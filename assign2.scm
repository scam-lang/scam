;Nicholas Green
;Mark Hale
;Assignment 2

;(include "table.scm")
(include "reflection.lib")
;**********************RUN1***************
(define (polar r theta) (list 'polar r theta) )

(define (rect x y)      (list 'rect x y) )

(define old+ +)

(define (+ a b)
  (define (p-to-r p)
    (list 'rect (* (cadr p) (cos (caddr p))) (* (cadr p) (sin (caddr p))))
    )
  (define (r-to-p r)
    (define (square x) (* x x))
    (define x (cadr r))
    (define y (caddr r))
    (list 'polar 
        (sqrt (old+   (square (cadr r)) (square (caddr r))))
        (atan (caddr r) (cadr r))
      )
    )
  (define (add-rect a b)
    (list 'rect (old+ (cadr a) (cadr b)) (old+ (caddr a) (caddr b)))
    )
  (if (and (is? a 'CONS) (is? b 'CONS))
    (cond
      ((eq? (car a) 'polar)
        (cond
          ((eq? (car b) 'polar)
            (r-to-p (add-rect (p-to-r a) (p-to-r b)))
            )
          ((eq? (car b) 'rect)
            (r-to-p (add-rect (p-to-r a) b)))
          )
        )
      ((eq? (car a) 'rect)
        (cond
          ((eq? (car b) 'polar)
            (add-rect a (p-to-r b))
            )
          ((eq? (car b) 'rect)
            (add-rect a b))
          )
        )
      )
    (old+ a b)
    )    
  )
(define (run1)
  (inspect (+ 2 3))
  (println "    [it should be 5]")
  (inspect (+ (polar 1 .707) (polar 1 .707)))
  (println "    [it should be magnitude 2 and angle .707]")
  )


;**********************RUN2***************

(define (identity x) x)

(define (increment number)
  (define (next-higher-number incrementer)
    (define (resolve base)
      (incrementer ((number incrementer) base))
      )
    resolve
    )
  next-higher-number
  )
  
(define (inc x) (cons 'x x))
(define base ())


(define zero  (lambda (f) (lambda (x) x)))
(define one   (lambda (f) (lambda (x) (f x))))
(define two   (lambda (f) (lambda (x) (f (f x)))))
(define three (lambda (f) (lambda (x) (f (f (f x))))))
(define four  (lambda (f) (lambda (x) (f (f (f (f x)))))))
(define five  (lambda (f) (lambda (x) (f (f (f (f (f x))))))))
(define six   (lambda (f) (lambda (x) (f (f (f (f (f (f x)))))))))
(define seven (lambda (f) (lambda (x) (f (f (f (f (f (f (f x))))))))))
(define eight (lambda (f) (lambda (x) (f (f (f (f (f (f (f (f x)))))))))))
(define nine  (lambda (f) (lambda (x) (f (f (f (f (f (f (f (f (f x))))))))))))


(define numbers
  (list
    (list ((zero  inc) base) 'zero)
    (list ((one   inc) base) 'one)
    (list ((two   inc) base) 'two)
    (list ((three inc) base) 'three)
    (list ((four  inc) base) 'four)
    (list ((five  inc) base) 'five)
    (list ((six   inc) base) 'six)
    (list ((seven inc) base) 'seven)
    (list ((eight inc) base) 'eight)
    (list ((nine  inc) base) 'nine)
    )
  )
  
(define (add a b)
  (lambda (f)
    (lambda (x)
      ( (b f) ( (a f) x)))))

(define (translate number)
  (cadr (assoc ((number inc) base) numbers))
  )
(define (run2)
  (inspect add)
  (println)
  (inspect numbers)
  (println)
  (inspect (translate (add two three)))
  (println "    [it should be five]\n")
  )
;**********************RUN3***************

(define (define->lambda source)
    (define  a (lambda ( (cdr (car (cdr source))))
      $(car (cdr (cdr (cdr source)))))
      )
    
    (list (car source) (car (car (cdr source))) (list 'lambda (cdr (car (cdr source)))
      (car (cdr (cdr source)))))
  )
(define (run3)
  (inspect (define->lambda '(define (plus a b) (old+ a b))))
  (println "    [it should be (define plus (lambda (a b) (+ a b)))]\n")
  )
;**********************RUN4***************
(define (extractor @)
  (lambda (x)
    (define (iter x @)
      (cond
        ((eq? (car @) nil) x)
        ((eq? (car (car @)) 0)
          (if (eq? (cdr (car @)) nil)
            (car x)
            (iter (car x) (cdr (car @)))
            )
          )
        ((eq? (car (car @)) 1) 
          (if (eq?  (cdr (car @)) nil)
            (car x)
            (iter (cdr x) (cdr (car @)))
            )
          )
        )
      )
      (iter x @)     
    )
  )

(define (run4)
  (inspect ((extractor 1 1 0) '(1 2 3 4 5)))
  (println "    [it should be 3]")
  )
;**********************RUN5***************
(define (accumulate op initial sequence)
	(if (null? sequence)
		initial
		(op (car sequence) (accumulate op initial (cdr sequence)))))

(define (accumulate-n op init seqs)
	(if (null? (car seqs))
		'()
		(cons (accumulate op init (map (lambda (x) (car x)) seqs)) (accumulate-n op init (map (lambda (x) (cdr x)) seqs)))))

(define (dot-product v w)
	(accumulate old+ 0 (map * v w)))

(define (matrix-*-vector m v)
	(define matrix1 (transpose m))
	(define vector1 (transpose v))
	(transpose(map (lambda (x) (dot-product x vector1)) matrix1)))

(define (transpose mat)
	(accumulate-n cons '() mat))

(define (matrix-*-matrix m n)
	(define matrix1 (transpose m))
	(define matrix2 (transpose n))
	(let ((cols (transpose matrix2)))
		(transpose(map (lambda (x) (map (lambda (y) (dot-product x y)) cols)) matrix1))))

(define (run5)
	(inspect (matrix-*-matrix '((1 2) (3 4))'((1 0) (0 1))))
  (println "    [it should be ((1 2) (3 4))]\n")
)

;**********************RUN6***************

(define (infix->postfix express)
  (define opList '(^ / * - +))
  (define (iter ex)
    (if(eq? (cdr ex) nil) ex)
    (if(eq? (car ex) '$)
      (if(eq? (car ex) '#)
        (cdr ex)
        (iter (cdr ex))
        )
      ex)
    )  
  (define (conser ex)
    (if(eq? (car ex) '#)
      (cons ex '#))
    (if(eq? (car ex) '$)
      (cons '$ (conser (cadr ex)))
      (car ex)
      )
    )
  (define (helper expr op worker)
    (if(eq? (cdddr expr) nil)
      worker
      (cond
        ((eq? (cadr expr) op)
          (begin 
          (if(eq? (caddr expr) '$)
            (cons worker (helper (iter(cddr expr)) op (list '$ (car expr) (conser (cddr expr)) (cadr expr) '#)))
            (cons worker (helper (cddr expr) op (list '$ (car expr) (conser (cddr expr)) (cadr expr) '#)))
            )
          )
          )
        (else
          (helper (cdr expr) op worker))
        )
      )
    )
  (define (op_iter ops worker)
    (if (null? ops)
      worker
      (begin
        (op_iter (cdr ops) (list  (helper express (car ops) worker)))
        )
      )
    );end opt_iter
  (op_iter opList express)
  )

(define (run6)
  (inspect (infix->postfix '(2 + 3 * x ^ 5 + a)))
  (println "    [it should be (2 3 x 5 ^ * a + +) or equivalent]\n")
  )
;**********************RUN7***************


(define (calcsize lst)
	(define (ccalcsize lst size)
		(cond
			((equal? lst '()) size)
			(#t (ccalcsize (cdr lst) (+ size 1)))
		)
	)
	(ccalcsize lst 0)
)

(define (zeros n)
	(define (zzeros lst n)
		(cond
			((equal? n 0) lst)
			(#t (zzeros (cons 0 lst) (- n 1)))
		)
	)
	(zzeros '() n)
)

(define (rightmost_one lst)
	(define (rrightmost_one lst curIndex index)
		(cond
			((equal? lst '()) index)
			((equal? (car lst) 1) (rrightmost_one (cdr lst) (+ curIndex 1) (+ curIndex 1)))
			(#t (rrightmost_one (cdr lst) (+ curIndex 1) index))
		)
	)
	(rrightmost_one lst 0 0)
)

(define (setone lst index)
	(cond
		((equal? index 0) (cons 1 (cdr lst)))
		(#t (cons (car lst) (setone (cdr lst) (- index 1))))
	)
)

(define (formfunction lst size)
	(define (fformfunction lst size)
		(define (ffformfunction lst ret size index)
			(cond
				((equal? (+ size 1) index) ret)
				(#t (ffformfunction lst (cons (setone lst size) ret) (- size 1) index))
			)
		)
		(ffformfunction lst '() (- size 1) (rightmost_one lst))
	)
	(cond
		((equal? lst '()) '())
		((number? (car lst)) (fformfunction lst size))
		(#t (append (formfunction (car lst) size) (formfunction (cdr lst) size)))
	)
)

(define (nextf size n)
	(define (nextff lst size n)
		(cond
			((equal? n 0) lst)
			(#t (nextff (formfunction lst size) size (- n 1)))
		)
	)
	(nextff (list (zeros size)) size n)
)

(define (powermap size)
	(define (ppowermap lst size n)
		(cond
			((equal? n size) (append lst (nextf size n)))
			(#t (ppowermap (append lst (nextf size n)) size (+ n 1)))
		)
	)

	(ppowermap '() size 0)
)

(define (subset set binmap)
	(cond
		((equal? binmap '()) '())
		((equal? (car binmap) 0) (subset (cdr set) (cdr binmap)))
		(#t (cons (car set) (subset (cdr set) (cdr binmap))))
	)
)

(define (powerSet set)
	(define (ppowerSet set pmap)
		(cond
			((equal? pmap '()) '())
			(#t (cons (subset set (car pmap)) (ppowerSet set (cdr pmap))))
		)
	)
	(cdr (ppowerSet set (powermap (calcsize set))))
)

(define (run7)
  (inspect (powerSet '(a b)))
  (println "    [it should be (() (a) (b) (a b))]")
)

;***************END RUN7******************************
;***************RUN8**********************************

(define (newTree) ())
(define (treeNode value left right)
  (list 'binaryTree value left right)
  )
  
(define (depthStat x)
  (define (isLeaf node)
    (if (and (eq? (caddr node) nil) (eq? (cadddr node) nil))
      #t
      #f)
    );end isLeaf
  (define (countLeaves x)
    (cond
      ((null? x) 0)
      ((eq? (isLeaf x) #t) 1)
      (else (+ (countLeaves (caddr x))
               (countLeaves (cadddr x)))
        )
      )
    );end countLeaves
  (define (totalDepths tree)
    (define (counter x cnt)
      (cond
        ((null? x) 0)
        ((eq? (isLeaf x) #t) cnt)
        (else (old+ (counter (caddr x) (old+ cnt 1))
          (counter (cadddr x) (old+ cnt 1))))
        )
      )
    (counter tree 0)
    );end totalDepths
  ;Execute
  (/ (* (totalDepths x) 1.0) (countLeaves x))
  )
  
  
  
  
  
(define (run8)
  (inspect
      (depthStat (treeNode 1 (treeNode 1 nil nil) (treeNode 1 nil nil)))
      )
  (println "    [it should be 1.0]\n")
  )
  
;***************RUN 9********************************

(define square (lambda(x) (* x x)))
(define newold+ +)
(define (+ a b)
  (if (and (is? a 'object) (is? b 'object))    
    (begin
      (define atype (car(dot a data)))
      (define btype (car(dot b data)))

      (cond
        ((eq? atype 'Integer)
          (cond
            ((eq? btype 'Integer)
              ((dot a add) b))
            ((eq? btype 'Real)
              ((dot b add) (dot a promote)))
            ((eq? btype 'Rectangular)
              ((dot b add) (dot (dot a promote) promote)))
            ((eq? btype 'Polar)
              ((dot b add) (dot (dot (dot a promote) promote) convert)))
            )
          )
        ((eq? atype 'Real)
          (cond
            ((eq? btype 'Integer)
              ((dot a add) (dot b promote))
              )
            ((eq? btype 'Real)
              ((dot b add) a))
            ((eq? btype 'Rectangular)
              ((dot b add)  (dot a promote)))
            ((eq? btype 'Polar)
              ((dot b add) (dot (dot a promote) convert)))
            )
          )
        ((eq? atype 'Rectangular)
          (cond
            ((eq? btype 'Integer)
              ((dot a add) (dot (dot b promote) promote)))
            ((eq? btype 'Real)
              ((dot a add) (dot b promote)))
            ((eq? btype 'Rectangular)
              ((dot a add) b))
            ((eq? btype 'Polar)
              ((dot a add) (dot b convert)))
            )
          )
        ((eq? atype 'Polar)
          (cond
            ((eq? btype 'Integer)
              ((dot a add) (dot (dot (dot b promote) promote))))
            ((eq? btype 'Real)
              ((dot a add) (dot b promote)))
            ((eq? btype 'Rectangular)
              ((dot a add)  b))
            ((eq? btype 'Polar)
              ((dot a add) b))
            )
          )
        )
      )
     (newold+ a b)
    )
  )
(define (Integer value_param)
  (define data (list 'Integer value_param)
    )
  (define (add x)
    (if (eq? (car(dot x data)) 'Integer)
      (Integer (old+ (dot x value_param) value_param))
      (add ((dot x demote)))
      )
    )
  (define (promote)
    (Real value_param)
    )
  (define (demote)
    (Integer value_param)
    )
  (define (toString)
    (string+ (string value_param))
    )
  (define (value)
    value_param
    )
  this
  )

(define (Real value_param)
  (define data (list 'Real value_param)
    )
  (define (add x)
    (if (eq? (car(dot x data)) 'Real)
      (Real (old+ (dot x value_param) value_param))
      (if (eq? (car(dot x data)) 'Integer)
        (add ((dot x promote)))
        (add ((dot x demote)))
        )
      )
    )
  (define (promote)
    (Rectangular value_param 0)
    )
  (define (demote)
    (define (real_to_int count total)
	  (define (count_above count total)
		  (if (<= count total)
			  (count_above (+ count 1) total)
			  (- count 1)
		  )
	  )
	  (define (count_below count total)
		  (if (>= count total)
			  (count_below (- count 1) total)
			  (+ count 1)
		  )
	  )
	  (cond
		  ((= total 0) 0)
		  ((< total 0) (count_below 0 total))
		  ((> total 0) (count_above 0 total))
	  )
  )
    (Integer (real_to_int 0 value_param))
    )
  (define (toString)
    (string+ (string value_param))
    )
  (define (value)
    value_param
    ) 
  this
  )
(define (Rectangular v1 v2)
  (define value_param (cons v1 v2))
  (define data (list 'Rectangular v1 v2))
  (define (add x)
    (if (eq? (car (dot x data)) 'Rectangular)
      (Rectangular (old+ (car value_param) (car (dot x value_param)))
        (old+ (cdr value_param) (cdr (dot x value_param))))
      (if (eq? (car (dot x data)) 'Polar)
        (add ((dot x convert)))
        (add ((dot x promote)))
        )
      )
    )
  (define (promote)
    (Rectangular v1 v2)
    )
  (define (demote)
    (Real v1)
    )
  (define (convert)
    (Polar (sqrt(old+ (square v1) (square v2))) (atan v2 v1))
    )
  (define (toString)
    (string+ (string value_param))
    )
  (define (value)
    value_param
    )
  this
  )
  
(define (Polar mag ang)
  (define value_param (cons mag ang))
  (define data (list 'Polar mag ang))
  (define (add x)
    (if (eq? (car (dot x data)) 'Polar)
      (begin
        (define xrval
          (old+ 
            (* (car value_param)         (cos (cdr value_param)))
            (* (car (dot x value_param)) (cos (cdr (dot x value_param))))
            )
            )
        (define yrval
          (old+ 
            (* (car value_param)         (sin (cdr value_param)))
            (* (car (dot x value_param)) (sin (cdr (dot x value_param))))
            )
          )
        (Polar (sqrt(old+ (square xrval) (square yrval))) (atan yrval xrval))
      )
      (if (eq? (car (dot x data)) 'Rectangular)
        (add ((dot x convert)))
        (add ((dot x promote)))
        )
      )
    )    
  (define (promote)
    (Polar mag ang)
    )
  (define (demote)
    (Real (* mag (cos ang)))
    )
  (define (convert)
    (Rectangular (* mag (cos ang)) (* mag (sin ang)))
    )
  (define (toString)
    (string+ (string value_param))
    )
  (define (value)
    value_param
    )
  this
  )
(define (run9)
  (inspect (+ 2 3))
  (println "    [it should be 5]\n")
  (inspect ((dot (+ (Polar 1 .707) (Polar 1 .707)) toString)))
  (println "    [it should be magnitude 2 and angle .707]\n")
  (inspect ((dot (+ (Rectangular 1 1) (Integer 1)) toString)))
  (println "    [it should be real 2 and imaginary 1]\n")
  (inspect ((dot (+ (Real 2.3) (Integer 1)) value)))
  (println "    [it should be real 3.3]\n")
)

;***************RUN 10 ******************************
;(put '(Integer Integer) (lambda(x) x))
;(put '(Integer Real) (lambda (x) x))
;(put '(Integer Rectangular) (lambda(x) ((dot ((dot x promote)) promote))))
;(put '(Integer Polar) (lambda(x) ((dot ((dot ((dot x promote)) promote)) convert))))
;(put '(Real Integer) (lambda(x) ((dot x demote))))
;(put '(Real Real) (lambda(x) x))
;(put '(Real Rectangular) (lambda(x) ((dot x promote))))
;(put '(Real Polar) (lambda(x) ((dot ((dot x promote)) convert))))
;(put '(Rectangular Integer) (lambda(x) ((dot ((dot x demote)) demote))))
;(put '(Rectangular Real) (lambda(x) ((dot x demote))))
;(put '(Rectangular Polar) (lambda(x) ((dot x convert))))
;(put '(Rectangular Rectangular) (lambda(x) x))
;(put '(Polar Integer) (lambda(x) ((dot ((dot ((dot x convert)) demote)) demote))))
;(put '(Polar Real) (lambda(x) ((dot ((dot x convert)) demote))))
;(put '(Polar Rectangular) (lambda(x) ((dot x convert))))
;(put '(Polar Polar) (lambda(x) x))
;
;
;(define (coerce a b)
;  ((get(list (car (dot a data)) b))a)
;  )
;
;(define (run10)
;  (inspect ((dot (Real 5) value)))
;  (inspect ((dot (coerce (Polar 5 36) 'Real) value)))
;  (println "[it should be real 5.0]\n")
;)
;
(println "Assignment 2 loaded!")
