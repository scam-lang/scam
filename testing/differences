OLD vs. NEW
heapsort.s
------------------------------------------
1c1,2
< include("basics");
---
> (define (heap items op)
>     (define size (length items))
3,21c4,17
< function heap(items,op)
<     {
<     var size = length(items);
< 
<     function leftChild(x) { 2 * x + 1; }
<     function rightChild(x) { 2 * x + 2; }
<     function deleteMin()
<         {
<         var temp = items[0];
<         items[0] = items[size - 1];
<         items[size - 1] = temp;
<         size = size - 1;
<         heapify(0);
<         temp;
<         }
<     function heapify(root)
<         {
<         var extreme;
<         var newRoot;
---
>     (define (leftChild x) (+ (* 2 x) 1))
>     (define (rightChild x) (+ (* 2 x) 2))
>     (define (deleteExtreme)
>         (define temp (getElement items 0))
>         (setElement items 0 (getElement items (- size 1)))
>         (setElement items (- size 1) temp)
>         (set! size (- size 1))
>         (heapify 0)
>         temp
>         )
> 
>     (define (heapify root)
>         (define extreme nil)
>         (define newRoot nil)
23c19
<         if (leaf?(root)) { return :ok; }
---
>         (if (leaf? root) (return 'ok))
25c21
<         extreme = findExtremalChild(root);
---
>         (set! extreme (findExtremalChild root))
27c23
<         if (extreme == items[root]) { return :ok; }
---
>         (if (== extreme (getElement items root)) (return 'ok))
29,92c25,79
<         if (extreme == items[leftChild(root)])
<             {
<             newRoot = leftChild(root);
<             }
<         else
<             {
<             newRoot = rightChild(root);
<             }
<         items[newRoot] = items[root];
<         items[root] = extreme;
<         heapify(newRoot);
<         }
<     function findExtremalChild(root)
<         {
<         var extreme;
< 
<         extreme = extremal(op,items[root],items[leftChild(root)]);
< 
<         if (rightChild(root) >= size)
<             {
<             extreme;
<             }
<         else
<             {
<             extremal(op,extreme,items[rightChild(root)]);
<             }
<         }
<     function build-heap()
<         {
<         var i;
< 
<         for (i = size - 1, i >= 0, i = i - 1)
<             {
<             heapify(i);
<             }
<         }
< 
<     function leaf?(x)
<         {
<         leftChild(x) >= size;
<         }
< 
<     build-heap();
<     this;
<     }
< 
< function heap-sort(items,op)
<     {
<     var i;
<     var h;
< 
<     h = heap(items,op);
< 
<     while (h . size > 0)
<         {
<         print(h . deleteMin());
<         if (h . size > 0,print(" "));
<         }
<     }
< 
< function extremal(op,a,b)
<     {
<     if (a op b,a,b);
<     }
---
>         (if (== extreme (getElement items (leftChild root)))
>             (set! newRoot (leftChild root))
>             (set! newRoot (rightChild root))
>             )
> 
>         (setElement items newRoot (getElement items root))
>         (setElement items root extreme)
>         (heapify newRoot)
>         )
> 
>     (define (findExtremalChild root)
>         (define extreme nil)
>         (set! extreme 
>             (extremal op
>                 (getElement items root)
>                 (getElement items (leftChild root))))
> 
>         (if (>= (rightChild root) size)
>             extreme
>             (extremal op extreme (getElement items (rightChild root)))
>             )
>         )
> 
>     (define (build-heap)
>         (define i nil)
>         (for (set! i (- size 1)) (>= i 0) (set! i (- i 1))
>             (println "heapifying element " i)
>             (heapify i)
>             (println "element " i " has been heapified")
>             )
>         )
> 
>     (define (leaf? x) (>= (leftChild x) size))
> 
>     (println "about to build-heap...")
>     (build-heap)
>     this
>     )
> 
> (define (heap-sort items op)
>     (define i nil)
>     (define h nil)
> 
>     (set! h (heap items op))
> 
>     (while (> (get 'size h) 0)
>         (print ((get 'deleteExtreme h)))
>         (if (> (get 'size h) 0) (print " "))
>         )
>     (println "\n")
>     )
> 
> (define (extremal op a b)
>     (if (op a b) a b)
>     )
94c81
< var a = array(3,6,3,9,4,10,5,29,4,6,0,20,25,16,88,0,31);
---
> (define a (array 3 6 3 9 4 10 5 29 4 6 0 20 25 16 88 0 31))
96,97c83
< heap-sort(a,>);
< println("\n");
---
> (heap-sort a >)
99,100c85,86
< inspect(a);
< inspect(extremal . parameters);
---
> (inspect a)
> (inspect (get 'parameters extremal))
102c88,90
< 88 31 29 25 20 16 10 9 6 6 5 4 4 3 3 0 0
---
> about to build-heap...
> heapifying element 16
> 3 31 6 88 16 25 20 9 29 6 4 5 10 4 3 0 0
104,105c92,93
< a is [0,0,3,3,4,4,5,6,6,9,10,16,20,25,29,31,88]
< extremal . parameters is (op,a,b)
---
> a is [0,0,3,4,10,5,4,6,29,9,20,25,16,88,6,31,3]
> (get (quote parameters) extremal) is (op a b)
------------------------------------------
