OLD vs. NEW
rb.s
------------------------------------------
1,365c1,330
< include("debug");
< 
< var root = :null;
< 
< function node(value,left,right)
<     {
<     var parent;
<     var color;
< 
<     function display()
<         {
<         println("value:  ", value);
<         println("left:   ", left);
<         println("right:  ", right);
<         println("parent: ", parent);
<         println("color:  ", color);
<         }
< 
<     this;
<     }
< 
< function printTree(t)
<     {
<     function iter(r, indent)
<         {
<         if (r == :null)
<             {
<             println("null");
<             }
<         else
<             {
<             println(r . value, "(", r . color, ")");
<             print(indent, "left:  ");
<             iter(r . left,indent + "    ");
<             print(indent, "right: ");
<             iter(r . right,indent + "    ");
<             }
<         }
< 
<     iter(t, "   ");
<     }
< 
< function insert(t, v, op)
<     {
<     if (t == :null)
<         {
<         root = node(v,:null,:null);
<         root . parent = root;
<         insertionFixup(root);
<         }
<     else
<         {
<         var lessThan = v op t . value;
< 
<         if (lessThan && t . left != :null)
<             {
<             insert(t . left, v, op);
<             }
<         else if (lessThan)
<             {
<             t . left = node(v,:null,:null);
<             t . left . parent = t;
<             insertionFixup(t . left);
<             }
<         else if (t . right != :null)
<             {
<             insert(t . right, v, op);
<             }
<         else
<             {
<             t . right = node(v, :null, :null);
<             t . right . parent = t;
<             insertionFixup(t . right);
<             }
<         }
<     }
< 
< function prune(x)
<     {
<     assert(leaf?(x) == :true);
<     if (leftChild?(x))
<         {
<         parent(x) . left = :null;
<         }
<     else if (rightChild?(x))
<         {
<         parent(x) . right = :null;
<         }
<     else
<         {
<         root = :null;
<         }
<     }
< 
< function swapToLeaf(x)
<     {
<     if (leaf?(x) == :false)
<         {
<         var y;
<         var temp;
< 
<         if (x . right != :null)
<             {
<             y = findMin(x . right);
<             }
<         else
<             {
<             y = findMax(x . left);
<             }
< 
<         temp = x . value;
<         x . value = y . value;
<         y . value = temp;
< 
<         swapToLeaf(y);
<         }
<     else
<         {
<         x;
<         }
<     }
< function findMin(x)
<     {
<     while (x . left != :null)
<         {
<         x = x . left;
<         }
<     return x;
<     }
< function findMax(x)
<     {
<     while (x . right != :null)
<         {
<         x = x . right;
<         }
<     return x;
<     }
< function delete(x)
<     {
<     x = swapToLeaf(x);
<     deletionFixup(x);
<     //println("pruning ", x . value);
<     prune(x);
<     }
< 
< function deletionFixup(x)
<     {
<     while (root?(x) == :false && x . color == :black)
<         {
<         if (red?(sibling(x)))
<             {
<             parent(x) . color = :red;
<             sibling(x) . color = :black;
<             rotate(sibling(x),parent(x));
<             // should have black sibling now
<             assert(sibling(x) . color == :black);
<             }
<         else if (red?(nephew(x)))
<             {
<             sibling(x) . color = parent(x) . color;
<             parent(x) . color = :black;
<             nephew(x) . color = :black;
<             rotate(sibling(x),parent(x));
<             x = root;
<             // subtree is bh balanced
<             // with proper bh contribution
<             }
<         else if (red?(niece(x)))
<             {
<             // nephew must be black
<             niece(x) = :black;
<             sibling(x) = :red;
<             rotate(neice(x),sibling(x));
<             // should have red nephew now
<             assert(nephew(x) . color == :red);
<             }
<         else
<             {
<             // sibling, niece, and nephew must be black
<             sibling(x) . color = :red;
<             x = parent(x);
<             // subtree is bh balanced
<             // but has deficit in bh contribution
<             }
<         }
< 
<     x . color = :black;
<     }
< 
< function insertionFixup(x)
<     {
<     x . color = :red;
< 
<     while (root?(x) == :false && x . parent . color == :red)
<         {
<         if (red?(uncle(x)))
<             {
<             parent(x) . color = :black;
<             uncle(x) . color = :black;
<             grandparent(x) . color = :red;
<             x = grandparent(x);
<             }
<         else
<             {
<             // uncle must be black
< 
<             if (linear?(x, parent(x), grandparent(x)) == :false)
<                 {
<                 var oldParent = parent(x);
<                 rotate(x,parent(x));
<                 x = oldParent;
<                 }
< 
<             parent(x) . color = :black;
<             assert(x . parent . color == :black);
<             grandparent(x) . color = :red;
<             rotate(parent(x),grandparent(x));
<             }
<         }
< 
<     root . color = :black;
<     }
< 
< function root?(x) { x == x . parent; }
< function leftChild?(x) { return parent(x) . left == x; }
< function rightChild?(x) { return parent(x) . right == x; }
< function leaf?(x) { x . left == :null && x . right == :null; }
< function red?(x) { return x != :null && x . color == :red; }
< function black?(x) { return x == :null || x . color == :black; }
< 
< function sibling(x)
<     {
<     if (leftChild?(x))
<         {
<         x . parent . right;
<         }
<     else if (rightChild?(x))
<         {
<         x . parent . left;
<         }
<     else
<         {
<         :null;
<         }
<     }
< function niece(x)       //precondition: sibling exists
<     {
<     if (leftChild?(x))
<         {
<         sibling(x) . left;
<         }
<     else
<         {
<         sibling(x) . right;
<         }
<     }
< function nephew(x)      //precondition: sibling exists
<     {
<     if (leftChild?(x))
<         {
<         sibling(x) . right;
<         }
<     else
<         {
<         sibling(x) . left;
<         }
<     }
< function parent(x) { x . parent; }
< function grandparent(x) { parent(x) . parent; }
< function uncle(x)
<     {
<     if (leftChild?(parent(x)))
<         {
<         return grandparent(x) . right;
<         }
<     else if (rightChild?(parent(x)))
<         {
<         return grandparent(x) . left;
<         }
<     else
<         {
<         return :null;
<         }
<     }
< function linear?(x,y,z)
<     {
<     return
<         ((leftChild?(x)  && leftChild?(y)) ||
<          (rightChild?(x) && rightChild?(y)));
<     }
< 
< 
< function rotate(x,p)
<     {
<     if (p . left == x) 
<         {
<         //rotate right
<         rotator(x,p,:right,:left);
<         }
<     else if (p . right == x)
<         {
<         //rotate left
<         rotator(x,p,:left,:right);
<         }
<     else
<         {
<         throw("rotate error");
<         }
<     }
< function rotator(x,p,direction,oppositeDirection)
<     {
<     var gp = parent(p);
<     var beta = x . (direction);
< 
<     p . (oppositeDirection) = beta;
<     if (beta != :null) { beta . parent = p; }
< 
<     x . (direction) = p;
<     p . parent = x;
< 
<     if (p == gp)
<         {
<         root = x;
<         x . parent = x;
<         }
<     else {
<         if (gp . (direction) == p) { gp . (direction) = x; }
<         else { gp . (oppositeDirection) = x; }
<         x . parent = gp;
<         }
<     }
< 
< function findNode(t, v, op)
<     {
<     if (t == :null || v == t . value)
<         {
<         t;
<         }
<     else if (v op t . value)
<         {
<         findNode(t . left, v, op);
<         }
<     else
<         {
<         findNode(t . right, v, op);
<         }
<     }
< 
< function main()
<     {
<     var i;
<     var num = :null;
<     var x;
<     var input = array(1, 2, 9, 3, 6, 4, 7, 8, 5);
< 
<     i = 0;
<     while (i < length(input))
<         {
<         num = input . i;
<         println("inserting!");
<         insert(root, num, <);
<         print(num," inserted.\n");
<         printTree(root);
<         i = i + 1;
<         }
---
> (define root nil)
> (define (assert # $x)
>     (if (not (eval $x #))
>         (throw 'assertionError $x)
>         )
>     )
> 
> (define (node value left right)
>     (define parent nil)
>     (define color nil)
> 
>     (define (display)
>         (println "value:  "  value)
>         (println "left:   "  left)
>         (println "right:  "  right)
>         (println "parent: "  parent)
>         (println "color:  "  color)
>         )
> 
>     this
>     )
> 
> (define (printTree t)
>     (define (iter r indent)
>         (if (null? r)
>             (println "null")
>             (begin
>                 (println (. r value)  "("  (. r color)  ")")
>                 (print indent "left:  ")
>                 (iter (. r left) (string+ indent "    "))
>                 (print indent  "right: ")
>                 (iter (. r right) (string+ indent "    "))
>                 )
>             )
>         )
> 
>     (iter t "   ")
>     )
> 
> (define (insert t v op)
>     (if (null? t)
>         (begin
>             (assign root (node v nil nil))
>             (assign (. root parent) root)
>             (insertionFixup root)
>             )
>         (begin
>             (define lessThan (op v (. t value)))
> 
>             (cond
>                 ((and lessThan (valid? (. t left)))
>                     (insert (. t left)  v  op)
>                     )
>                 (lessThan
>                     (assign (. t left) (node v nil nil))
>                     (assign (. (. t left) parent) t)
>                     (insertionFixup (. t left))
>                     )
>                 ((valid? (. t right))
>                     (insert (. t right)  v  op)
>                     )
>                 (else
>                     (assign (. t right) (node v nil nil))
>                     (assign (. (. t right) parent) t)
>                     (insertionFixup (. t right))
>                     )
>                 )
>             )
>         )
>     )
> (define (prune x)
>     (assert (leaf? x))
>     (cond
>         ((leftChild? x)
>             (assign (. (parent x) left) nil)
>             )
>         ((rightChild? x)
>             (assign (. (parent x) right) nil)
>             )
>         (else
>             (assign root nil)
>             )
>         )
>     )
> 
> (define (swapToLeaf x)
>     (if (not (leaf? x))
>         (begin
>             (define y nil)
>             (define temp nil)
> 
>             (if (valid? (. x right))
>                 (assign y (findMin (. x right)))
>                 (assign y (findMax (. x left)))
>                 )
> 
>             (assign temp (. x value))
>             (assign (. x value) (. y value))
>             (assign (. y value) temp)
> 
>             (swapToLeaf y)
>             )
>         x
>         )
>     )
> 
> (define (findMin x)
>     (while (valid? (. x left))
>         (assign x (. x left))
>         )
>     x
>     )
> 
> (define (findMax x)
>     (while (valid? (. x right))
>         (assign x (. x right))
>         )
>     x
>     )
> 
> (define (delete x)
>     (assign x (swapToLeaf x))
>     (deletionFixup x)
>     ; (println "pruning "  (. x value))
>     (prune x)
>     )
> 
> (define (deletionFixup x)
>     (while (and (false? (root? x)) (eq? (. x color) 'black))
>         (cond
>             ((red? (sibling x))
>                 (assign (. (parent x) color) 'red)
>                 (assign (. (sibling x) color) 'black)
>                 (rotate (sibling x) (parent x))
>                 ; should have black sibling now
>                 (assert (eq? (. (sibling x) color) 'black))
>                 )
>             ((red? (nephew x))
>                 (assign (. (sibling x) color) (. (parent x) color))
>                 (assign (. (parent x) color) 'black)
>                 (assign (. (nephew x) color) 'black)
>                 (rotate (sibling x) (parent x))
>                 (assign x root)
>                 ; subtree is bh balanced
>                 ; with proper bh contribution
>                 )
>             ((red? (niece x))
>                 ; nephew must be black
>                 (assign (. (niece x) color) 'black)
>                 (assign (. (sibling x) color) 'red)
>                 (rotate (niece x) (sibling x))
>                 ; should have red nephew now
>                 (assert (eq? (. (nephew x) color) 'red))
>                 )
>             (else
>                 ; sibling  niece  and nephew must be black
>                 (assign (. (sibling x) color) 'red)
>                 (assign x (parent x))
>                 ; subtree is bh balanced
>                 ; but has deficit in bh contribution
>                 )
>             )
> 
>         (assign (. x color) 'black)
>         )
>     )
> 
> (define (insertionFixup x)
>     (assign (. x color) 'red)
> 
>     (while (and (not (root? x)) (eq? (. (. x parent) color) 'red))
>         (if (red? (uncle x))
>             (begin
>                 (assign (. (parent x) color) 'black)
>                 (assign (. (uncle x) color) 'black)
>                 (assign (. (grandparent x) color) 'red)
>                 (assign x (grandparent x))
>                 )
>             (begin
>                 ; uncle must be black
> 
>                 (if (not (linear? x (parent x) (grandparent x)))
>                     (begin
>                         (define oldParent (parent x))
>                         (rotate x (parent x))
>                         (assign x oldParent)
>                         )
>                     )
> 
>                 (assign (. (parent x) color) 'black)
>                 ;(inspect (. (parent x) color))
>                 (assert (eq? (. (. x parent) color) 'black))
>                 (assign (. (grandparent x) color) 'red)
>                 (rotate (parent x) (grandparent x))
>                 )
>             )
>         )
>     (assign (. root color) 'black)
>     )
> 
> (define (root? x) (eq? x (. x parent)))
> (define (leftChild? x) (eq? (. (parent x) left) x))
> (define (rightChild? x) (eq? (. (parent x) right) x))
> (define (leaf? x) (and (null? (. x left))(null? (. x right))))
> (define (red? x) (and (valid? x) (eq? (. x color) 'red)))
> (define (black? x) (or  (null? x) (eq? (. x color) 'black)))
> 
> (define (sibling x)
>     (cond
>         ((leftChild? x)
>             (. (. x parent) right)
>             )
>         ((rightChild? x)
>             (. (. x parent) left)
>             )
>         (else
>             nil
>             )
>         )
>     )
> 
> (define (niece x)       ; precondition: sibling exists
>     (if (leftChild? x)
>         (. (sibling x) left)
>         (. (sibling x) right)
>         )
>     )
> 
> (define (nephew x)      ; precondition: sibling exists
>     ;(inspect (sibling x))
>     (if (leftChild? x)
>         (. (sibling x) right)
>         (. (sibling x) left)
>         )
>     )
> 
> (define (parent x) (. x parent))
> (define (grandparent x) (parent (parent x)))
> (define (uncle x)
>     (cond
>         ((leftChild? (parent x))
>             (. (grandparent x) right))
>         ((rightChild? (parent x))
>             (. (grandparent x) left))
>         (else
>             nil)
>         )
>     )
> 
> (define (linear? x y z)
>     (or
>         (and (leftChild? x) (leftChild? y))
>         (and (rightChild? x) (rightChild? y))
>         )
>     )
> 
> (define (rotate x p)
>     (cond
>         ((eq? (. p left) x) 
>             ; rotate right
>             (println "rotating right")
>             (rotator x p 'right 'left)
>             )
>         ((eq? (. p right) x)
>             ; rotate left
>             (println "rotating left")
>             (rotator x p 'left 'right)
>             )
>         (else
>             (throw 'redBlackException "rotate error")
>             )
>         )
>     )
> 
> (define (id x) x)
> 
> (define (rotator x p direction oppositeDirection)
>     (define gp (parent p))
>     (define beta (. x (id direction)))
> 
>     (assign (. p (id oppositeDirection)) beta)
>     (if (valid? beta) (assign (. beta parent) p))
> 
>     (assign (. x (id direction)) p)
>     (assign (. p parent) x)
> 
>     (if (eq? p gp)
>         (begin
>             (assign root x)
>             (assign (. x parent) x)
>             )
>         (begin
>             (if (eq? (. gp (id direction)) p)
>                 (assign (. gp (id direction)) x)
>                 (assign (. gp (id oppositeDirection)) x)
>                 )
>             (assign (. x parent) gp)
>             )
>         )
>     )
> 
> (define (findNode t v op)
>     (cond
>         ((or (null? t) (eq? v (. t value)))
>             t
>             )
>         ((op v (. t value))
>             (findNode (. t left) v op)
>             )
>         (else
>             (findNode (. t right) v op)
>             )
>         )
>     )
> 
> (define (main)
>     (define i nil)
>     (define num nil)
>     (define x nil)
>     (define input (array 1  2  9  3  6  4  7  8  5))
> 
>     (assign i 0)
>     (while (< i (length input))
>         (assign num (getElement input i))
>         (println "inserting!")
>         (insert root num <)
>         (println num " inserted.")
>         (printTree root)
>         (assign i (+ i 1))
>         )
367,384c332,348
<     println("insertion phase complete, tree is...");
<     printTree(root);
<     println("deletion phase begins...");
< 
<     i = 0;
<     while (i < length(input))
<         {
<         num = input . i;
<         x = findNode(root,num,<);
<         delete(x);
<         print(num," deleted.\n");
<         printTree(root);
<         i = i + 1;
<         }
< 
<     println("deletion phase complete, tree is...");
<     print("good-bye!\n");
<     }
---
>     (println "insertion phase complete  tree is...")
>     (printTree root)
>     (println "deletion phase begins...")
> 
>     (assign i 0)
>     (while (< i (length input))
>         (assign num (getElement input i))
>         (assign x (findNode root num <))
>         (delete x)
>         (println num " deleted.")
>         (printTree root)
>         (assign i (+ i 1))
>         )
> 
>     (println "deletion phase complete  tree is...")
>     (println "good-bye!")
>     )
386,387c350,351
< print("hello\n");
< main();
---
> (println "hello");
> (main)
390,619c354,356
< inserting!
< 1 inserted.
< 1(black)
<    left:  null
<    right: null
< inserting!
< 2 inserted.
< 1(black)
<    left:  null
<    right: 2(red)
<        left:  null
<        right: null
< inserting!
< 9 inserted.
< 2(black)
<    left:  1(red)
<        left:  null
<        right: null
<    right: 9(red)
<        left:  null
<        right: null
< inserting!
< 3 inserted.
< 2(black)
<    left:  1(black)
<        left:  null
<        right: null
<    right: 9(black)
<        left:  3(red)
<            left:  null
<            right: null
<        right: null
< inserting!
< 6 inserted.
< 2(black)
<    left:  1(black)
<        left:  null
<        right: null
<    right: 6(black)
<        left:  3(red)
<            left:  null
<            right: null
<        right: 9(red)
<            left:  null
<            right: null
< inserting!
< 4 inserted.
< 2(black)
<    left:  1(black)
<        left:  null
<        right: null
<    right: 6(red)
<        left:  3(black)
<            left:  null
<            right: 4(red)
<                left:  null
<                right: null
<        right: 9(black)
<            left:  null
<            right: null
< inserting!
< 7 inserted.
< 2(black)
<    left:  1(black)
<        left:  null
<        right: null
<    right: 6(red)
<        left:  3(black)
<            left:  null
<            right: 4(red)
<                left:  null
<                right: null
<        right: 9(black)
<            left:  7(red)
<                left:  null
<                right: null
<            right: null
< inserting!
< 8 inserted.
< 2(black)
<    left:  1(black)
<        left:  null
<        right: null
<    right: 6(red)
<        left:  3(black)
<            left:  null
<            right: 4(red)
<                left:  null
<                right: null
<        right: 8(black)
<            left:  7(red)
<                left:  null
<                right: null
<            right: 9(red)
<                left:  null
<                right: null
< inserting!
< 5 inserted.
< 2(black)
<    left:  1(black)
<        left:  null
<        right: null
<    right: 6(red)
<        left:  4(black)
<            left:  3(red)
<                left:  null
<                right: null
<            right: 5(red)
<                left:  null
<                right: null
<        right: 8(black)
<            left:  7(red)
<                left:  null
<                right: null
<            right: 9(red)
<                left:  null
<                right: null
< insertion phase complete, tree is...
< 2(black)
<    left:  1(black)
<        left:  null
<        right: null
<    right: 6(red)
<        left:  4(black)
<            left:  3(red)
<                left:  null
<                right: null
<            right: 5(red)
<                left:  null
<                right: null
<        right: 8(black)
<            left:  7(red)
<                left:  null
<                right: null
<            right: 9(red)
<                left:  null
<                right: null
< deletion phase begins...
< 1 deleted.
< 6(black)
<    left:  4(red)
<        left:  2(black)
<            left:  null
<            right: 3(red)
<                left:  null
<                right: null
<        right: 5(black)
<            left:  null
<            right: null
<    right: 8(black)
<        left:  7(red)
<            left:  null
<            right: null
<        right: 9(red)
<            left:  null
<            right: null
< 2 deleted.
< 6(black)
<    left:  4(red)
<        left:  3(black)
<            left:  null
<            right: null
<        right: 5(black)
<            left:  null
<            right: null
<    right: 8(black)
<        left:  7(red)
<            left:  null
<            right: null
<        right: 9(red)
<            left:  null
<            right: null
< 9 deleted.
< 6(black)
<    left:  4(red)
<        left:  3(black)
<            left:  null
<            right: null
<        right: 5(black)
<            left:  null
<            right: null
<    right: 8(black)
<        left:  7(red)
<            left:  null
<            right: null
<        right: null
< 3 deleted.
< 6(black)
<    left:  4(black)
<        left:  null
<        right: 5(red)
<            left:  null
<            right: null
<    right: 8(black)
<        left:  7(red)
<            left:  null
<            right: null
<        right: null
< 6 deleted.
< 7(black)
<    left:  4(black)
<        left:  null
<        right: 5(red)
<            left:  null
<            right: null
<    right: 8(black)
<        left:  null
<        right: null
< 4 deleted.
< 7(black)
<    left:  5(black)
<        left:  null
<        right: null
<    right: 8(black)
<        left:  null
<        right: null
< 7 deleted.
< 8(black)
<    left:  5(red)
<        left:  null
<        right: null
<    right: null
< 8 deleted.
< 5(black)
<    left:  null
<    right: null
< 5 deleted.
< null
< deletion phase complete, tree is...
< good-bye!
---
> ------------------------------------
> EXCEPTION: undefinedVariable
> file rb.s,line 322: variable assign is undefined
------------------------------------------
recur.s
------------------------------------------
32c32,34
< 5050
---
> ------------------------------------
> EXCEPTION: undefinedVariable
> file recur.s,line 1: variable function is undefined
------------------------------------------
recursion.s
------------------------------------------
23,423c23,25
< 399
< 398
< 397
< 396
< 395
< 394
< 393
< 392
< 391
< 390
< 389
< 388
< 387
< 386
< 385
< 384
< 383
< 382
< 381
< 380
< 379
< 378
< 377
< 376
< 375
< 374
< 373
< 372
< 371
< 370
< 369
< 368
< 367
< 366
< 365
< 364
< 363
< 362
< 361
< 360
< 359
< 358
< 357
< 356
< 355
< 354
< 353
< 352
< 351
< 350
< 349
< 348
< 347
< 346
< 345
< 344
< 343
< 342
< 341
< 340
< 339
< 338
< 337
< 336
< 335
< 334
< 333
< 332
< 331
< 330
< 329
< 328
< 327
< 326
< 325
< 324
< 323
< 322
< 321
< 320
< 319
< 318
< 317
< 316
< 315
< 314
< 313
< 312
< 311
< 310
< 309
< 308
< 307
< 306
< 305
< 304
< 303
< 302
< 301
< 300
< 299
< 298
< 297
< 296
< 295
< 294
< 293
< 292
< 291
< 290
< 289
< 288
< 287
< 286
< 285
< 284
< 283
< 282
< 281
< 280
< 279
< 278
< 277
< 276
< 275
< 274
< 273
< 272
< 271
< 270
< 269
< 268
< 267
< 266
< 265
< 264
< 263
< 262
< 261
< 260
< 259
< 258
< 257
< 256
< 255
< 254
< 253
< 252
< 251
< 250
< 249
< 248
< 247
< 246
< 245
< 244
< 243
< 242
< 241
< 240
< 239
< 238
< 237
< 236
< 235
< 234
< 233
< 232
< 231
< 230
< 229
< 228
< 227
< 226
< 225
< 224
< 223
< 222
< 221
< 220
< 219
< 218
< 217
< 216
< 215
< 214
< 213
< 212
< 211
< 210
< 209
< 208
< 207
< 206
< 205
< 204
< 203
< 202
< 201
< 200
< 199
< 198
< 197
< 196
< 195
< 194
< 193
< 192
< 191
< 190
< 189
< 188
< 187
< 186
< 185
< 184
< 183
< 182
< 181
< 180
< 179
< 178
< 177
< 176
< 175
< 174
< 173
< 172
< 171
< 170
< 169
< 168
< 167
< 166
< 165
< 164
< 163
< 162
< 161
< 160
< 159
< 158
< 157
< 156
< 155
< 154
< 153
< 152
< 151
< 150
< 149
< 148
< 147
< 146
< 145
< 144
< 143
< 142
< 141
< 140
< 139
< 138
< 137
< 136
< 135
< 134
< 133
< 132
< 131
< 130
< 129
< 128
< 127
< 126
< 125
< 124
< 123
< 122
< 121
< 120
< 119
< 118
< 117
< 116
< 115
< 114
< 113
< 112
< 111
< 110
< 109
< 108
< 107
< 106
< 105
< 104
< 103
< 102
< 101
< 100
< 99
< 98
< 97
< 96
< 95
< 94
< 93
< 92
< 91
< 90
< 89
< 88
< 87
< 86
< 85
< 84
< 83
< 82
< 81
< 80
< 79
< 78
< 77
< 76
< 75
< 74
< 73
< 72
< 71
< 70
< 69
< 68
< 67
< 66
< 65
< 64
< 63
< 62
< 61
< 60
< 59
< 58
< 57
< 56
< 55
< 54
< 53
< 52
< 51
< 50
< 49
< 48
< 47
< 46
< 45
< 44
< 43
< 42
< 41
< 40
< 39
< 38
< 37
< 36
< 35
< 34
< 33
< 32
< 31
< 30
< 29
< 28
< 27
< 26
< 25
< 24
< 23
< 22
< 21
< 20
< 19
< 18
< 17
< 16
< 15
< 14
< 13
< 12
< 11
< 10
< 9
< 8
< 7
< 6
< 5
< 4
< 3
< 2
< 1
< 0
< bottom
---
> ------------------------------------
> EXCEPTION: undefinedVariable
> file recursion.s,line 1: variable var is undefined
------------------------------------------
reflect.s
------------------------------------------
38,49c38,40
< x: a is 2, b is 3, c is 5
< n is constructed via m's constructor
< x: a is 2, b is 3, c is 8
< 
< m . constructor . name is x
< n . constructor . name is x
< 
< changing m . a to 10
< changing n . b to 10
< 
< x: a is 10, b is 3, c is 5
< x: a is 2, b is 10, c is 8
---
> ------------------------------------
> EXCEPTION: nonFunction
> file reflect.s,line 1: attempted to call STRING as a function
------------------------------------------
reify.s
------------------------------------------
29,31c29,31
< calling superclass:a
< superclass:a: calling virtual function b
< subclass:b
---
> ------------------------------------
> EXCEPTION: undefinedVariable
> file reify.s,line 1: variable function is undefined
------------------------------------------
