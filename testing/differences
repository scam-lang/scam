OLD vs. NEW
assign1.scm
------------------------------------------
0a1,242
> (define (run1)
>     (println "need lazy evaluation!")
>     )
> 
> (define (run2)
>     (inspect (zeno_cost 20 150 0.25))
>     )
> 
> (define (zeno_cost d c f)
>     (cond
>         ((<= (* c f) (/ 1 12.)) c)
>         ((<= (/ d 2.) (/ 1 9600.)) (+ c 5))
>         (else (+ c (zeno_cost (/ d 2.) (* c f) f)))
>         )
>     )
> 
> (define (run3)
>     (inspect (min8 1 2 3 4 5 6 7 8))
>     (inspect (min8 2 1 3 4 5 6 7 8))
>     (inspect (min8 2 3 1 4 5 6 7 8))
>     )
> 
> (define (min8 a b c d e f g h)
> (define (min2 a b) (if (< a b) a b))
> (define (min3 a b c) (if (< a b) (min2 a c) (min2 b c)))
> (define (min4 a b c d) (if (< a b) (min3 a c d) (min3 b c d)))
> (define (min5 a b c d e) (if (< a b) (min4 a c d e) (min4 b c d e)))
> (define (min6 a b c d e f) (if (< a b) (min5 a c d e f) (min5 b c d e f)))
> (define (min7 a b c d e f g) (if (< a b) (min6 a c d e f g) (min6 b c d e f g)))
>     (if (< a b) (min7 a c d e f g h) (min7 b c d e f g h))
>     )
>         
> (define (run4)
>     (inspect (root3 8.0))
>     (inspect (root3 27.0))
>     )
> 
> (define (root3 x)
>     (define (iter lower upper)
>         (define guess (/ (+ upper lower) 2))
>         (define try (* guess guess guess))
>         (cond
>             ((= try x) guess)
>             ((> try x) (iter lower guess))
>             (else (iter guess upper))
>             )
>         )
>     (iter 1 x)
>     )
> 
> (define (run5)
>     (pt 9)
>     )
> 
> (define (pt n)
>     (define (indent count)
>         (cond
>             ((= count 0) 'done)
>             (else (print " ") (indent (- count 1)))
>             )
>         )
>     (define (ptLevel r c)
>         (cond 
>             ((= r 0) 1)
>             ((= c 0) 1)
>             ((= c r) 1)
>             (else (+ (ptLevel (- r 1) (- c 1)) (ptLevel (- r 1) c)))
>             )
>         )
> 
>     (define (row-iter row)
>         (define (col-iter col)
>             (cond
>                 ((> col row) (println))
>                 (else
>                     (print (ptLevel row col) " ")
>                     (col-iter (+ col 1))
>                     )
>                 )
>             )
>         (cond 
>             ((> row n) (println))
>             (else
>                 (indent (- n row))
>                 (col-iter 0)
>                 (row-iter (+ row 1))
>                 )
>             )
>         )
>     (row-iter 0)
>     )
> 
> (define (run6)
>     (inspect (r-zorp 1 (lambda (x) (* x x))))
>     (inspect (r-zorp 2 (lambda (x) (* x x))))
>     (inspect (r-zorp 3 (lambda (x) (* x x))))
>     (inspect (r-zorp 4 (lambda (x) (* x x))))
>     (inspect (r-zorp 5 (lambda (x) (* x x))))
>     (inspect (zorp 1 (lambda (x) (* x x))))
>     (inspect (zorp 2 (lambda (x) (* x x))))
>     (inspect (zorp 3 (lambda (x) (* x x))))
>     (inspect (zorp 4 (lambda (x) (* x x))))
>     (inspect (zorp 5 (lambda (x) (* x x))))
>     )
> 
> (define (my-square x) (* x x))
> (define (r-zorp i f)
>     (cond
>         ((< i 3) (f i))
>         (else
>             (+  (r-zorp (- i 1) f)
>                 (/  (my-square (- (r-zorp (- i 1) f) (r-zorp (- i 2) f)))
>                     (+  (r-zorp (- i 3) f)
>                         (* -2 (r-zorp (- i 2) f))
>                         (r-zorp (- i 1) f)
>                         )
>                     )
>                 )
>             )
>         )
>     )
> 
> (define (zorp i f)
>     (define (iter a b c store)
>         (cond
>             ((= store 0) a)
>             (else
>                 (iter
>                     b c (+ c (/ (my-square (- c b)) (+ a (* -2 b) c)))
>                     (- store 1)
>                     )
>                 )
>             )
>         )
>     (iter (f 0) (f 1) (f 2) i)
>     )
> 
> 
> (define (run7)
>     (inspect (square 5))
>     (inspect (halve 6))
>     (inspect (halve 5))
>     (inspect (halve 4))
>     (inspect (babyl* 7 8))
>     (inspect (babyl* 9 9))
>     )
> 
> (define (square n)
>     (define (iter result store)
>         (cond
>             ((= store 1) result)
>             (else (iter (+ result store store -1) (- store 1)))
>             )
>         )
>     (iter 1 n)
>     )
> 
> (define (halve n)
>     (define (iter result store)
>         (cond
>             ((= store 0) result)
>             ((= (% store 2) 0) (iter (+ result 1) (- store 1)))
>             (else (iter result (- store 1)))
>             )
>         )
>     (iter 0 n)
>     )
> 
> (define (babyl* a b)
>     (/ (- (square (+ a b)) (square a) (square b)) 2)
>     )
> 
> (define (run8)
>     (inspect (ecf 0))
>     (inspect (ecf 1))
>     (inspect (ecf 2))
>     )
> 
> (define (ecf terms)
>     (define (iter count)
>         (cond
>             ((= terms count) 0.0)
>             (else
>                 (/ 1 (+ 1 (/ 1 (+ 2 (* 2 count) (/ 1 (+ 1 (iter (+ count 1))))))))
>                 )
>             )
>         )
>     (+ 2  (iter 0))
>     )
> 
> 
> (define (run9)
>     (inspect (ramanujan 0))
>     (inspect (ramanujan 1))
>     (inspect (ramanujan 2))
>     (inspect (ramanujan 10))
>     (inspect (ramanujan 100))
>     (println "the answer is 3")
>     )
> 
> (define (ramanujan terms)
>     (define (iter result store)
>         (cond
>             ((= store 0) result)
>             (else (iter (sqrt (+ 1 (* (+ store 1) result))) (- store 1)))
>             )
>         )
>     (iter 1 terms)
>     )
> 
> (define (run10)
>     (inspect (ramanujan2 0 2))
>     (inspect (ramanujan2 1 2))
>     (inspect (ramanujan2 2 2))
>     (inspect (ramanujan2 10 2))
>     (inspect (ramanujan2 50 2))
>     (inspect (ramanujan2 2 3))
>     (inspect (ramanujan2 50 3))
>     (inspect (ramanujan2 50 10))
>     (println "the answer is x + 1")
>     )
> 
> (define (ramanujan2 terms x)
>     (define (iter count)
>         (cond
>             ((= count terms) 0.0)
>             (else (sqrt (+ 1 (* (+ x count 1) (iter (+ count 1))))))
>             )
>         )
>     (sqrt (+ 1 (* x (iter 0))))
>     )
> ;(run1)
> ;(run2)
> ;(run3)
> ;(run4)
> ;(run5)
> ;(run6)
> ;(run7)
> ;(run8)
> ;(run9)
> ;(run10)
> ------------------------------------------
------------------------------------------
assign2.scm
------------------------------------------
0a1,412
> (include "reflection.lib")
> ;(compile-reflection)
> (include "../../proglan/table.scm")
> (include "pretty.lib")
> 
> 
> (define (run1) 
>     (inspect (+ (polar 1 .707) (polar 1 .707)))
>     (inspect (+ (polar 3 1.423) (polar 7 2.453)))
>     (inspect (+ (rectangular 3 1.423) (rectangular 7 2.453)))
>     (inspect (+ (polar 3 1.423) 0))
>     (inspect (+ (rectangular 3 1.423) 0))
>     )
> 
> (define (polar mag ang)
>     (list 'polar mag ang)
>     )
> 
> (define (rectangular x y)
>     (list 'rectangular x y)
>     )
> 
> (define (polar? p) (and (pair? p) (eq? (car p) 'polar)))
> (define (rectangular? p) (and (pair? p) (eq? (car p) 'rectangular)))
> (define (polar->rectangular p)
>     (rectangular (* (cadr p) (cos (caddr p))) (* (cadr p) (sin (caddr p))))
>     )
> (define (rectangular->polar r)
>     (define x (cadr r))
>     (define y (caddr r))
>     (polar (expt (+ (* x x) (* y y)) 0.5) (atan y x))
>     )
> (define (polar+polar a b)
>     (rectangular->polar
>         (rectangular+rectangular
>             (polar->rectangular a)
>             (polar->rectangular b)
>             )
>         )
>     )
> (define (polar+rectangular a b)
>     (rectangular->polar
>         (rectangular+rectangular
>             (polar->rectangular a)
>             (rectangular b 0)
>             )
>         )
>     )
> (define (polar+number a b)
>     (rectangular->polar
>         (rectangular+rectangular
>             (polar->rectangular a)
>             (rectangular b 0)
>             )
>         )
>     )
> (define (rectangular+rectangular a b)
>     (rectangular (+ (cadr a) (cadr b)) (+ (caddr a) (caddr b)))
>     )
> (define (rectangular+number a b)
>     (rectangular+rectangular a (rectangular b 0))
>     )
> (redefine (+ a b)
>     (cond
>         ((polar? a)
>             (cond
>                 ((polar? b) (polar+polar a b))
>                 ((rectangular? b) (polar+rectangular a b))
>                 (else (polar+number a b))
>                 )
>             )
>         ((rectangular? a)
>             (cond
>                 ((polar? b) (polar+rectangular b a))
>                 ((rectangular? b) (rectangular+rectangular a b))
>                 (else (rectangular+number a b))
>                 )
>             )
>         (else
>             (cond
>                 ((polar? b) (polar+number b a))
>                 ((rectangular? b) (rectangular+number b a))
>                 (else ((prior) a b))
>                 )
>             )
>         )
>     )
> 
> (define (run2)
>     (println "(add two three) is " (translate (add two three)))
>     (println "(add zero five) is " (translate (add zero five)))
>     (println "(add five zero) is " (translate (add five zero)))
>     (println "(add nine nine) is " (translate (add nine nine)))
>     )
> 
> (define (identity x) x)
> 
> (define (increment number)
>     (define (next-higher-number incrementer)
>         (define (resolve base)
>             (incrementer ((number incrementer) base))
>             )
>         resolve
>         )
>     next-higher-number
>     )
> 
> (define (zero incrementer)
>     identity
>     )
> 
> (define (one incrementer) 
>     (define (resolver base)
>         (incrementer base)
>         )
>     resolver
>     )
> 
> (define (two incrementer)
>     (lambda (base)
>         (incrementer (incrementer base))
>         )
>     )
> 
> (define (three incrementer)
>     (lambda (base)
>         (incrementer (incrementer (incrementer base)))
>         )
>     )
> 
> (define (four incrementer)
>     (lambda (base)
>         (incrementer (incrementer (incrementer (incrementer base))))
>         )
>     )
> 
> (define (five incrementer)
>     (lambda (base)
>         (incrementer (incrementer (incrementer (incrementer (incrementer base)))))
>         )
>     )
> 
> (define (six incrementer)
>     (lambda (base)
>         (incrementer (incrementer (incrementer (incrementer (incrementer (incrementer base))))))
>         )
>     )
> 
> (define (seven incrementer)
>     (lambda (base)
>         (incrementer (incrementer (incrementer (incrementer (incrementer (incrementer (incrementer base)))))))
>         )
>     )
> 
> (define (eight incrementer)
>     (lambda (base)
>         (incrementer (incrementer (incrementer (incrementer (incrementer (incrementer (incrementer (incrementer base))))))))
>         )
>     )
> 
> (define (nine incrementer)
>     (lambda (base)
>         (incrementer (incrementer (incrementer (incrementer (incrementer (incrementer (incrementer (incrementer (incrementer base)))))))))
>         )
>     )
> 
> (define (inc x) (cons 'x x))
> (define base ())
> 
> (define numbers
>     (list
>         (list ((zero inc) base) 'zero)
>         (list ((one inc) base)  'one)
>         (list ((two inc) base)  'two)
>         (list ((three inc) base)  'three)
>         (list ((four inc) base)  'four)
>         (list ((five inc) base)  'five)
>         (list ((six inc) base)  'six)
>         (list ((seven inc) base)  'seven)
>         (list ((eight inc) base)  'eight)
>         (list ((nine inc) base) 'nine)
>         )
>     )
> 
> (define (translate number)
>     (define result (assoc ((number inc) base) numbers))
>     (if (eq? result #f)
>         ((number inc) base)
>         (cadr result)
>         )
>     )
> 
> (define (add a b)
>     (lambda (incrementer)
>         (lambda (base) ((a incrementer) ((b incrementer) base)))
>         )
>     )
> 
> (define (run3)
>     (inspect (define->lambda '(define (plus a b) (+ a b))))
>     )
> 
> (define (define->lambda code)
>     (list
>         'define
>         (car (cadr code)) ;function name
>         (cons 'lambda (cons (cdr (cadr code)) (cddr code)))
>         )
>     )
> (define (run4)
>     (inspect ((extractor 0 1) '((1 2) 3)))
>     )
> 
> (define (extractor @)
>     (define (iter pointers)
>         (cond
>             ((equal? pointers '(0)) car)
>             ((equal? pointers '(1)) cdr)
>             ((eq? (car pointers) 0)
>                 (lambda (x) ((iter (cdr pointers)) (car x))))
>             (else
>                 (lambda (x) ((iter (cdr pointers)) (cdr x))))
>             )
>         )
>     (iter @)
>     )
> 
> (define (run7)
>     (inspect (powerSet '(a b c d)))
>     )
> 
> (define (powerSet items)
>     (define (interleave a b)
>         (cond
>             ((null? a) b)
>             ((null? b) a)
>             ((or (null? (car a)) (< (length (car a)) (length (car b))))
>                 (cons (car a) (interleave (cdr a) b)))
>             (else
>                 (cons (car b) (interleave a (cdr b))))
>             )
>         )
>     (cond
>         ((null? items) (list nil))
>         (else 
>             (define rest (powerSet (cdr items)))
>             (define added (map (lambda (x) (cons (car items) x)) rest))
>             (interleave rest added)
>             )
>         )
>     )
> 
> (define (run8)
>     (define t (treeNode 2 (treeNode 1 nil (treeNode 4 nil nil)) (treeNode 0 nil nil)))
>     (inspect t)
>     (inspect (depthStat t))
>     )
> 
> (define (newTree) ())
> 
> (define (treeNode value left right)
>     (list 'binaryTree value left right)
>     )
> 
> (define (extract-leaves t)
>     (define (iter root depth)
>         (cond
>             ((and (null? (caddr root)) (null? (cadddr root)))
>                 (list (list (cadr root) depth)))
>             ((null? (caddr root))
>                 (iter (cadddr root) (+ depth 1)))
>             ((null? (cadddr root))
>                 (iter (caddr root) (+ depth 1)))
>             (else
>                 (append
>                     (iter (cadddr root) (+ depth 1))
>                     (iter (caddr root) (+ depth 1))
>                     )
>                 )
>             )
>         )
>     (iter t 0)
>     )
> 
> (define (accumulate op base items)
>     (cond
>         ((null? items) base)
>         (else (op (car items) (accumulate op base (cdr items))))
>         )
>     )
> (define (depthStat t)
>     (define depths (map cadr (extract-leaves t)))
>     (define sum (accumulate + 0 depths))
>     (define count (accumulate (lambda (x y) (+ 1 y)) 0 depths))
>     (inspect depths)
>     (inspect sum)
>     (inspect count)
>     (/ sum (real count))
>     )
> 
> (define (run9)
>     (inspect (((((Polar 3 1.423) 'add) (Polar 7 2.453)) 'toString)))
>     ;(inspect (+ (rectangular 3 1.423) (rectangular 7 2.453)))
>     ;(inspect (+ (polar 3 1.423) 0))
>     ;(inspect (+ (rectangular 3 1.423) 0))
>     )
> 
> 
> (define (Integer i)
>     (define (add x)
>         (cond
>             ((is? x 'Integer) (Integer (+ i ((x 'value)))))
>             (else (((promote) 'add) x))
>             )
>         )
>     (define (promote) (Real (real i)))
>     (define (demote) __context)
>     (define (value) i)
>     (define (toString) (string i))
>     this
>     )
> 
> (define (Real r)
>     (define (add x)
>         (cond
>             ((is? x 'Integer) (Real (+ r ((x 'value)))))
>             ((is? x 'Real) (Real (+ r ((x 'value)))))
>             (else (((promote) 'add) x))
>             )
>         )
>     (define (promote) (Rectangular r 0))
>     (define (demote) (Integer (integer r)))
>     (define (value) r)
>     (define (toString) (string r))
>     this
>     )
> 
> (define (Rectangular x y) 
>     (define (add a)
>         (cond
>             ((is? a 'Integer) (Rectangular (+ x ((a 'value))) y))
>             ((is? a 'Real) (Rectangular (+ x ((a 'value))) y))
>             ((is? a 'Polar) (add ((a 'convert))))
>             (else
>                 (Rectangular
>                     (+ x (car ((a 'value))))
>                     (+ y (cadr ((a 'value))))
>                     )
>                 )
>             )
>         )
>     (define (convert)
>         (apply Polar (cdr (rectangular->polar (rectangular x y))))
>         )
>     (define (promote) __context)
>     (define (demote) (Real (real x)))
>     (define (value) (list x y))
>     (define (toString) (string (list 'rectangular x y)))
>     this
>     )
>          
> (define (Polar m a) 
>     (define (add a)
>         (cond
>             ((is? a 'Integer) (((((convert) 'add) a) 'convert)))
>             ((is? a 'Real) (((((convert) 'add) a) 'convert)))
>             ((is? a 'Rectangular) ((((a 'add) __context) 'convert)))
>             (else (((((convert) 'add) a) 'convert)))
>             )
>         )
>     (define (convert)
>         (apply Rectangular (cdr (polar->rectangular (polar m a))))
>         )
>     (define (promote) __context)
>     (define (demote) (Real (car (((convert) 'value)))))
>     (define (value) (list m a))
>     (define (toString) (string (list 'polar m a)))
>     this
>     )
> (redefine (+ a b)
>     (cond
>         ((object? a) ((a 'add) b))
>         (else ((prior) a b))
>         )
>     )
> 
> (run1)
> (run2)
> (run3)
> (run4)
> (run7)
> (run8)
> (run9)
> ------------------------------------------
> (+ (polar 1 0.707000) (polar 1 0.707000)) is (polar 2.000000 0.707000)
> (+ (polar 3 1.423000) (polar 7 2.453000)) is (polar 8.923138 2.160624)
> (+ (rectangular 3 1.423000) (rectangular 7 2.453000)) is (rectangular 10 3.876000)
> (+ (polar 3 1.423000) 0) is (polar 3.000000 1.423000)
> (+ (rectangular 3 1.423000) 0) is (rectangular 3 1.423000)
> (add two three) is five
> (add zero five) is five
> (add five zero) is five
> (add nine nine) is (x x x x x x x x x x x x x x x x x x)
> (define->lambda (quote (define (plus a b) (+ a b)))) is (define plus (lambda (a b) (+ a b)))
> ((extractor 0 1) (quote ((1 2) 3))) is (2)
> (powerSet (quote (a b c d))) is ( (a) (b) (c) (d) (a b) (a c) (a d) (b c) (b d) (c d) (a b c) (a b d) (a c d) (b c d) (a b c d))
> t is (binaryTree 2 (binaryTree 1  (binaryTree 4  )) (binaryTree 0  ))
> depths is (1 2)
> sum is 3
> count is 2
> (depthStat t) is 1.500000
> (((((Polar 3 1.423000) (quote add)) (Polar 7 2.453000)) (quote toString))) is (polar 8.923138 2.160624)
------------------------------------------
run.scm
------------------------------------------
0a1,93
> (define port)
> (define oldPort (getOutputPort))
> (define remarks #f)
> (define topEnv this)
> 
> (define (logln port @)
>     (define oldPort (setPort port))
>     (apply println @)
>     (setPort oldPort)
>     )
> (define (log port @)
>     (define oldPort (setPort port))
>     (apply print @)
>     (setPort oldPort)
>     )
> 
> (define (run exercises out)
> 
>     (define target nil)
>     (define mytarget nil)
>     (define exercise nil)
>     (define (run-items items)
>         (define result nil)
>         (if (valid? items)
>             (begin
>                 (set! target (car items))
>                 (set! exercise (string target))
>                 (set! exercise (cdddr exercise))
>                 (set! mytarget 
>                     (symbol (string+ "jcl-run" exercise))
>                     )
>                 (log oldPort "initiating exercise ")
>                 (log oldPort target)
>                 (logln oldPort "...")
>                 (println "############ exercise " exercise " ############\n")
>                 (close (getOutputPort))
>                 (set! port (open out 'append))
>                 (setPort port)
>                 (cond
>                     ((local? (__id target) topEnv)
>                     (println "#### your explanations and tests...\n")
>                     ;(set! result
>                         ;(ignore-errors (lambda () ((eval target topEnv)))))
>                     (set! result (catch ((eval target topEnv))))
>                     (if (error? result)
>                         (println "\n" target " failed: " (dot result value)))
>                     (println)
>                     (if (local? (__id mytarget) topEnv)
>                         (begin
>                             (println "#### your code and my tests...\n")
>                             ((eval mytarget topEnv))
>                             (println)
>                             )
>                         )
>                     (println)
>                     (if remarks
>                         (begin
>                             (println "#### exercise " exercise " remarks:")
>                             (println "####")
>                             (println "####")
>                             )
>                         )
>                     )
>                     (else
>                         (println "####")
>                         (println "#### exercise " exercise " not implemented")
>                         )
>                     )
>                 (println "####\n")
>                 (log oldPort "exercise ")
>                 (log oldPort (car items))
>                 (logln oldPort " completed.")
>                 (run-items (cdr items))
>                 )
>             )
>         )
> 
>     (set! port (open out 'write))
>     (setPort port)
> 
>     (logln oldPort "running the exercises...")
> 
>     (run-items exercises)
> 
>     (logln oldPort "exercises completed...")
>     (reset)
>     )
> 
> (define (reset)
>     (setPort oldPort)
>     (close port)
>     )
> ------------------------------------------
------------------------------------------
sin.scm
------------------------------------------
0a1,46
> (define i 0)
> (while (< i 4)
>     (println (int (* (sin i) 1000)))
>     (+= i .1)
>     )
> ------------------------------------------
> 0
> 99
> 198
> 295
> 389
> 479
> 564
> 644
> 717
> 783
> 841
> 891
> 932
> 963
> 985
> 997
> 999
> 991
> 973
> 946
> 909
> 863
> 808
> 745
> 675
> 598
> 515
> 427
> 334
> 239
> 141
> 41
> -58
> -157
> -255
> -350
> -442
> -529
> -611
> -687
------------------------------------------
test1.scm
------------------------------------------
0a1,141
> (include "assign1.scm")
> 
> (define (inspect # $item)
>     (print $item " is " (eval $item #) " ")
>     )
> 
> (println "problem 1...\n")
> (if (defined? 'run1 this)
>     (println "no testing for problem 1\n")
>     (println "problem 1 not implemented\n")
>     )
> 
> (println "problem 2...\n")
> (if (defined? 'run2 this)
>     (begin
>         (inspect (zeno_cost 20 150 0.25))
>         (println "[it should be 199.951172]\n")
>         )
>     (println "problem 2 not implemented\n")
>     )
> 
> (println "problem 3...\n")
> (if (defined? 'run3 this)
>     (begin
>         (inspect (min8 0 0 0 0 0 0 0 0))
>         (println "[it should be 0]\n")
>         )
>     (println "problem 3 not implemented\n")
>     )
> 
> (println "problem 4...\n")
> (if (defined? 'run4 this)
>     (begin
>         (inspect (root3 27.0))
>         (println "[it should be 3.0]\n")
>         )
>     (println "problem 4 not implemented\n")
>     )
> 
> (println "problem 5...\n")
> (if (defined? 'run5 this)
>     (begin
>         (pt 0)
>         (println "[it should print out 1]\n")
>         )
>     (println "problem 5 not implemented\n")
>     )
> 
> (println "problem 6...\n")
> (if (defined? 'run6 this)
>     (begin
>         (inspect (zorp 1 (lambda (x) (* x x))))
>         (println "[it should be 1]\n")
>         )
>     (println "problem 6 not implemented\n")
>     )
> 
> (println "problem 7...\n")
> (if (defined? 'run7 this)
>     (begin
>         (inspect (square 1))
>         (println "[it should be 1]")
>         (inspect (halve 2))
>         (println "[it should be 1]")
>         (inspect (babyl* 1 1))
>         (println "[it should be 1]\n")
>         )
>     (println "problem 7 not implemented\n")
>     )
> 
> (println "problem 8...\n")
> (if (defined? 'run8 this)
>     (begin
>         (inspect (ecf 0))
>         (println "[it should be 2.0]\n")
>         )
>     (println "problem 8 not implemented\n")
>     )
> 
> (println "problem 9...\n")
> (if (defined? 'run9 this)
>     (begin
>         (inspect (ramanujan 0))
>         (println "[it should be 1.0]\n")
>         )
>     (println "problem 9 not implemented\n")
>     )
> 
> (println "problem 10...\n")
> (if (defined? 'run10 this)
>     (begin
>         (inspect (ramanujan2 1 2))
>         (println "[it should be 1.732051]\n")
>         )
>     (println "problem 10 not implemented]\n")
>     )
> ------------------------------------------
> problem 1...
> 
> no testing for problem 1
> 
> problem 2...
> 
> (zeno_cost 20 150 0.250000) is 199.951172 [it should be 199.951172]
> 
> problem 3...
> 
> (min8 0 0 0 0 0 0 0 0) is 0 [it should be 0]
> 
> problem 4...
> 
> (root3 27.000000) is 3.000000 [it should be 3.0]
> 
> problem 5...
> 
> 1 
> 
> [it should print out 1]
> 
> problem 6...
> 
> (zorp 1 (lambda (x) (* x x))) is 1 [it should be 1]
> 
> problem 7...
> 
> (square 1) is 1 [it should be 1]
> (halve 2) is 1 [it should be 1]
> (babyl* 1 1) is 1 [it should be 1]
> 
> problem 8...
> 
> (ecf 0) is 2.000000 [it should be 2.0]
> 
> problem 9...
> 
> (ramanujan 0) is 1 [it should be 1.0]
> 
> problem 10...
> 
> (ramanujan2 1 2) is 1.732051 [it should be 1.732051]
> 
------------------------------------------
test2.scm
------------------------------------------
0a1,188
> (include "reflection.lib")
> (include "assign2.scm")
> 
> (println "problem 1...\n")
> (if (defined? 'run1 this)
>     (begin
>         (inspect (+ 2 3))
>         (println "    [it should be 5]")
>         (inspect (+ (polar 1 .707) (polar 1 .707)))
>         (println "    [it should be magnitude 2 and angle .707]")
>         )
>     (println "problem 1 not implemented\n")
>     )
> 
> (println "problem 2...\n")
> (if (defined? 'run2 this)
>     (begin
>         (inspect add)
>         (println)
>         (inspect numbers)
>         (println)
>         (inspect (translate (add two three)))
>         (println "    [it should be five]\n")
>         )
>     (println "problem 2 not implemented\n")
>     )
>     
> 
> (println "problem 3...\n")
> (if (defined? 'run3 this)
>     (begin
>         (inspect (define->lambda '(define (plus a b) (+ a b))))
>         (println "    [it should be (define plus (lambda (a b) (+ a b)))]\n")
>         )
>     (println "problem 3 not implemented\n")
>     )
> 
> (println "problem 4...\n")
> (if (defined? 'run4 this)
>     (begin
>         (inspect ((extractor 1 1 0) '(1 2 3 4 5)))
>         (println "    [it should be 3]")
>         )
>     (println "problem 4 not implemented\n")
>     )
> 
> (println "problem 5...\n")
> (if (defined? 'run5 this)
>     (begin
>         (inspect (matrix-*-matrix '((1 2) (3 4))'((1 0) (0 1))))
>         (println "    [it should be ((1 2) (3 4))]\n")
>         )
>     (println "problem 5 not implemented\n")
>     )
> 
> (println "problem 6...\n")
> (if (defined? 'run6 this)
>     (begin
>         (inspect (infix->postfix '(2 + 3 * x ^ 5 + a)))
>         (println "    [it should be (2 3 x 5 ^ * a + +) or equivalent]\n")
>         )
>     (println "problem 6 not implemented\n")
>     )
> 
> (println "problem 7...\n")
> (if (defined? 'run7 this)
>     (begin
>         (inspect (powerSet '(a b)))
>         (println "    [it should be (() (a) (b) (a b))]")
>         )
>     (println "problem 7 not implemented\n")
>     )
> 
> (println "problem 8...\n")
> (if (defined? 'run8 this)
>     (begin
>         (inspect
>             (depthStat (treeNode 1 (treeNode 1 nil nil) (treeNode 1 nil nil)))
>             )
>         (println "    [it should be 1.0]\n")
>         )
>     (println "problem 8 not implemented\n")
>     )
> 
> (println "problem 9...\n")
> (if (defined? 'run9 this)
>     (begin
>         (inspect (+ 2 3))
>         (println "    [it should be 5]\n")
>         (inspect ((dot (+ (Polar 1 .707) (Polar 1 .707)) toString)))
>         (println "    [it should be magnitude 2 and angle .707]\n")
>         (inspect ((dot (+ (Rectangular 1 1) (Integer 1)) toString)))
>         (println "    [it should be real 2 and imaginary 1]\n")
>         (inspect ((dot (+ (Real 2.3) (Integer 1)) value)))
>         (println "    [it should be real 3.3]\n")
>         )
>     (println "problem 9 not implemented\n")
>     )
> 
> (println "problem 10...\n")
> (if (defined? 'run10 this)
>     (begin
>         (inspect ((dot (coerce (Integer 5) 'Real) value)))
>         (println "[it should be real 5.0]\n")
>         )
>     (println "problem 10 not implemented]\n")
>     )
> ------------------------------------------
> (+ (polar 1 0.707000) (polar 1 0.707000)) is (polar 2.000000 0.707000)
> (+ (polar 3 1.423000) (polar 7 2.453000)) is (polar 8.923138 2.160624)
> (+ (rectangular 3 1.423000) (rectangular 7 2.453000)) is (rectangular 10 3.876000)
> (+ (polar 3 1.423000) 0) is (polar 3.000000 1.423000)
> (+ (rectangular 3 1.423000) 0) is (rectangular 3 1.423000)
> (add two three) is five
> (add zero five) is five
> (add five zero) is five
> (add nine nine) is (x x x x x x x x x x x x x x x x x x)
> (define->lambda (quote (define (plus a b) (+ a b)))) is (define plus (lambda (a b) (+ a b)))
> ((extractor 0 1) (quote ((1 2) 3))) is (2)
> (powerSet (quote (a b c d))) is ( (a) (b) (c) (d) (a b) (a c) (a d) (b c) (b d) (c d) (a b c) (a b d) (a c d) (b c d) (a b c d))
> t is (binaryTree 2 (binaryTree 1  (binaryTree 4  )) (binaryTree 0  ))
> depths is (1 2)
> sum is 3
> count is 2
> (depthStat t) is 1.500000
> (((((Polar 3 1.423000) (quote add)) (Polar 7 2.453000)) (quote toString))) is (polar 8.923138 2.160624)
> problem 1...
> 
> (+ 2 3) is 5
>     [it should be 5]
> (+ (polar 1 0.707000) (polar 1 0.707000)) is (polar 2.000000 0.707000)
>     [it should be magnitude 2 and angle .707]
> problem 2...
> 
> add is <function add(a b)>
> 
> numbers is (( zero) ((x) one) ((x x) two) ((x x x) three) ((x x x x) four) ((x x x x x) five) ((x x x x x x) six) ((x x x x x x x) seven) ((x x x x x x x x) eight) ((x x x x x x x x x) nine))
> 
> (translate (add two three)) is five
>     [it should be five]
> 
> problem 3...
> 
> (define->lambda (quote (define (plus a b) (+ a b)))) is (define plus (lambda (a b) (+ a b)))
>     [it should be (define plus (lambda (a b) (+ a b)))]
> 
> problem 4...
> 
> ((extractor 1 1 0) (quote (1 2 3 4 5))) is 3
>     [it should be 3]
> problem 5...
> 
> problem 5 not implemented
> 
> problem 6...
> 
> problem 6 not implemented
> 
> problem 7...
> 
> (powerSet (quote (a b))) is ( (a) (b) (a b))
>     [it should be (() (a) (b) (a b))]
> problem 8...
> 
> depths is (1 1)
> sum is 2
> count is 2
> (depthStat (treeNode 1 (treeNode 1  ) (treeNode 1  ))) is 1.000000
>     [it should be 1.0]
> 
> problem 9...
> 
> (+ 2 3) is 5
>     [it should be 5]
> 
> ((dot (+ (Polar 1 0.707000) (Polar 1 0.707000)) toString)) is (polar 2.000000 0.707000)
>     [it should be magnitude 2 and angle .707]
> 
> ((dot (+ (Rectangular 1 1) (Integer 1)) toString)) is (rectangular 2 1)
>     [it should be real 2 and imaginary 1]
> 
> ((dot (+ (Real 2.300000) (Integer 1)) value)) is 3.300000
>     [it should be real 3.3]
> 
> problem 10...
> 
> problem 10 not implemented]
> 
------------------------------------------
