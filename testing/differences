OLD vs. NEW
adders.s
------------------------------------------
24a25,48
> (define (simulateAND)
>     (define i)
>     (define a (wire))
>     (define b (wire))
>     (define c (wire))
>     (define simulator (agenda))
>     (define inputs (array (array 0 0) (array 0 1) (array 1 0) (array 1 1)))
> 
>     (println "a\t\b\tc")
> 
>     (AND a b c simulator)
> 
>     (for (assign i 0) (< i (length inputs)) (assign i (+ i 1))
>         ((. a set) (getElement inputs i 0))
>         ((. b set) (getElement inputs i 1))
>             ((. simulator run))
>             (println
>             (getElement inputs i 0) "\t" 
>             (getElement inputs i 1) "\t" 
>             ((. c get))
>             )
>             )
>     )
> 
81a106,107
> ;(simulateAND)
> ;(println)
98a125
> gc:1, 13171 cells
------------------------------------------
agenda.s
------------------------------------------
7c7,10
<         ((. actions enqueue) (thunk $action #)  (+ time delay))
---
>         (define result (thunk $action #))
>         ;(print "enqueuing " result)
>         ;(inspect result)
>         ((. actions enqueue) result  (+ time delay))
12c15,18
<             (force ((. actions dequeue)))       ;action was delayed!
---
>             (define result ((. actions dequeue)))
>             ;(println "dequeuing " result)
>             ;(inspect result)
>             (force result)
------------------------------------------
apply.s
------------------------------------------
------------------------------------------
a.s
------------------------------------------
------------------------------------------
bad.s
------------------------------------------
------------------------------------------
block.s
------------------------------------------
------------------------------------------
call.s
------------------------------------------
------------------------------------------
catch.s
------------------------------------------
------------------------------------------
chain.s
------------------------------------------
0a1,15
> (define (a x y)
>     this
>     )
> 
> (define (b m n)
>     (define o (a 'one 'two))
>     this
>     )
> 
> (define obj (b 'red 'green))
> 
> (inspect (. obj o x))
> 
> ------------------------------------------
> (. obj o x) is one
------------------------------------------
common2.s
------------------------------------------
6,7c6,7
< ((label environment) (context <object 4685>) (level 0) (constructor nil) (this <object 8372>) (common <object 8450>) (__included_common2.s #t))
< ((label environment) (context <object 8372>) (level 0) (constructor nil) (this <object 8450>) (count 0))
---
> ((__label environment) (__context <object 4657>) (__level 0) (__constructor nil) (this <object 11215>) (common <object 11293>) (__included_common2.s #t))
> ((__label environment) (__context <object 11215>) (__level 0) (__constructor nil) (this <object 11293>) (count 0))
------------------------------------------
common3.s
------------------------------------------
------------------------------------------
common4.s
------------------------------------------
------------------------------------------
common5.s
------------------------------------------
------------------------------------------
common.s
------------------------------------------
------------------------------------------
defined.s
------------------------------------------
------------------------------------------
env.s
------------------------------------------
11d10
< TERM
12a12
> TERM
20,21d19
< SESSION_MANAGER
< USERNAME
22a21,22
> USERNAME
> SESSION_MANAGER
24d23
< PATH
25a25
> PATH
28c28
< GNOME_KEYRING_PID
---
> EDITOR
30c30
< GDM_LANG
---
> GNOME_KEYRING_PID
31a32
> GDM_LANG
34,35d34
< SPEECHD_PORT
< SHLVL
36a36
> SHLVL
40d39
< XDG_DATA_DIRS
41a41
> XDG_DATA_DIRS
43,44d42
< EMAIL
< VIMRUNTIME
47d44
< VIM
49d45
< COLORTERM
50a47
> COLORTERM
------------------------------------------
error0.s
------------------------------------------
0a1,32
> (println "starting error0.s")
> (println "including fact.s")
> (include "fact.s")
> 
> (define (fib n)
>     (if (< n 2)
>         n
>         (+ (fib (- n 1)) (fib (- n 2)))
>         )
>         )
> (define x 0)
> (define result)
> (define t (time))
> 
> (define x 20)
> 
> (define result (fib x))
> (println "fib(" x ") is " result)
> (println (- (time) t) " seconds")
> ------------------------------------------
> scam: cell.c:524: transferBackbone: Assertion `(the_cars[old].transferred) == 0' failed.
> starting error0.s
> including fact.s
> starting fact.s
> including fib.s
> starting fib.s
> including fact.s
> gc:1, 9748 cells
> gc:2, 9747 cells
> gc:3, 9747 cells
> gc:4, 9686 cells
> gc:5, 9747 cells
------------------------------------------
except2.s
------------------------------------------
------------------------------------------
except3.s
------------------------------------------
------------------------------------------
except4.s
------------------------------------------
------------------------------------------
except.s
------------------------------------------
------------------------------------------
extend.s
------------------------------------------
------------------------------------------
extension.s
------------------------------------------
------------------------------------------
fact.s
------------------------------------------
17a18
> scam: cell.c:524: transferBackbone: Assertion `(the_cars[old].transferred) == 0' failed.
22,27c23,26
< fib: fib(10) is 55
< 0 seconds
< fib.s included - SHOULD ONLY SEE THIS ONCE
< fact: fib(5) is 5
< fact: fact(5) is 120
< fact.s included - SHOULD ONLY SEE THIS ONCE
---
> gc:1, 9535 cells
> gc:2, 9500 cells
> gc:3, 9564 cells
> gc:4, 9548 cells
------------------------------------------
fib-opt.s
------------------------------------------
1c1,6
< include("fact.s");
---
> (define (fib n)
>     (if (< n 2)
>         n
>         (+ (fib (- n 1)) (fib (- n 2)))
>         )
>     )
3,16c8,10
< function fib(n)
<     {
<     if (n < 2)
<         {
<         n;
<         }
<     else
<         {
<         fib(n - 1) + fib(n - 2);
<         }
<     }
< var x = 0;
< var result;
< var t = time();
---
> (define x 0)
> (define result)
> (define t (time))
18c12
< x = 22;
---
> (define x 26)
26,34c20,28
< result = fib(x);
< display("fib(");
< display(x);
< display(") is ");
< display(result);
< display("\n");
< display(time() - t);
< display(" seconds");
< display("\n");
---
> (define result (fib x))
> (display("fib(");
> (display(x);
> (display(") is ");
> (display(result);
> (display("\n");
> (display(time() - t);
> (display(" seconds");
> (display("\n");
36,37c30,31
< fib(22) is 17711
< 1 seconds
---
> EXCEPTION: syntaxException
> file fib-opt.s,line 29: expecting CLOSE_PARENTHESIS, found END_OF_INPUT instead
------------------------------------------
fib.s
------------------------------------------
2,4d1
< (println "including fact.s")
< 
< (include "fact.s")
11a9,12
> 
> (println "including fact.s")
> (include "fact.s")
> 
16c17
< (set! x 10)
---
> (set! x 25)
27,28c28,39
< EXCEPTION: undefinedVariable
< file fact.s,line 13: variable fib is undefined
---
> fact: fib(5) is 5
> fact: fact(5) is 120
> fact.s included - SHOULD ONLY SEE THIS ONCE
> gc:1, 9408 cells
> gc:2, 9389 cells
> gc:3, 9454 cells
> gc:4, 9396 cells
> gc:5, 9375 cells
> gc:6, 9424 cells
> fib: fib(25) is 75025
> 2 seconds
> fib.s included - SHOULD ONLY SEE THIS ONCE
------------------------------------------
foreach.s
------------------------------------------
25,32c25,26
< i is 1
< i is 2
< i is 3
< i is 4
< a[2] is 1
< a[2] is 2
< a[2] is 3
< a[2] is 4
---
> EXCEPTION: undefinedVariable
> file foreach.s,line 1: variable function is undefined
------------------------------------------
for.s
------------------------------------------
35,44c35,36
< the value of i is 1
< the value of i is 3
< the value of i is 5
< the value of i is 7
< the value of i is 9
< the value of i is 1
< the value of i is 3
< the value of i is 5
< the value of i is 7
< the value of i is 9
---
> EXCEPTION: undefinedVariable
> file for.s,line 1: variable var is undefined
------------------------------------------
f.s
------------------------------------------
23,24c23,24
< f(10) is 3628800
< g(10) is 3628800
---
> EXCEPTION: nonFunction
> file f.s,line 1: attempted to call STRING as a function
------------------------------------------
function.s
------------------------------------------
1,55c1,36
< function parameterListMaker($)
<     {
<     var vars = :null;
< 
<     while ($ != :null)
<         {
<         vars = vars + list($ . 0 . code);
<         $ = tail($);
<         }
< 
<     vars;
<     }
< 
< function named-lambda($name,params,$body)
<     {
<     var $p = thunk(0,$name . context);
< 
<     $p . code = params;
< 
<     __function__($name,$p,$body);
<     }
< 
< function loadAndgo($name,params,values,$body)
<     {
<     var f = named-lambda($name,params,$body);
< 
<     apply(f,values);
<     }
< 
< loadAndgo(countdown,parameterListMaker(a),list(4))
<     {
<     inspect(a);
<     if (a > 0)
<         {
<         countdown(a - 1);
<         }
<     }
< 
< loadAndgo(countdown,list(:a),list(4))
<     {
<     inspect(a);
<     if (a > 0)
<         {
<         countdown(a - 1);
<         }
<     }
< 
< (named-lambda(countdown,list(:a),
<     {
<     inspect(a);
<     if (a > 0)
<         {
<         countdown(a - 1);
<         }
<     }))(4);
---
> (define (define-function name params body env)
>     (define donor (lambda () 1))
>     (set! 'name name donor)
>     (set! 'parameters params donor)
>     (set! 'code body donor)
>     (addSymbol name donor env)
>     )
> 
> (define (loadAndgo # $name params values $body)
>     (define f (define-function $name params $body #))
>     (apply f values)
>     )
> 
> (println "first load and go...");
> (loadAndgo countdown '(a) '(4)
>     (begin
>         (inspect a)
>         (if (> a 0) (countdown (- a 1)))
>         )
>     )
> 
> (println "second load and go...")
> (loadAndgo countdown '(b) '(3)
>     (begin
>         (inspect b)
>         (if (> b 0) (countdown (- b 1)))
>         )
>     )
> 
> (println "calling define-function directly...")
> ((define-function 'countdown '(a)
>     '(begin
>         (inspect a)
>         (if (> a 0) (countdown (- a 1)))
>         )
>     this) 4)
57,71c38,40
< a is 4
< a is 3
< a is 2
< a is 1
< a is 0
< a is 4
< a is 3
< a is 2
< a is 1
< a is 0
< a is 4
< a is 3
< a is 2
< a is 1
< a is 0
---
> first load and go...
> EXCEPTION: generalException
> file function.s,line 3: set identifier resolved to type CONS, not SYMBOL
------------------------------------------
gc.s
------------------------------------------
1,3c1,2
< function f(x)
<     {
<     var y = x * x;
---
> (define (f x)
>     (define y (* x x))
5c4
<     gc();
---
>     (gc)
7,10c6,9
<     println("f is ", f);
<     println("x is ", x);
<     println("y is ", y);
<     }
---
>     (inspect f)
>     (inspect x)
>     (inspect y)
>     )
12c11
< f(3);
---
> (f 3)
13a13
> gc:1, 8918 cells
------------------------------------------
g.s
------------------------------------------
1,3c1,2
< function g(n)
<     {
<     var total = 1;
---
> (define (g n)
>     (define total 1)
5,9c4,7
<     while (n > 1)
<         {
<         total = total * n;
<         n = n - 1;
<         }
---
>     (while (> n 1)
>         (set! 'total (* total n))
>         (set! 'n (- n 1))
>         )
11,12c9,10
<     total;
<     }
---
>     total
>     )
14c12
< var x = 10;
---
> (define x 10)
16c14
< print("g(",x,") is ", g(x), "\n");
---
> (print "g(" x ") is " (g x) "\n")
18c16,17
< g(10) is 3628800
---
> EXCEPTION: generalException
> file g.s,line 5: set identifier resolved to type CONS, not SYMBOL
------------------------------------------
heapsort.s
------------------------------------------
1c1,2
< include("basics");
---
> (define (heap items op)
>     (define size (length items))
3,21c4,17
< function heap(items,op)
<     {
<     var size = length(items);
< 
<     function leftChild(x) { 2 * x + 1; }
<     function rightChild(x) { 2 * x + 2; }
<     function deleteMin()
<         {
<         var temp = items[0];
<         items[0] = items[size - 1];
<         items[size - 1] = temp;
<         size = size - 1;
<         heapify(0);
<         temp;
<         }
<     function heapify(root)
<         {
<         var extreme;
<         var newRoot;
---
>     (define (leftChild x) (+ (* 2 x) 1))
>     (define (rightChild x) (+ (* 2 x) 2))
>     (define (deleteExtreme)
>         (define temp (getElement items 0))
>         (setElement! items 0 (getElement items (- size 1)))
>         (setElement! items (- size 1) temp)
>         (set! 'size (- size 1))
>         (heapify 0)
>         temp
>         )
> 
>     (define (heapify root)
>         (define extreme nil)
>         (define newRoot nil)
23c19
<         if (leaf?(root)) { return :ok; }
---
>         (if (leaf? root) (return 'ok))
25c21
<         extreme = findExtremalChild(root);
---
>         (set! 'extreme (findExtremalChild root))
27c23
<         if (extreme == items[root]) { return :ok; }
---
>         (if (== extreme (getElement items root)) (return 'ok))
29,92c25,79
<         if (extreme == items[leftChild(root)])
<             {
<             newRoot = leftChild(root);
<             }
<         else
<             {
<             newRoot = rightChild(root);
<             }
<         items[newRoot] = items[root];
<         items[root] = extreme;
<         heapify(newRoot);
<         }
<     function findExtremalChild(root)
<         {
<         var extreme;
< 
<         extreme = extremal(op,items[root],items[leftChild(root)]);
< 
<         if (rightChild(root) >= size)
<             {
<             extreme;
<             }
<         else
<             {
<             extremal(op,extreme,items[rightChild(root)]);
<             }
<         }
<     function build-heap()
<         {
<         var i;
< 
<         for (i = size - 1, i >= 0, i = i - 1)
<             {
<             heapify(i);
<             }
<         }
< 
<     function leaf?(x)
<         {
<         leftChild(x) >= size;
<         }
< 
<     build-heap();
<     this;
<     }
< 
< function heap-sort(items,op)
<     {
<     var i;
<     var h;
< 
<     h = heap(items,op);
< 
<     while (h . size > 0)
<         {
<         print(h . deleteMin());
<         if (h . size > 0,print(" "));
<         }
<     }
< 
< function extremal(op,a,b)
<     {
<     if (a op b,a,b);
<     }
---
>         (if (== extreme (getElement items (leftChild root)))
>             (set! 'newRoot (leftChild root))
>             (set! 'newRoot (rightChild root))
>             )
> 
>         (setElement! items newRoot (getElement items root))
>         (setElement! items root extreme)
>         (heapify newRoot)
>         )
> 
>     (define (findExtremalChild root)
>         (define extreme nil)
>         (set! 'extreme 
>             (extremal op
>                 (getElement items root)
>                 (getElement items (leftChild root))))
> 
>         (if (>= (rightChild root) size)
>             extreme
>             (extremal op extreme (getElement items (rightChild root)))
>             )
>         )
> 
>     (define (build-heap)
>         (define i nil)
>         (for (set! 'i (- size 1)) (>= i 0) (set! 'i (- i 1))
>             (println "heapifying element " i)
>             (heapify i)
>             (println "element " i " has been heapified")
>             )
>         )
> 
>     (define (leaf? x) (>= (leftChild x) size))
> 
>     (println "about to build-heap...")
>     (build-heap)
>     this
>     )
> 
> (define (heap-sort items op)
>     (define i nil)
>     (define h nil)
> 
>     (set! 'h (heap items op))
> 
>     (while (> (get 'size h) 0)
>         (print ((get 'deleteExtreme h)))
>         (if (> (get 'size h) 0) (print " "))
>         )
>     (println "\n")
>     )
> 
> (define (extremal op a b)
>     (if (op a b) a b)
>     )
94c81
< var a = array(3,6,3,9,4,10,5,29,4,6,0,20,25,16,88,0,31);
---
> (define a (array 3 6 3 9 4 10 5 29 4 6 0 20 25 16 88 0 31))
96,97c83
< heap-sort(a,>);
< println("\n");
---
> (heap-sort a >)
99,100c85,86
< inspect(a);
< inspect(extremal . parameters);
---
> (inspect a)
> (inspect (get 'parameters extremal))
102,105c88,90
< 88 31 29 25 20 16 10 9 6 6 5 4 4 3 3 0 0
< 
< a is [0,0,3,3,4,4,5,6,6,9,10,16,20,25,29,31,88]
< extremal . parameters is (op,a,b)
---
> about to build-heap...
> EXCEPTION: generalException
> file heapsort.s,line 50: set identifier resolved to type CONS, not SYMBOL
------------------------------------------
hide.s
------------------------------------------
37,41c37,38
< EVALUATION ERROR: :restrictedAssignment
< hide.s,line 7: you are only allowed to assign to simple variables
< 4
< 13
< 13
---
> EXCEPTION: nonFunction
> file hide.s,line 1: attempted to call STRING as a function
------------------------------------------
hook2.s
------------------------------------------
16,18c16,17
< about to greet...
< intercepted! initializer is hello, world!
< hello, world!
---
> EXCEPTION: undefinedVariable
> file hook2.s,line 1: variable function is undefined
------------------------------------------
hook.s
------------------------------------------
15,17c15,16
< Intercepted!
< about to greet...
< hello, world!
---
> EXCEPTION: undefinedVariable
> file hook.s,line 1: variable function is undefined
------------------------------------------
if2.s
------------------------------------------
27c27,28
< three *is* less than 4!
---
> EXCEPTION: undefinedVariable
> file if2.s,line 1: variable var is undefined
------------------------------------------
if3.s
------------------------------------------
47,63c47,48
< EVALUATION ERROR: :argumentCountError
< if3.s,line 8: too many arguments to if
< the test is true
< naughts!
< the test is false
< the test is true
< onesies!
< the test is false
< the test is false
< the test is true
< binary!
< the test is false
< the test is false
< the test is false
< the test is true
< trinary!
< call if with too many arguments
---
> EXCEPTION: undefinedVariable
> file if3.s,line 1: variable var is undefined
------------------------------------------
if4.s
------------------------------------------
26,45c26,27
< function (test,$tBranch,$fBranch)
<     {
<     var oldIf = context . context . if;
<     print("the test is ",test,"
< ");
<     oldIf (test)
<         {
<         while (:false)
<             {
<             println("huh");
<             }
<         force($tBranch);
<         }
<     else
<         {
<         force($fBranch);
<         }
<     }
< the test is true
< three *is* less than 4!
---
> EXCEPTION: undefinedVariable
> file if4.s,line 1: variable var is undefined
------------------------------------------
if5.s
------------------------------------------
24c24,25
< 3 is less than 4!
---
> EXCEPTION: undefinedVariable
> file if5.s,line 1: variable var is undefined
------------------------------------------
if.s
------------------------------------------
33,35c33,34
< enter 0, 1, or 2: 
< you entered 3
< can't follow directions, can you?
---
> EXCEPTION: undefinedVariable
> file if.s,line 1: variable //overload is undefined
------------------------------------------
lhs.s
------------------------------------------
30,33c30,31
< z is 3 (should be 3)
< xobj's a is z (should be z)
< z now is 5 (should be 5)
< xobj's a now is q (should be q)
---
> EXCEPTION: undefinedVariable
> file lhs.s,line 1: variable var is undefined
------------------------------------------
linecheck.s
------------------------------------------
186,188c186,187
< done
< even
< cleaning up...
---
> EXCEPTION: lexicalException
> file linecheck.s,line 64: misformed number (1])
------------------------------------------
list.s
------------------------------------------
98,113c98,99
< [ ]
< [ 4 ]
< [ 3 ]
< [ 3 4 ]
< [ 2 ]
< [ 2 4 ]
< [ 2 3 ]
< [ 2 3 4 ]
< [ 1 ]
< [ 1 4 ]
< [ 1 3 ]
< [ 1 3 4 ]
< [ 1 2 ]
< [ 1 2 4 ]
< [ 1 2 3 ]
< [ 1 2 3 4 ]
---
> EXCEPTION: syntaxException
> file list.s,line 97: expecting CLOSE_PARENTHESIS, found END_OF_INPUT instead
------------------------------------------
logic.s
------------------------------------------
1,62c1,42
< function AND(in1, in2, out, agenda)
<     {
<     var delay = 4; //milliseconds
<     function recalculate()
<         {
<         if (in1 . get() == 1 && in2 . get() == 1)
<             {
<             agenda . schedule(out . set(1), delay);
<             }
<         else
<             {
<             agenda . schedule(out . set(0), delay);
<             }
<         }
< 
<     in1 . register(this);
<     in2 . register(this);
<     recalculate();
<     this;
<     }
< 
< 
< function OR(in1, in2, out, agenda)
<     {
<     var delay = 3; //milliseconds
<     function recalculate()
<         {
<         if (in1 . get() == 1 || in2 . get() == 1)
<             {
<             agenda . schedule(out . set(1), delay);
<             }
<         else
<             {
<             agenda . schedule(out . set(0), delay);
<             }
<         }
< 
<     in1 . register(this);
<     in2 . register(this);
<     this;
<     }
< 
< 
< function NOT(in, out, agenda)
<     {
<     var delay = 1; //milliseconds
<     function recalculate()
<         {
<         if (in . get() == 0)
<             {
<             agenda . schedule(out . set(1), delay);
<             }
<         else
<             {
<             //println("output is 0");
<             agenda . schedule(out . set(0), delay);
<             }
<         }
< 
<     in . register(this);
<     this;
<     }
---
> (define (AND in1 in2 out agenda)
>     (define delay 4)  ;milliseconds
>     (define (recalculate)
>         (if (and (== ((. in1 get)) 1) (== ((. in2 get)) 1))
>             ((. agenda schedule) ((. out set) 1) delay)
>             ((. agenda schedule) ((. out set) 0) delay)
>             )
>         )
> 
>     ((. in1 register) this)
>     ((. in2 register) this)
>     (recalculate)
>     this
>     )
> 
> 
> (define (OR in1 in2 out agenda)
>     (define delay 3) ;milliseconds
>     (define (recalculate)
>         (if (or (== ((. in1 get)) 1) (== ((. in2 get)) 1))
>             ((. agenda schedule) ((. out set) 1) delay)
>             ((. agenda schedule) ((. out set) 0) delay)
>             )
>         )
> 
>     ((. in1 register) this)
>     ((. in2 register) this)
>     this
>     )
> 
> (define (NOT in out agenda)
>     (define delay 1)  ;milliseconds
>     (define (recalculate)
>         (if (== ((. in get)) 0)
>             ((. agenda schedule) ((. out set) 1) delay)
>             ((. agenda schedule) ((. out set) 0) delay)
>             )
>         )
> 
>     ((. in register) this)
>     this
>     )
------------------------------------------
map.s
------------------------------------------
45,56c45,46
< mapping [ 1 2 3 4 ] 
< mapping [ 2 3 4 ] 
< mapping [ 3 4 ] 
< mapping [ 4 ] 
< mapping [ ] 
< returning null
< joining 16 with null
< joining 9 with (16)
< joining 4 with (9,16)
< joining 1 with (4,9,16)
< [ 1 2 3 4 ] 
< [ 1 4 9 16 ] 
---
> EXCEPTION: undefinedVariable
> file map.s,line 1: variable var is undefined
------------------------------------------
matrixproblem.s
------------------------------------------
27,28c27,28
< length(mat) is 10
< length(mat) is 20
---
> EXCEPTION: nonFunction
> file matrixproblem.s,line 1: attempted to call STRING as a function
------------------------------------------
object3.s
------------------------------------------
49,68c49,56
< (locals b) is (__label __context __level __constructor this parent x)
< (local? parent b) is #t
< (local? Parent b) is #f
< a . x is 4
< (. a x) is 4
< <object 10983>
<              __label  : closure
<            __context  : <object 9029>
<                 name  : alpha
<           parameters  : (x)
<                 code  : (begin (define parent nil) this)
< (. (. a __constructor) name) is alpha
< (. b x) is 5
< (. (. b __constructor) name) is alpha
< (is? a (quote alpha)) is #t
< (is? b (quote alpha)) is #t
< (is? b (quote beta)) is #f
< (is? c (quote beta)) is #t
< (is? c (quote alpha)) is #t
< (is? c (quote gamma)) is #f
---
> (locals b) is <object 25914>
>              __label  : throw
>                 code  : undefinedVariable
>                value  : "file object3.s,line 25: variable locals is undefined"
>                trace  : ((locals b))
> 
> EXCEPTION: undefinedVariable
> file object3.s,line 25: variable locals is undefined
------------------------------------------
object.s
------------------------------------------
36c36
< z is <object 9629>
---
> z is <object 13341>
38c38
<            __context  : <object 9516>
---
>            __context  : <object 11702>
41c41
<                 this  : <object 9629>
---
>                 this  : <object 13341>
------------------------------------------
obj.s
------------------------------------------
------------------------------------------
overlay.s
------------------------------------------
0a1,41
> function stack()
>     {
>     var store = :null;
>     function pop()
>         {
>         var p = head(store);
>         store = tail(store);
>         p;
>         }
>     function push(item)
>         {
>         store = item join store;
>         item;
>         }
>     function empty?()
>         {
>         return store == :null;
>         }
>     this;
>     }
> 
> function stack()
>     {
>     function pop()
>         {
>         if (empty?(),throw(:stackException,"popped an empty stack"));
>         pop . prior();
>         }
>     extends(stack . prior());
>     this;
>     }
> 
> var s = stack();
> 
> pp(stack);
> inspect(s . push(5));
> inspect(s . pop());
> inspect(s . pop());
> ------------------------------------------
> EXCEPTION: undefinedVariable
> file overlay.s,line 1: variable function is undefined
------------------------------------------
overload.s
------------------------------------------
15,19c15,16
< local + is <function +(x,y)>
< non-local + is <function +(x,y)>
< non-non-local + is <function +(a,b)>
< shadowed + is <function +(a,b)>
< x is 7
---
> EXCEPTION: nonFunction
> file overload.s,line 1: attempted to call STRING as a function
------------------------------------------
p1.s
------------------------------------------
16,18c16,17
< in overridden +
< 3
< hello, world
---
> EXCEPTION: undefinedVariable
> file p1.s,line 1: variable var is undefined
------------------------------------------
pp.s
------------------------------------------
54,99c54,55
< function f(a,b,c)
<     {
<     var x;
<     if (true)
<         {
<         var x = 3;
<         var y = 4;
<         print(x);
<         print(y);
<         while (x > y)
<             {
<             x = x - 1;
<             y = y + 1;
<             }
<         }
<     else if (false)
<         {
<         :ok;
<         }
<     else if (true)
<         {
<         :ok;
<         }
<     else
<         {
<         print("huh?");
<         }
<     return :oops;
<     }
< function mv(m,v)
<     {
<     function q()
<         {
<         x;
<         }
<     function h()
<         {
<         3 * 3;
<         }
<     map(function (r) { r dot-product v; },m);
<     }
< ["pp.s"]
< <THUNK 7272>:
<     context: <OBJECT 984>
<     code: hello + goodbye
< 
---
> EXCEPTION: syntaxException
> file pp.s,line 53: expecting CLOSE_PARENTHESIS, found END_OF_INPUT instead
------------------------------------------
pq.s
------------------------------------------
32,52c32,33
< enqueueing: 3
<     first item is 3
<     first rank is 6
< enqueueing: 2
<     first item is 2
<     first rank is 4
< enqueueing: 0
<     first item is 0
<     first rank is 0
< enqueueing: 1
<     first item is 0
<     first rank is 0
< enqueueing: 4
<     first item is 0
<     first rank is 0
< 
< dequeueing: 0
< dequeueing: 1
< dequeueing: 2
< dequeueing: 3
< dequeueing: 4
---
> EXCEPTION: nonFunction
> file pq.s,line 1: attempted to call STRING as a function
------------------------------------------
priorityQueue.s
------------------------------------------
1,7c1,5
< function priorityQueue()
<     {
<     var items;
<     function bundle(data,rank,next) { return this; }
<     function dequeue()
<         {
<         var item;
---
> (define (priorityQueue)
>     (define items)
>     (define (bundle data rank next) this)
>     (define (dequeue)
>         (define item)
9,17c7,14
<         item = items . next . data;
<         items . next = items . next . next;
<         return item;
<         }
<     function enqueue(item,rank)
<         {
<         var prefix = items;
<         var suffix = items . next;
<         var package = bundle(item,rank,:null);
---
>         (assign item (. items next data))
>         (assign (. items next) (. items next next))
>         item
>         )
>     (define (enqueue item rank)
>         (define prefix items)
>         (define suffix (. items next))
>         (define package (bundle item rank nil))
19,23c16,19
<         while (suffix != :null && rank >= suffix . rank)
<             {
<             prefix = suffix;
<             suffix = suffix . next;
<             }
---
>         (while (and (valid? suffix) (>= rank (. suffix rank)))
>             (assign prefix suffix)
>             (assign suffix (. suffix next))
>             )
25,30c21,26
<         prefix . next = package;
<         package . next = suffix;
<         }
<     function peekItem() { return items . next . data; }
<     function peekRank() { return items . next . rank; }
<     function empty()    { return items . next == :null; }
---
>         (assign (. prefix next) package)
>         (assign (. package next) suffix)
>         )
>     (define (peekItem) (. items next data))
>     (define (peekRank) (. items next rank))
>     (define (empty)    (null? (. items next)))
32,34c28,30
<     items = bundle(:null,:null,:null); //dummy head node
<     this;
<     }
---
>     (assign items (bundle nil nil nil))  ;dummy head node
>     this
>     )
------------------------------------------
prior.s
------------------------------------------
19,20c19,20
< well, hello there!
< hi,all!
---
> EXCEPTION: undefinedVariable
> file prior.s,line 1: variable function is undefined
------------------------------------------
rb.s
------------------------------------------
1,365c1,330
< include("debug");
< 
< var root = :null;
< 
< function node(value,left,right)
<     {
<     var parent;
<     var color;
< 
<     function display()
<         {
<         println("value:  ", value);
<         println("left:   ", left);
<         println("right:  ", right);
<         println("parent: ", parent);
<         println("color:  ", color);
<         }
< 
<     this;
<     }
< 
< function printTree(t)
<     {
<     function iter(r, indent)
<         {
<         if (r == :null)
<             {
<             println("null");
<             }
<         else
<             {
<             println(r . value, "(", r . color, ")");
<             print(indent, "left:  ");
<             iter(r . left,indent + "    ");
<             print(indent, "right: ");
<             iter(r . right,indent + "    ");
<             }
<         }
< 
<     iter(t, "   ");
<     }
< 
< function insert(t, v, op)
<     {
<     if (t == :null)
<         {
<         root = node(v,:null,:null);
<         root . parent = root;
<         insertionFixup(root);
<         }
<     else
<         {
<         var lessThan = v op t . value;
< 
<         if (lessThan && t . left != :null)
<             {
<             insert(t . left, v, op);
<             }
<         else if (lessThan)
<             {
<             t . left = node(v,:null,:null);
<             t . left . parent = t;
<             insertionFixup(t . left);
<             }
<         else if (t . right != :null)
<             {
<             insert(t . right, v, op);
<             }
<         else
<             {
<             t . right = node(v, :null, :null);
<             t . right . parent = t;
<             insertionFixup(t . right);
<             }
<         }
<     }
< 
< function prune(x)
<     {
<     assert(leaf?(x) == :true);
<     if (leftChild?(x))
<         {
<         parent(x) . left = :null;
<         }
<     else if (rightChild?(x))
<         {
<         parent(x) . right = :null;
<         }
<     else
<         {
<         root = :null;
<         }
<     }
< 
< function swapToLeaf(x)
<     {
<     if (leaf?(x) == :false)
<         {
<         var y;
<         var temp;
< 
<         if (x . right != :null)
<             {
<             y = findMin(x . right);
<             }
<         else
<             {
<             y = findMax(x . left);
<             }
< 
<         temp = x . value;
<         x . value = y . value;
<         y . value = temp;
< 
<         swapToLeaf(y);
<         }
<     else
<         {
<         x;
<         }
<     }
< function findMin(x)
<     {
<     while (x . left != :null)
<         {
<         x = x . left;
<         }
<     return x;
<     }
< function findMax(x)
<     {
<     while (x . right != :null)
<         {
<         x = x . right;
<         }
<     return x;
<     }
< function delete(x)
<     {
<     x = swapToLeaf(x);
<     deletionFixup(x);
<     //println("pruning ", x . value);
<     prune(x);
<     }
< 
< function deletionFixup(x)
<     {
<     while (root?(x) == :false && x . color == :black)
<         {
<         if (red?(sibling(x)))
<             {
<             parent(x) . color = :red;
<             sibling(x) . color = :black;
<             rotate(sibling(x),parent(x));
<             // should have black sibling now
<             assert(sibling(x) . color == :black);
<             }
<         else if (red?(nephew(x)))
<             {
<             sibling(x) . color = parent(x) . color;
<             parent(x) . color = :black;
<             nephew(x) . color = :black;
<             rotate(sibling(x),parent(x));
<             x = root;
<             // subtree is bh balanced
<             // with proper bh contribution
<             }
<         else if (red?(niece(x)))
<             {
<             // nephew must be black
<             niece(x) = :black;
<             sibling(x) = :red;
<             rotate(neice(x),sibling(x));
<             // should have red nephew now
<             assert(nephew(x) . color == :red);
<             }
<         else
<             {
<             // sibling, niece, and nephew must be black
<             sibling(x) . color = :red;
<             x = parent(x);
<             // subtree is bh balanced
<             // but has deficit in bh contribution
<             }
<         }
< 
<     x . color = :black;
<     }
< 
< function insertionFixup(x)
<     {
<     x . color = :red;
< 
<     while (root?(x) == :false && x . parent . color == :red)
<         {
<         if (red?(uncle(x)))
<             {
<             parent(x) . color = :black;
<             uncle(x) . color = :black;
<             grandparent(x) . color = :red;
<             x = grandparent(x);
<             }
<         else
<             {
<             // uncle must be black
< 
<             if (linear?(x, parent(x), grandparent(x)) == :false)
<                 {
<                 var oldParent = parent(x);
<                 rotate(x,parent(x));
<                 x = oldParent;
<                 }
< 
<             parent(x) . color = :black;
<             assert(x . parent . color == :black);
<             grandparent(x) . color = :red;
<             rotate(parent(x),grandparent(x));
<             }
<         }
< 
<     root . color = :black;
<     }
< 
< function root?(x) { x == x . parent; }
< function leftChild?(x) { return parent(x) . left == x; }
< function rightChild?(x) { return parent(x) . right == x; }
< function leaf?(x) { x . left == :null && x . right == :null; }
< function red?(x) { return x != :null && x . color == :red; }
< function black?(x) { return x == :null || x . color == :black; }
< 
< function sibling(x)
<     {
<     if (leftChild?(x))
<         {
<         x . parent . right;
<         }
<     else if (rightChild?(x))
<         {
<         x . parent . left;
<         }
<     else
<         {
<         :null;
<         }
<     }
< function niece(x)       //precondition: sibling exists
<     {
<     if (leftChild?(x))
<         {
<         sibling(x) . left;
<         }
<     else
<         {
<         sibling(x) . right;
<         }
<     }
< function nephew(x)      //precondition: sibling exists
<     {
<     if (leftChild?(x))
<         {
<         sibling(x) . right;
<         }
<     else
<         {
<         sibling(x) . left;
<         }
<     }
< function parent(x) { x . parent; }
< function grandparent(x) { parent(x) . parent; }
< function uncle(x)
<     {
<     if (leftChild?(parent(x)))
<         {
<         return grandparent(x) . right;
<         }
<     else if (rightChild?(parent(x)))
<         {
<         return grandparent(x) . left;
<         }
<     else
<         {
<         return :null;
<         }
<     }
< function linear?(x,y,z)
<     {
<     return
<         ((leftChild?(x)  && leftChild?(y)) ||
<          (rightChild?(x) && rightChild?(y)));
<     }
< 
< 
< function rotate(x,p)
<     {
<     if (p . left == x) 
<         {
<         //rotate right
<         rotator(x,p,:right,:left);
<         }
<     else if (p . right == x)
<         {
<         //rotate left
<         rotator(x,p,:left,:right);
<         }
<     else
<         {
<         throw("rotate error");
<         }
<     }
< function rotator(x,p,direction,oppositeDirection)
<     {
<     var gp = parent(p);
<     var beta = x . (direction);
< 
<     p . (oppositeDirection) = beta;
<     if (beta != :null) { beta . parent = p; }
< 
<     x . (direction) = p;
<     p . parent = x;
< 
<     if (p == gp)
<         {
<         root = x;
<         x . parent = x;
<         }
<     else {
<         if (gp . (direction) == p) { gp . (direction) = x; }
<         else { gp . (oppositeDirection) = x; }
<         x . parent = gp;
<         }
<     }
< 
< function findNode(t, v, op)
<     {
<     if (t == :null || v == t . value)
<         {
<         t;
<         }
<     else if (v op t . value)
<         {
<         findNode(t . left, v, op);
<         }
<     else
<         {
<         findNode(t . right, v, op);
<         }
<     }
< 
< function main()
<     {
<     var i;
<     var num = :null;
<     var x;
<     var input = array(1, 2, 9, 3, 6, 4, 7, 8, 5);
< 
<     i = 0;
<     while (i < length(input))
<         {
<         num = input . i;
<         println("inserting!");
<         insert(root, num, <);
<         print(num," inserted.\n");
<         printTree(root);
<         i = i + 1;
<         }
---
> (define root nil)
> (define (assert # $x)
>     (if (not (eval $x #))
>         (throw 'assertionError $x)
>         )
>     )
> 
> (define (node value left right)
>     (define parent nil)
>     (define color nil)
> 
>     (define (display)
>         (println "value:  "  value)
>         (println "left:   "  left)
>         (println "right:  "  right)
>         (println "parent: "  parent)
>         (println "color:  "  color)
>         )
> 
>     this
>     )
> 
> (define (printTree t)
>     (define (iter r indent)
>         (if (null? r)
>             (println "null")
>             (begin
>                 (println (. r value)  "("  (. r color)  ")")
>                 (print indent "left:  ")
>                 (iter (. r left) (string+ indent "    "))
>                 (print indent  "right: ")
>                 (iter (. r right) (string+ indent "    "))
>                 )
>             )
>         )
> 
>     (iter t "   ")
>     )
> 
> (define (insert t v op)
>     (if (null? t)
>         (begin
>             (assign root (node v nil nil))
>             (assign (. root parent) root)
>             (insertionFixup root)
>             )
>         (begin
>             (define lessThan (op v (. t value)))
> 
>             (cond
>                 ((and lessThan (valid? (. t left)))
>                     (insert (. t left)  v  op)
>                     )
>                 (lessThan
>                     (assign (. t left) (node v nil nil))
>                     (assign (. (. t left) parent) t)
>                     (insertionFixup (. t left))
>                     )
>                 ((valid? (. t right))
>                     (insert (. t right)  v  op)
>                     )
>                 (else
>                     (assign (. t right) (node v nil nil))
>                     (assign (. (. t right) parent) t)
>                     (insertionFixup (. t right))
>                     )
>                 )
>             )
>         )
>     )
> (define (prune x)
>     (assert (leaf? x))
>     (cond
>         ((leftChild? x)
>             (assign (. (parent x) left) nil)
>             )
>         ((rightChild? x)
>             (assign (. (parent x) right) nil)
>             )
>         (else
>             (assign root nil)
>             )
>         )
>     )
> 
> (define (swapToLeaf x)
>     (if (not (leaf? x))
>         (begin
>             (define y nil)
>             (define temp nil)
> 
>             (if (valid? (. x right))
>                 (assign y (findMin (. x right)))
>                 (assign y (findMax (. x left)))
>                 )
> 
>             (assign temp (. x value))
>             (assign (. x value) (. y value))
>             (assign (. y value) temp)
> 
>             (swapToLeaf y)
>             )
>         x
>         )
>     )
> 
> (define (findMin x)
>     (while (valid? (. x left))
>         (assign x (. x left))
>         )
>     x
>     )
> 
> (define (findMax x)
>     (while (valid? (. x right))
>         (assign x (. x right))
>         )
>     x
>     )
> 
> (define (delete x)
>     (assign x (swapToLeaf x))
>     (deletionFixup x)
>     ; (println "pruning "  (. x value))
>     (prune x)
>     )
> 
> (define (deletionFixup x)
>     (while (and (false? (root? x)) (eq? (. x color) 'black))
>         (cond
>             ((red? (sibling x))
>                 (assign (. (parent x) color) 'red)
>                 (assign (. (sibling x) color) 'black)
>                 (rotate (sibling x) (parent x))
>                 ; should have black sibling now
>                 (assert (eq? (. (sibling x) color) 'black))
>                 )
>             ((red? (nephew x))
>                 (assign (. (sibling x) color) (. (parent x) color))
>                 (assign (. (parent x) color) 'black)
>                 (assign (. (nephew x) color) 'black)
>                 (rotate (sibling x) (parent x))
>                 (assign x root)
>                 ; subtree is bh balanced
>                 ; with proper bh contribution
>                 )
>             ((red? (niece x))
>                 ; nephew must be black
>                 (assign (. (niece x) color) 'black)
>                 (assign (. (sibling x) color) 'red)
>                 (rotate (niece x) (sibling x))
>                 ; should have red nephew now
>                 (assert (eq? (. (nephew x) color) 'red))
>                 )
>             (else
>                 ; sibling  niece  and nephew must be black
>                 (assign (. (sibling x) color) 'red)
>                 (assign x (parent x))
>                 ; subtree is bh balanced
>                 ; but has deficit in bh contribution
>                 )
>             )
> 
>         (assign (. x color) 'black)
>         )
>     )
> 
> (define (insertionFixup x)
>     (assign (. x color) 'red)
> 
>     (while (and (not (root? x)) (eq? (. (. x parent) color) 'red))
>         (if (red? (uncle x))
>             (begin
>                 (assign (. (parent x) color) 'black)
>                 (assign (. (uncle x) color) 'black)
>                 (assign (. (grandparent x) color) 'red)
>                 (assign x (grandparent x))
>                 )
>             (begin
>                 ; uncle must be black
> 
>                 (if (not (linear? x (parent x) (grandparent x)))
>                     (begin
>                         (define oldParent (parent x))
>                         (rotate x (parent x))
>                         (assign x oldParent)
>                         )
>                     )
> 
>                 (assign (. (parent x) color) 'black)
>                 ;(inspect (. (parent x) color))
>                 (assert (eq? (. (. x parent) color) 'black))
>                 (assign (. (grandparent x) color) 'red)
>                 (rotate (parent x) (grandparent x))
>                 )
>             )
>         )
>     (assign (. root color) 'black)
>     )
> 
> (define (root? x) (eq? x (. x parent)))
> (define (leftChild? x) (eq? (. (parent x) left) x))
> (define (rightChild? x) (eq? (. (parent x) right) x))
> (define (leaf? x) (and (null? (. x left))(null? (. x right))))
> (define (red? x) (and (valid? x) (eq? (. x color) 'red)))
> (define (black? x) (or  (null? x) (eq? (. x color) 'black)))
> 
> (define (sibling x)
>     (cond
>         ((leftChild? x)
>             (. (. x parent) right)
>             )
>         ((rightChild? x)
>             (. (. x parent) left)
>             )
>         (else
>             nil
>             )
>         )
>     )
> 
> (define (niece x)       ; precondition: sibling exists
>     (if (leftChild? x)
>         (. (sibling x) left)
>         (. (sibling x) right)
>         )
>     )
> 
> (define (nephew x)      ; precondition: sibling exists
>     ;(inspect (sibling x))
>     (if (leftChild? x)
>         (. (sibling x) right)
>         (. (sibling x) left)
>         )
>     )
> 
> (define (parent x) (. x parent))
> (define (grandparent x) (parent (parent x)))
> (define (uncle x)
>     (cond
>         ((leftChild? (parent x))
>             (. (grandparent x) right))
>         ((rightChild? (parent x))
>             (. (grandparent x) left))
>         (else
>             nil)
>         )
>     )
> 
> (define (linear? x y z)
>     (or
>         (and (leftChild? x) (leftChild? y))
>         (and (rightChild? x) (rightChild? y))
>         )
>     )
> 
> (define (rotate x p)
>     (cond
>         ((eq? (. p left) x) 
>             ; rotate right
>             (println "rotating right")
>             (rotator x p 'right 'left)
>             )
>         ((eq? (. p right) x)
>             ; rotate left
>             (println "rotating left")
>             (rotator x p 'left 'right)
>             )
>         (else
>             (throw 'redBlackException "rotate error")
>             )
>         )
>     )
> 
> (define (id x) x)
> 
> (define (rotator x p direction oppositeDirection)
>     (define gp (parent p))
>     (define beta (. x (id direction)))
> 
>     (assign (. p (id oppositeDirection)) beta)
>     (if (valid? beta) (assign (. beta parent) p))
> 
>     (assign (. x (id direction)) p)
>     (assign (. p parent) x)
> 
>     (if (eq? p gp)
>         (begin
>             (assign root x)
>             (assign (. x parent) x)
>             )
>         (begin
>             (if (eq? (. gp (id direction)) p)
>                 (assign (. gp (id direction)) x)
>                 (assign (. gp (id oppositeDirection)) x)
>                 )
>             (assign (. x parent) gp)
>             )
>         )
>     )
> 
> (define (findNode t v op)
>     (cond
>         ((or (null? t) (eq? v (. t value)))
>             t
>             )
>         ((op v (. t value))
>             (findNode (. t left) v op)
>             )
>         (else
>             (findNode (. t right) v op)
>             )
>         )
>     )
> 
> (define (main)
>     (define i nil)
>     (define num nil)
>     (define x nil)
>     (define input (array 1  2  9  3  6  4  7  8  5))
> 
>     (assign i 0)
>     (while (< i (length input))
>         (assign num (getElement input i))
>         (println "inserting!")
>         (insert root num <)
>         (println num " inserted.")
>         (printTree root)
>         (assign i (+ i 1))
>         )
367,384c332,348
<     println("insertion phase complete, tree is...");
<     printTree(root);
<     println("deletion phase begins...");
< 
<     i = 0;
<     while (i < length(input))
<         {
<         num = input . i;
<         x = findNode(root,num,<);
<         delete(x);
<         print(num," deleted.\n");
<         printTree(root);
<         i = i + 1;
<         }
< 
<     println("deletion phase complete, tree is...");
<     print("good-bye!\n");
<     }
---
>     (println "insertion phase complete  tree is...")
>     (printTree root)
>     (println "deletion phase begins...")
> 
>     (assign i 0)
>     (while (< i (length input))
>         (assign num (getElement input i))
>         (assign x (findNode root num <))
>         (delete x)
>         (println num " deleted.")
>         (printTree root)
>         (assign i (+ i 1))
>         )
> 
>     (println "deletion phase complete  tree is...")
>     (println "good-bye!")
>     )
386,387c350,351
< print("hello\n");
< main();
---
> (println "hello");
> (main)
403,619c367,369
< 9 inserted.
< 2(black)
<    left:  1(red)
<        left:  null
<        right: null
<    right: 9(red)
<        left:  null
<        right: null
< inserting!
< 3 inserted.
< 2(black)
<    left:  1(black)
<        left:  null
<        right: null
<    right: 9(black)
<        left:  3(red)
<            left:  null
<            right: null
<        right: null
< inserting!
< 6 inserted.
< 2(black)
<    left:  1(black)
<        left:  null
<        right: null
<    right: 6(black)
<        left:  3(red)
<            left:  null
<            right: null
<        right: 9(red)
<            left:  null
<            right: null
< inserting!
< 4 inserted.
< 2(black)
<    left:  1(black)
<        left:  null
<        right: null
<    right: 6(red)
<        left:  3(black)
<            left:  null
<            right: 4(red)
<                left:  null
<                right: null
<        right: 9(black)
<            left:  null
<            right: null
< inserting!
< 7 inserted.
< 2(black)
<    left:  1(black)
<        left:  null
<        right: null
<    right: 6(red)
<        left:  3(black)
<            left:  null
<            right: 4(red)
<                left:  null
<                right: null
<        right: 9(black)
<            left:  7(red)
<                left:  null
<                right: null
<            right: null
< inserting!
< 8 inserted.
< 2(black)
<    left:  1(black)
<        left:  null
<        right: null
<    right: 6(red)
<        left:  3(black)
<            left:  null
<            right: 4(red)
<                left:  null
<                right: null
<        right: 8(black)
<            left:  7(red)
<                left:  null
<                right: null
<            right: 9(red)
<                left:  null
<                right: null
< inserting!
< 5 inserted.
< 2(black)
<    left:  1(black)
<        left:  null
<        right: null
<    right: 6(red)
<        left:  4(black)
<            left:  3(red)
<                left:  null
<                right: null
<            right: 5(red)
<                left:  null
<                right: null
<        right: 8(black)
<            left:  7(red)
<                left:  null
<                right: null
<            right: 9(red)
<                left:  null
<                right: null
< insertion phase complete, tree is...
< 2(black)
<    left:  1(black)
<        left:  null
<        right: null
<    right: 6(red)
<        left:  4(black)
<            left:  3(red)
<                left:  null
<                right: null
<            right: 5(red)
<                left:  null
<                right: null
<        right: 8(black)
<            left:  7(red)
<                left:  null
<                right: null
<            right: 9(red)
<                left:  null
<                right: null
< deletion phase begins...
< 1 deleted.
< 6(black)
<    left:  4(red)
<        left:  2(black)
<            left:  null
<            right: 3(red)
<                left:  null
<                right: null
<        right: 5(black)
<            left:  null
<            right: null
<    right: 8(black)
<        left:  7(red)
<            left:  null
<            right: null
<        right: 9(red)
<            left:  null
<            right: null
< 2 deleted.
< 6(black)
<    left:  4(red)
<        left:  3(black)
<            left:  null
<            right: null
<        right: 5(black)
<            left:  null
<            right: null
<    right: 8(black)
<        left:  7(red)
<            left:  null
<            right: null
<        right: 9(red)
<            left:  null
<            right: null
< 9 deleted.
< 6(black)
<    left:  4(red)
<        left:  3(black)
<            left:  null
<            right: null
<        right: 5(black)
<            left:  null
<            right: null
<    right: 8(black)
<        left:  7(red)
<            left:  null
<            right: null
<        right: null
< 3 deleted.
< 6(black)
<    left:  4(black)
<        left:  null
<        right: 5(red)
<            left:  null
<            right: null
<    right: 8(black)
<        left:  7(red)
<            left:  null
<            right: null
<        right: null
< 6 deleted.
< 7(black)
<    left:  4(black)
<        left:  null
<        right: 5(red)
<            left:  null
<            right: null
<    right: 8(black)
<        left:  null
<        right: null
< 4 deleted.
< 7(black)
<    left:  5(black)
<        left:  null
<        right: null
<    right: 8(black)
<        left:  null
<        right: null
< 7 deleted.
< 8(black)
<    left:  5(red)
<        left:  null
<        right: null
<    right: null
< 8 deleted.
< 5(black)
<    left:  null
<    right: null
< 5 deleted.
< null
< deletion phase complete, tree is...
< good-bye!
---
> rotating left
> EXCEPTION: generalException
> file rb.s,line 281: set identifier resolved to type CONS, not SYMBOL
------------------------------------------
recur.s
------------------------------------------
32c32,33
< 5050
---
> EXCEPTION: undefinedVariable
> file recur.s,line 1: variable function is undefined
------------------------------------------
recursion.s
------------------------------------------
23,423c23,24
< 399
< 398
< 397
< 396
< 395
< 394
< 393
< 392
< 391
< 390
< 389
< 388
< 387
< 386
< 385
< 384
< 383
< 382
< 381
< 380
< 379
< 378
< 377
< 376
< 375
< 374
< 373
< 372
< 371
< 370
< 369
< 368
< 367
< 366
< 365
< 364
< 363
< 362
< 361
< 360
< 359
< 358
< 357
< 356
< 355
< 354
< 353
< 352
< 351
< 350
< 349
< 348
< 347
< 346
< 345
< 344
< 343
< 342
< 341
< 340
< 339
< 338
< 337
< 336
< 335
< 334
< 333
< 332
< 331
< 330
< 329
< 328
< 327
< 326
< 325
< 324
< 323
< 322
< 321
< 320
< 319
< 318
< 317
< 316
< 315
< 314
< 313
< 312
< 311
< 310
< 309
< 308
< 307
< 306
< 305
< 304
< 303
< 302
< 301
< 300
< 299
< 298
< 297
< 296
< 295
< 294
< 293
< 292
< 291
< 290
< 289
< 288
< 287
< 286
< 285
< 284
< 283
< 282
< 281
< 280
< 279
< 278
< 277
< 276
< 275
< 274
< 273
< 272
< 271
< 270
< 269
< 268
< 267
< 266
< 265
< 264
< 263
< 262
< 261
< 260
< 259
< 258
< 257
< 256
< 255
< 254
< 253
< 252
< 251
< 250
< 249
< 248
< 247
< 246
< 245
< 244
< 243
< 242
< 241
< 240
< 239
< 238
< 237
< 236
< 235
< 234
< 233
< 232
< 231
< 230
< 229
< 228
< 227
< 226
< 225
< 224
< 223
< 222
< 221
< 220
< 219
< 218
< 217
< 216
< 215
< 214
< 213
< 212
< 211
< 210
< 209
< 208
< 207
< 206
< 205
< 204
< 203
< 202
< 201
< 200
< 199
< 198
< 197
< 196
< 195
< 194
< 193
< 192
< 191
< 190
< 189
< 188
< 187
< 186
< 185
< 184
< 183
< 182
< 181
< 180
< 179
< 178
< 177
< 176
< 175
< 174
< 173
< 172
< 171
< 170
< 169
< 168
< 167
< 166
< 165
< 164
< 163
< 162
< 161
< 160
< 159
< 158
< 157
< 156
< 155
< 154
< 153
< 152
< 151
< 150
< 149
< 148
< 147
< 146
< 145
< 144
< 143
< 142
< 141
< 140
< 139
< 138
< 137
< 136
< 135
< 134
< 133
< 132
< 131
< 130
< 129
< 128
< 127
< 126
< 125
< 124
< 123
< 122
< 121
< 120
< 119
< 118
< 117
< 116
< 115
< 114
< 113
< 112
< 111
< 110
< 109
< 108
< 107
< 106
< 105
< 104
< 103
< 102
< 101
< 100
< 99
< 98
< 97
< 96
< 95
< 94
< 93
< 92
< 91
< 90
< 89
< 88
< 87
< 86
< 85
< 84
< 83
< 82
< 81
< 80
< 79
< 78
< 77
< 76
< 75
< 74
< 73
< 72
< 71
< 70
< 69
< 68
< 67
< 66
< 65
< 64
< 63
< 62
< 61
< 60
< 59
< 58
< 57
< 56
< 55
< 54
< 53
< 52
< 51
< 50
< 49
< 48
< 47
< 46
< 45
< 44
< 43
< 42
< 41
< 40
< 39
< 38
< 37
< 36
< 35
< 34
< 33
< 32
< 31
< 30
< 29
< 28
< 27
< 26
< 25
< 24
< 23
< 22
< 21
< 20
< 19
< 18
< 17
< 16
< 15
< 14
< 13
< 12
< 11
< 10
< 9
< 8
< 7
< 6
< 5
< 4
< 3
< 2
< 1
< 0
< bottom
---
> EXCEPTION: undefinedVariable
> file recursion.s,line 1: variable var is undefined
------------------------------------------
reflect.s
------------------------------------------
38,49c38,39
< x: a is 2, b is 3, c is 5
< n is constructed via m's constructor
< x: a is 2, b is 3, c is 8
< 
< m . constructor . name is x
< n . constructor . name is x
< 
< changing m . a to 10
< changing n . b to 10
< 
< x: a is 10, b is 3, c is 5
< x: a is 2, b is 10, c is 8
---
> EXCEPTION: nonFunction
> file reflect.s,line 1: attempted to call STRING as a function
------------------------------------------
reify.s
------------------------------------------
29,31c29,30
< calling superclass:a
< superclass:a: calling virtual function b
< subclass:b
---
> EXCEPTION: undefinedVariable
> file reify.s,line 1: variable function is undefined
------------------------------------------
return3.s
------------------------------------------
42,58c42,43
< g executing...
< r is <ERROR 5300>
< i is 0 and j is 1
< i is 0 and j is 2
< i is 0 and j is 3
< i is 0 and j is 4
< i is 1 and j is 1
< i is 1 and j is 2
< i is 1 and j is 3
< i is 1 and j is 4
< i is 2 and j is 1
< i is 2 and j is 2
< trying to leave f...
< g's z is 6
< g done.
< 6
< done
---
> EXCEPTION: nonFunction
> file return3.s,line 1: attempted to call STRING as a function
------------------------------------------
return.s
------------------------------------------
1,10c1,9
< function f()
<     {
<     var x;
<     print("entering f\n");
<     x = {
<         print("entering block\n");
<         return 3;
<         print("leaving block (this should not be displayed)\n");
<         5;
<         };
---
> (define (f)
>     (define x)
>     (println "entering f...")
>     (if #t
>         (print("entering block")
>         //(return 3)
>         (println "leaving block (this should not be displayed)")
>         5
>         }
11a11,12
>     //return 22;
>     print("really leaving f (this should not be displayed)\n");
14a16
> var z = 0;
16c18,20
< print("f() returns ",f(),"\n");
---
> z = f();
> print("f() returns ",z,"\n");
> println("done");
18,21c22,23
< f() should return 3
< entering f
< entering block
< f() returns 3
---
> EXCEPTION: syntaxException
> file return.s,line 21: expecting CLOSE_PARENTHESIS, found END_OF_INPUT instead
------------------------------------------
reverse.s
------------------------------------------
35,46c35,36
< reversing hello
< reversing ello
< reversing llo
< reversing lo
< reversing o
< reversing hello
< reversing ello
< reversing llo
< reversing lo
< reversing o
< reverse(hello) is olleh
< reverse2(hello) is olleh
---
> EXCEPTION: undefinedVariable
> file reverse.s,line 1: variable function is undefined
------------------------------------------
right.s
------------------------------------------
33,35c33,34
< items . item is 1
< items . item is 2
< items . item is 3
---
> EXCEPTION: nonFunction
> file right.s,line 1: attempted to call STRING as a function
------------------------------------------
sicp1.s
------------------------------------------
0a1,1115
> ;;;;CODE FROM CHAPTER 1 OF STRUCTURE AND INTERPRETATION OF COMPUTER PROGRAMS
> 
> ;;; Examples from the book are commented out with ;: so that they
> ;;;  are easy to find and so that they will be omitted if you evaluate a
> ;;;  chunk of the file (programs with intervening examples) in Scheme.
> 
> ;;; BEWARE: Although the whole file can be loaded into Scheme,
> ;;;  don't expect the programs to work if you do so.  For example,
> ;;;  the redefinition of + in exercise 1.9 wreaks havoc with the
> ;;;  last version of square defined here.
> 
> 
> (define original-+ +)
> (define original-* *)
> 
> ;;;SECTION 1.1.1
> 
> ;; interpreter examples
> 
> (define items '(
> 486
> 
> (+ 137 349)
> (- 1000 334)
> (* 5 99)
> (/ 10 5)
> (+ 2.7 10)
> 
> (+ 21 35 12 7)
> (- 21 35 12 7)
> (- 21)
> (* 25 4 12)
> 
> (+ (* 3 5) (- 10 6))
> 
> (+ (* 3 (+ (* 2 4) (+ 3 5))) (+ (- 10 7) 6))
> 
> (+ (* 3
>      (+ (* 2 4)
>         (+ 3 5)))
>   (+ (- 10 7)
>      6))
>    
> 
> 
> ;;;SECTION 1.1.2
> 
> (define size 2)
> size
> (* 5 size)
> 
> (define pi 3.14159)
> (define radius 10)
> (* pi (* radius radius))
> (define circumference (* 2 pi radius))
> circumference
> 
> 
> ;;;SECTION 1.1.3
> 
> (* (+ 2 (* 4 6)))
> (+ 3 5 7)
> 
> 
> ;;;SECTION 1.1.4
> 
> (define (square x) (* x x))
> 
> (square 21)
> (square (+ 2 5))
> (square (square 3))
> 
> 
> (define (sum-of-squares x y)
>     (+ (square x) (square y)))
> 
> (sum-of-squares 3 4)
> 
> (define (f a)
>     (sum-of-squares (+ a 1) (* a 2)))
> 
> (f 5)
> 
> 
> ;;;SECTION 1.1.5
> 
> (f 5)
> (sum-of-squares (+ 5 1) (* 5 2))
> (+ (square 6) (square 10))
> (+ (* 6 6) (* 10 10))
> (+ 36 100)
> 
> (f 5)
> (sum-of-squares (+ 5 1) (* 5 2))
> (+    (square (+ 5 1))      (square (* 5 2))  )
> (+    (* (+ 5 1) (+ 5 1))   (* (* 5 2) (* 5 2)))
> (+         (* 6 6)             (* 10 10))
> (+           36                   100)
> 136
> 
> ;;;SECTION 1.1.6
> 
> (define (abs x)
>     (cond
>         ((> x 0) x)
>         ((= x 0) 0)
>         ((< x 0) (- x))))
> 
> (define (abs x)
>   (cond ((< x 0) (- x))
>         (else x)))
> 
> (define (abs x)
>   (if (< x 0)
>       (- x)
>       x))
> 
> (define x 7)
> (and (> x 5) (< x 10))
> 
> (define (>= x y)
>   (or (> x y) (= x y)))
> 
> (define (>= x y)
>   (not (< x y)))
> 
> 
> ;;EXERCISE 1.1
> 10
> 
> (+ 5 3 4)
> 
> (- 9 1)
> 
> (/ 6 2)
> 
> (+ (* 2 4) (- 4 6))
> 
> (define a 3)
> 
> (define b (+ a 1))
> 
> (+ a b (* a b))
> 
> (= a b)
> 
> (if (and (> b a) (< b (* a b)))
>     b
>     a)
> 
> (cond ((= a 4) 6)
>     ((= b 4) (+ 6 7 a))
>     (else 25))
> 
> (+ 2 (if (> b a) b a))
> 
> (* (cond ((> a b) a)
>      ((< a b) b)
>      (else -1))
>     (+ a 1))
> 
> ;;EXERCISE 1.4
> (define (a-plus-abs-b a b)
>   ((if (> b 0) + -) a b))
> 
> ;;EXERCISE 1.5
> (define (p x) (if (< x 10000) (p (+ x 1)) x))
> 
> (define (test x y)
>   (if (= x 0)
>       0
>       y))
> 
> (if (= 0 0) 0 (p 0))
> ;:(test 0 (p 0))
> 
> ;;;SECTION 1.1.7
> 
> (define (sqrt-iter guess x)
>   (if (good-enough? guess x)
>       guess
>       (sqrt-iter (improve guess x)
>                  x)))
> 
> (define (improve guess x)
>   (average guess (/ x guess)))
> 
> (define (average x y)
>   (/ (+ x y) 2))
> 
> (define (good-enough? guess x)
>   (< (abs (- (square guess) x)) 0.001))
> 
> (define (sqrt x)
>   (sqrt-iter 1.0 x))
> 
> 
> (sqrt 9)
> (sqrt (+ 100 37))
> (sqrt (+ (sqrt 2) (sqrt 3)))
> (square (sqrt 1000))
> 
> 
> ;;EXERCISE 1.6
> (define (new-if predicate then-clause else-clause)
>   (cond (predicate then-clause)
>         (else else-clause)))
> 
> (new-if (= 2 3) 0 5)
> 
> (new-if (= 1 1) 0 5)
> 
> (define (sqrt-iter guess x)
>   (new-if (good-enough? guess x)
>           guess
>           (sqrt-iter (improve guess x)
>                      x)))
> 
> 
> ;;;SECTION 1.1.8
> 
> (define (square x) (* x x))
> 
> (define (square x) 
>   (exp (double (log x))))
> 
> (define (double x) (+ x x))
> 
> 
> ;; As in 1.1.7
> (define (sqrt x)
>   (sqrt-iter 1.0 x))
> 
> (define (sqrt-iter guess x)
>   (if (good-enough? guess x)
>       guess
>       (sqrt-iter (improve guess x) x)))
> 
> (define (good-enough? guess x)
>   (< (abs (- (square guess) x)) 0.001))
> 
> (define (improve guess x)
>   (average guess (/ x guess)))
> 
> 
> ;; Block-structured
> (define (sqrt x)
>   (define (good-enough? guess x)
>     (< (abs (- (square guess) x)) 0.001))
>   (define (improve guess x)
>     (average guess (/ x guess)))
>   (define (sqrt-iter guess x)
>     (if (good-enough? guess x)
>         guess
>         (sqrt-iter (improve guess x) x)))
>   (sqrt-iter 1.0 x))
> 
> ;; Taking advantage of lexical scoping
> (define (sqrt x)
>   (define (good-enough? guess)
>     (< (abs (- (square guess) x)) 0.001))
>   (define (improve guess)
>     (average guess (/ x guess)))
>   (define (sqrt-iter guess)
>     (if (good-enough? guess)
>         guess
>         (sqrt-iter (improve guess))))
>   (sqrt-iter 1.0))
> 
> 
> ;;;SECTION 1.2.1
> 
> ;; Recursive
> 
> (define (factorial n)
>   (if (= n 1)
>       1
>       (* n (factorial (- n 1)))))
> 
> 
> ;; Iterative
> 
> (define (factorial n)
>   (fact-iter 1 1 n))
> 
> (define (fact-iter product counter max-count)
>   (if (> counter max-count)
>       product
>       (fact-iter (* counter product)
>                  (+ counter 1)
>                  max-count)))
> 
> ;; Iterative, block-structured (from footnote)
> (define (factorial n)
>   (define (iter product counter)
>     (if (> counter n)
>         product
>         (iter (* counter product)
>               (+ counter 1))))
>   (iter 1 1))
> 
> ;;EXERCISE 1.9
> (define (+ a b)
>   (if (= a 0)
>       b
>       (inc (+ (dec a) b))))
> 
> (define (+ a b)
>   (if (= a 0)
>       b
>       (+ (dec a) (inc b))))
> 
> ;;EXERCISE 1.10
> (define (A x y)
>   (cond ((= y 0) 0)
>         ((= x 0) (* 2 y))
>         ((= y 1) 2)
>         (else (A (- x 1)
>                  (A x (- y 1))))))
> 
> (A 1 10)
> 
> (A 2 4)
> 
> (A 3 3)
> 
> (define (f n) (A 0 n))
> 
> (define (g n) (A 1 n))
> 
> (define (h n) (A 2 n))
> 
> (define (k n) (* 5 n n))
> 
> 
> ;;;SECTION 1.2.2
> 
> ;; Recursive
> 
> (define (fib n)
>   (cond ((= n 0) 0)
>         ((= n 1) 1)
>         (else (+ (fib (- n 1))
>                  (fib (- n 2))))))
> 
> ;; Iterative
> 
> (define (fib n)
>   (fib-iter 1 0 n))
> 
> (define (fib-iter a b count)
>   (if (= count 0)
>       b
>       (fib-iter (+ a b) a (- count 1))))
> 
> ;; Counting change
> 
> (define + original-+)
> 
> (define (count-change amount)
>   (cc amount 5))
> 
> (define (cc amount kinds-of-coins)
>   (inspect (list 'cc amount kinds-of-coins))
>   (inspect (stack-depth))
>   (cond ((= amount 0) 1)
>         ((or (< amount 0) (= kinds-of-coins 0)) 0)
>         (else (+ (cc amount
>                      (- kinds-of-coins 1))
>                  (cc (- amount
>                         (first-denomination kinds-of-coins))
>                      kinds-of-coins)))))
> 
> (define (first-denomination kinds-of-coins)
>   (cond ((= kinds-of-coins 1) 1)
>         ((= kinds-of-coins 2) 5)
>         ((= kinds-of-coins 3) 10)
>         ((= kinds-of-coins 4) 25)
>         ((= kinds-of-coins 5) 50)))
> 
> (count-change 10)
> 
> ;;;SECTION 1.2.3
> 
> ;;EXERCISE 1.15
> (define (cube x) (* x x x))
> 
> (define (p x) (- (* 3 x) (* 4 (cube x))))
> 
> (define (sine angle)
>    (if (not (> (abs angle) 0.1))
>        angle
>        (p (sine (/ angle 3.0)))))
> 
> 
> ;;;SECTION 1.2.4
> 
> ;; Linear recursion
> (define (expt b n)
>   (if (= n 0)
>       1
>       (* b (expt b (- n 1)))))
> 
> 
> ;; Linear iteration
> (define (expt b n)
>   (expt-iter b n 1))
> 
> (define (expt-iter b counter product)
>   (if (= counter 0)
>       product
>       (expt-iter b
>                 (- counter 1)
>                 (* b product)))) 
> 
> ;; Logarithmic iteration
> (define (fast-expt b n)
>   (cond ((= n 0) 1)
>         ((even? n) (square (fast-expt b (/ n 2))))
>         (else (* b (fast-expt b (- n 1))))))
> 
> (define (even? n)
>   (= (remainder n 2) 0))
> 
> 
> ;;EXERCISE 1.17
> (define (* a b)
>   (if (= b 0)
>       0
>       (+ a (* a (- b 1)))))
> 
> ;;EXERCISE 1.19
> (define (fib n)
>   (fib-iter 1 0 0 1 n))
> 
> (define (fib-iter a b p q count)
>   (cond ((= count 0) b)
>         ((even? count)
>          (fib-iter a
>                    b
>                    ??FILL-THIS-IN?? ; compute p'
>                    ??FILL-THIS-IN?? ; compute q'
>                    (/ count 2)))
>         (else (fib-iter (+ (* b q) (* a q) (* a p))
>                         (+ (* b p) (* a q))
>                         p
>                         q
>                         (- count 1)))))
> 
> 
> ;;;SECTION 1.2.5
> 
> (define (gcd a b)
>   (if (= b 0)
>       a
>       (gcd b (remainder a b))))
> 
> 
> ;;;SECTION 1.2.6
> 
> ;; prime?
> 
> (define (smallest-divisor n)
>   (find-divisor n 2))
> 
> (define (find-divisor n test-divisor)
>   (cond ((> (square test-divisor) n) n)
>         ((divides? test-divisor n) test-divisor)
>         (else (find-divisor n (+ test-divisor 1)))))
> 
> (define (divides? a b)
>   (= (remainder b a) 0))
> 
> (define (prime? n)
>   (= n (smallest-divisor n)))
> 
> 
> ;; fast-prime?
> 
> (define (expmod base exp m)
>   (cond ((= exp 0) 1)
>         ((even? exp)
>          (remainder (square (expmod base (/ exp 2) m))
>                     m))
>         (else
>          (remainder (* base (expmod base (- exp 1) m))
>                     m))))        
> 
> (define (fermat-test n)
>   (define (try-it a)
>     (= (expmod a n n) a))
>   (try-it (+ 1 (random (- n 1)))))
> 
> (define (fast-prime? n times)
>   (cond ((= times 0) true)
>         ((fermat-test n) (fast-prime? n (- times 1)))
>         (else false)))
> 
> 
> ;;EXERCISE 1.22
> (define (timed-prime-test n)
>   (newline)
>   (display n)
>   (start-prime-test n (runtime)))
> 
> (define (start-prime-test n start-time)
>   (if (prime? n)
>       (report-prime (- (runtime) start-time))))
> 
> (define (report-prime elapsed-time)
>   (display " *** ")
>   (display elapsed-time))
> 
> ;;EXERCISE 1.25
> (define (expmod base exp m)
>   (remainder (fast-expt base exp) m))
> 
> ;;EXERCISE 1.26
> (define (expmod base exp m)
>   (cond ((= exp 0) 1)
>         ((even? exp)
>          (remainder (* (expmod base (/ exp 2) m)
>                        (expmod base (/ exp 2) m))
>                     m))
>         (else
>          (remainder (* base (expmod base (- exp 1) m))
>                     m))))
> 
> ;;;SECTION 1.3
> 
> (define * original-*)
> (define (cube x) (* x x x))
> 
> ;;;SECTION 1.3.1
> 
> (define (sum-integers a b)
>   (if (> a b)
>       0
>       (+ a (sum-integers (+ a 1) b))))
> 
> (define (sum-cubes a b)
>   (if (> a b)
>       0
>       (+ (cube a) (sum-cubes (+ a 1) b))))
> 
> (define (pi-sum a b)
>   (if (> a b)
>       0
>       (+ (/ 1.0 (* a (+ a 2))) (pi-sum (+ a 4) b))))
> 
> (define (sum term a next b)
>   (if (> a b)
>       0
>       (+ (term a)
>          (sum term (next a) next b))))
> 
> 
> ;; Using sum
> 
> (define (inc n) (+ n 1))
> 
> (define (sum-cubes a b)
>   (sum cube a inc b))
> 
> (sum-cubes 1 10)
> 
> 
> (define (identity x) x)
> 
> (define (sum-integers a b)
>   (sum identity a inc b))
> 
> (sum-integers 1 10)
> 
> 
> (define (pi-sum a b)
>   (define (pi-term x)
>     (/ 1.0 (* x (+ x 2))))
>   (define (pi-next x)
>     (+ x 4))
>   (sum pi-term a pi-next b))
> 
> (* 8 (pi-sum 1 100))
> 
> 
> (define (integral f a b dx)
>   (define (add-dx x) (+ x dx))
>   (* (sum f (+ a (/ dx 2)) add-dx b)
>      dx))
> 
> (integral cube 0 1 0.01)
> 
> (integral cube 0 1 0.008)
> 
> 
> ;;EXERCISE 1.32
> ;:(accumulate combiner null-value term a next b)
> 
> ;;;SECTION 1.3.2
> 
> (define (pi-sum a b)
>   (sum (lambda (x) (/ 1.0 (* x (+ x 2))))
>        a
>        (lambda (x) (+ x 4))
>        b))
> 
> (define (integral f a b dx)
>   (* (sum f
>           (+ a (/ dx 2.0))
>           (lambda (x) (+ x dx))
>           b)
>      dx))
> 
> (define (plus4 x) (+ x 4))
> 
> (define plus4 (lambda (x) (+ x 4)))
> 
> ((lambda (x y z) (+ x y (square z))) 1 2 3)
> 
> (log 10)
> 
> ;; Using let
> 
> (define (f x y)
>   (define (f-helper a b)
>     (+ (* x (square a))
>        (* y b)
>        (* a b)))
>   (f-helper (+ 1 (* x y)) 
>             (- 1 y)))
> 
> (define (f x y)
>   ((lambda (a b)
>      (+ (* x (square a))
>         (* y b)
>         (* a b)))
>    (+ 1 (* x y))
>    (- 1 y)))
> 
> (define (f x y)
>   (let ((a (+ 1 (* x y)))
>         (b (- 1 y)))
>     (+ (* x (square a))
>        (* y b)
>        (* a b))))
> 
> (+ (let ((x 3))
>       (+ x (* x 10)))
>     x)
> 
> (let ((x 3)
>       (y (+ x 2)))
>   (* x y))
> 
> (define (f x y)
>   (define a (+ 1 (* x y)))
>   (define b (- 1 y))
>   (+ (* x (square a))
>      (* y b)
>      (* a b)))
> 
> 
> ;;EXERCISE 1.34
> (define (f g)
>   (g 2))
> 
> (f square)
> 
> (f (lambda (z) (* z (+ z 1))))
> 
> 
> ;;;SECTION 1.3.3
> 
> ;; Half-interval method
> 
> (define (search f neg-point pos-point)
>   (let ((midpoint (average neg-point pos-point)))
>     (if (close-enough? neg-point pos-point)
>         midpoint
>         (let ((test-value (f midpoint)))
>           (cond ((positive? test-value)
>                  (search f neg-point midpoint))
>                 ((negative? test-value)
>                  (search f midpoint pos-point))
>                 (else midpoint))))))
> 
> (define (close-enough? x y)
>   (< (abs (- x y)) 0.001))
> 
> (define (half-interval-method f a b)
>   (let ((a-value (f a))
>         (b-value (f b)))
>     (cond ((and (negative? a-value) (positive? b-value))
>            (search f a b))
>           ((and (negative? b-value) (positive? a-value))
>            (search f b a))
>           (else
>            (error "Values are not of opposite sign" a b)))))
> 
> 
> (half-interval-method sin 2.0 4.0)
> 
> (half-interval-method (lambda (x) (- (* x x x) (* 2 x) 3))
>                       1.0
>                       2.0)
> 
> 
> ;; Fixed points
> 
> (define tolerance 0.00001)
> 
> (define (fixed-point f first-guess)
>   (define (close-enough? v1 v2)
>     (< (abs (- v1 v2)) tolerance))
>   (define (try guess)
>     (let ((next (f guess)))
>       (if (close-enough? guess next)
>           next
>           (try next))))
>   (try first-guess))
> 
> 
> (sin .707)
> (cos .707)
> 
> (fixed-point cos 1.0)
> 
> (fixed-point (lambda (y) (+ (sin y) (cos y)))
>              1.0)
> 
> 
> (define (sqrt x)
>   (fixed-point (lambda (y) (/ x y))
>                1.0))
> 
> (define (sqrt x)
>   (fixed-point (lambda (y) (average y (/ x y)))
>                1.0))
> 
> 
> ;;EXERCISE 1.37
> ;:(cont-frac (lambda (i) 1.0)
> ;:           (lambda (i) 1.0)
> ;:           k)
> 
> 
> ;;;SECTION 1.3.4
> 
> (define (average-damp f)
>   (lambda (x) (average x (f x))))
> 
> ((average-damp square) 10)
> 
> (define (sqrt x)
>   (fixed-point (average-damp (lambda (y) (/ x y)))
>                1.0))
> 
> (define (cube-root x)
>   (fixed-point (average-damp (lambda (y) (/ x (square y))))
>                1.0))
> 
> 
> ;; Newton's method
> 
> (define (deriv g)
>   (lambda (x)
>     (/ (- (g (+ x dx)) (g x))
>        dx)))
> (define dx 0.00001)
> 
> 
> (define (cube x) (* x x x))
> 
> ((deriv cube) 5)
> 
> (define (newton-transform g)
>   (lambda (x)
>     (- x (/ (g x) ((deriv g) x)))))
> 
> (define (newtons-method g guess)
>   (fixed-point (newton-transform g) guess))
> 
> 
> (define (sqrt x)
>   (newtons-method (lambda (y) (- (square y) x))
>                   1.0))
> 
> 
> ;; Fixed point of transformed function
> 
> (define (fixed-point-of-transform g transform guess)
>   (fixed-point (transform g) guess))
> 
> (define (sqrt x)
>   (fixed-point-of-transform (lambda (y) (/ x y))
>                             average-damp
>                             1.0))
> 
> (define (sqrt x)
>   (fixed-point-of-transform (lambda (y) (- (square y) x))
>                             newton-transform
>                             1.0))
> 
> 
> ;;EXERCISE 1.40
> ;:(newtons-method (cubic a b c) 1)
> 
> 
> ;;EXERCISE 1.41
> ;:(((double (double double)) inc) 5)
> 
> 
> ;;EXERCISE 1.42
> ;:((compose square inc) 6)
> 
> 
> ;;EXERCISE 1.43
> ;:((repeated square 2) 5)
> 
> )) ;end of items
> 
> (define (process items #)
>     (define (iter items)
>         (cond
>             ((null? items) 'done)
>             (else
>                 (define result (eval (car items) #))
>                 (println (car items) " is " result)
>                 ;(inspect (stack-depth))
>                 (iter (cdr items))
>                 )
>             )
>         )
>     (iter items)
>     )
> 
> (process items)
> 
> ------------------------------------------
> 486 is 486
> (+ 137 349) is 486
> (- 1000 334) is 666
> (* 5 99) is 495
> (/ 10 5) is 2
> (+ 2.700000 10) is 12.700000
> (+ 21 35 12 7) is 75
> (- 21 35 12 7) is -33
> (- 21) is -21
> (* 25 4 12) is 1200
> (+ (* 3 5) (- 10 6)) is 19
> (+ (* 3 (+ (* 2 4) (+ 3 5))) (+ (- 10 7) 6)) is 57
> (+ (* 3 (+ (* 2 4) (+ 3 5))) (+ (- 10 7) 6)) is 57
> (define size 2) is 2
> size is 2
> (* 5 size) is 10
> (define pi 3.141590) is 3.141590
> (define radius 10) is 10
> (* pi (* radius radius)) is 314.159000
> (define circumference (* 2 pi radius)) is 62.831800
> circumference is 62.831800
> (* (+ 2 (* 4 6))) is 26
> (+ 3 5 7) is 15
> (define (square x) (* x x)) is <function square(x)>
> (square 21) is 441
> (square (+ 2 5)) is 49
> (square (square 3)) is 81
> (define (sum-of-squares x y) (+ (square x) (square y))) is <function sum-of-squares(x y)>
> (sum-of-squares 3 4) is 25
> (define (f a) (sum-of-squares (+ a 1) (* a 2))) is <function f(a)>
> (f 5) is 136
> (f 5) is 136
> (sum-of-squares (+ 5 1) (* 5 2)) is 136
> (+ (square 6) (square 10)) is 136
> (+ (* 6 6) (* 10 10)) is 136
> (+ 36 100) is 136
> (f 5) is 136
> (sum-of-squares (+ 5 1) (* 5 2)) is 136
> (+ (square (+ 5 1)) (square (* 5 2))) is 136
> (+ (* (+ 5 1) (+ 5 1)) (* (* 5 2) (* 5 2))) is 136
> (+ (* 6 6) (* 10 10)) is 136
> (+ 36 100) is 136
> 136 is 136
> (define (abs x) (cond ((> x 0) x) ((= x 0) 0) ((< x 0) (- x)))) is <function abs(x)>
> (define (abs x) (cond ((< x 0) (- x)) (else x))) is <function abs(x)>
> (define (abs x) (if (< x 0) (- x) x)) is <function abs(x)>
> (define x 7) is 7
> (and (> x 5) (< x 10)) is #t
> (define (>= x y) (or (> x y) (= x y))) is <function >=(x y)>
> (define (>= x y) (not (< x y))) is <function >=(x y)>
> 10 is 10
> (+ 5 3 4) is 12
> (- 9 1) is 8
> (/ 6 2) is 3
> (+ (* 2 4) (- 4 6)) is 6
> (define a 3) is 3
> (define b (+ a 1)) is 4
> (+ a b (* a b)) is 19
> (= a b) is #f
> (if (and (> b a) (< b (* a b))) b a) is 4
> (cond ((= a 4) 6) ((= b 4) (+ 6 7 a)) (else 25)) is 16
> (+ 2 (if (> b a) b a)) is 6
> (* (cond ((> a b) a) ((< a b) b) (else -1)) (+ a 1)) is 16
> (define (a-plus-abs-b a b) ((if (> b 0) + -) a b)) is <function a-plus-abs-b(a b)>
> (define (p x) (if (< x 10000) (p (+ x 1)) x)) is <function p(x)>
> (define (test x y) (if (= x 0) 0 y)) is <function test(x y)>
> (if (= 0 0) 0 (p 0)) is 0
> (define (sqrt-iter guess x) (if (good-enough? guess x) guess (sqrt-iter (improve guess x) x))) is <function sqrt-iter(guess x)>
> (define (improve guess x) (average guess (/ x guess))) is <function improve(guess x)>
> (define (average x y) (/ (+ x y) 2)) is <function average(x y)>
> (define (good-enough? guess x) (< (abs (- (square guess) x)) 0.001000)) is <function good-enough?(guess x)>
> (define (sqrt x) (sqrt-iter 1.000000 x)) is <function sqrt(x)>
> (sqrt 9) is 3.000092
> (sqrt (+ 100 37)) is 11.704700
> (sqrt (+ (sqrt 2) (sqrt 3))) is 1.773928
> (square (sqrt 1000)) is 1000.000370
> (define (new-if predicate then-clause else-clause) (cond (predicate then-clause) (else else-clause))) is <function new-if(predicate then-clause else-clause)>
> (new-if (= 2 3) 0 5) is 5
> (new-if (= 1 1) 0 5) is 0
> (define (sqrt-iter guess x) (new-if (good-enough? guess x) guess (sqrt-iter (improve guess x) x))) is <function sqrt-iter(guess x)>
> (define (square x) (* x x)) is <function square(x)>
> (define (square x) (exp (double (log x)))) is <function square(x)>
> (define (double x) (+ x x)) is <function double(x)>
> (define (sqrt x) (sqrt-iter 1.000000 x)) is <function sqrt(x)>
> (define (sqrt-iter guess x) (if (good-enough? guess x) guess (sqrt-iter (improve guess x) x))) is <function sqrt-iter(guess x)>
> (define (good-enough? guess x) (< (abs (- (square guess) x)) 0.001000)) is <function good-enough?(guess x)>
> (define (improve guess x) (average guess (/ x guess))) is <function improve(guess x)>
> (define (sqrt x) (define (good-enough? guess x) (< (abs (- (square guess) x)) 0.001000)) (define (improve guess x) (average guess (/ x guess))) (define (sqrt-iter guess x) (if (good-enough? guess x) guess (sqrt-iter (improve guess x) x))) (sqrt-iter 1.000000 x)) is <function sqrt(x)>
> (define (sqrt x) (define (good-enough? guess) (< (abs (- (square guess) x)) 0.001000)) (define (improve guess) (average guess (/ x guess))) (define (sqrt-iter guess) (if (good-enough? guess) guess (sqrt-iter (improve guess)))) (sqrt-iter 1.000000)) is <function sqrt(x)>
> (define (factorial n) (if (= n 1) 1 (* n (factorial (- n 1))))) is <function factorial(n)>
> (define (factorial n) (fact-iter 1 1 n)) is <function factorial(n)>
> (define (fact-iter product counter max-count) (if (> counter max-count) product (fact-iter (* counter product) (+ counter 1) max-count))) is <function fact-iter(product counter max-count)>
> (define (factorial n) (define (iter product counter) (if (> counter n) product (iter (* counter product) (+ counter 1)))) (iter 1 1)) is <function factorial(n)>
> (define (+ a b) (if (= a 0) b (inc (+ (dec a) b)))) is <function +(a b)>
> (define (+ a b) (if (= a 0) b (+ (dec a) (inc b)))) is <function +(a b)>
> (define (A x y) (cond ((= y 0) 0) ((= x 0) (* 2 y)) ((= y 1) 2) (else (A (- x 1) (A x (- y 1)))))) is <function A(x y)>
> (A 1 10) is 1024
> (A 2 4) is 65536
> (A 3 3) is 65536
> (define (f n) (A 0 n)) is <function f(n)>
> (define (g n) (A 1 n)) is <function g(n)>
> (define (h n) (A 2 n)) is <function h(n)>
> (define (k n) (* 5 n n)) is <function k(n)>
> (define (fib n) (cond ((= n 0) 0) ((= n 1) 1) (else (+ (fib (- n 1)) (fib (- n 2)))))) is <function fib(n)>
> (define (fib n) (fib-iter 1 0 n)) is <function fib(n)>
> (define (fib-iter a b count) (if (= count 0) b (fib-iter (+ a b) a (- count 1)))) is <function fib-iter(a b count)>
> (define + original-+) is <builtIn +(@)>
> (define (count-change amount) (cc amount 5)) is <function count-change(amount)>
> (define (cc amount kinds-of-coins) (inspect (list (quote cc) amount kinds-of-coins)) (inspect (stack-depth)) (cond ((= amount 0) 1) ((or (< amount 0) (= kinds-of-coins 0)) 0) (else (+ (cc amount (- kinds-of-coins 1)) (cc (- amount (first-denomination kinds-of-coins)) kinds-of-coins))))) is <function cc(amount kinds-of-coins)>
> (define (first-denomination kinds-of-coins) (cond ((= kinds-of-coins 1) 1) ((= kinds-of-coins 2) 5) ((= kinds-of-coins 3) 10) ((= kinds-of-coins 4) 25) ((= kinds-of-coins 5) 50))) is <function first-denomination(kinds-of-coins)>
> (list (quote cc) amount kinds-of-coins) is (cc 10 5)
> (stack-depth) is 18
> (list (quote cc) amount kinds-of-coins) is (cc 10 4)
> (stack-depth) is 23
> (list (quote cc) amount kinds-of-coins) is (cc 10 3)
> (stack-depth) is 28
> (list (quote cc) amount kinds-of-coins) is (cc 10 2)
> (stack-depth) is 33
> (list (quote cc) amount kinds-of-coins) is (cc 10 1)
> (stack-depth) is 38
> (list (quote cc) amount kinds-of-coins) is (cc 10 0)
> (stack-depth) is 43
> (list (quote cc) amount kinds-of-coins) is (cc 9 1)
> (stack-depth) is 44
> (list (quote cc) amount kinds-of-coins) is (cc 9 0)
> (stack-depth) is 49
> (list (quote cc) amount kinds-of-coins) is (cc 8 1)
> (stack-depth) is 50
> (list (quote cc) amount kinds-of-coins) is (cc 8 0)
> (stack-depth) is 55
> (list (quote cc) amount kinds-of-coins) is (cc 7 1)
> (stack-depth) is 56
> (list (quote cc) amount kinds-of-coins) is (cc 7 0)
> (stack-depth) is 61
> (list (quote cc) amount kinds-of-coins) is (cc 6 1)
> (stack-depth) is 62
> (list (quote cc) amount kinds-of-coins) is (cc 6 0)
> (stack-depth) is 67
> (list (quote cc) amount kinds-of-coins) is (cc 5 1)
> (stack-depth) is 68
> (list (quote cc) amount kinds-of-coins) is (cc 5 0)
> (stack-depth) is 73
> (list (quote cc) amount kinds-of-coins) is (cc 4 1)
> (stack-depth) is 74
> (list (quote cc) amount kinds-of-coins) is (cc 4 0)
> (stack-depth) is 79
> (list (quote cc) amount kinds-of-coins) is (cc 3 1)
> (stack-depth) is 80
> (list (quote cc) amount kinds-of-coins) is (cc 3 0)
> (stack-depth) is 85
> (list (quote cc) amount kinds-of-coins) is (cc 2 1)
> (stack-depth) is 86
> (list (quote cc) amount kinds-of-coins) is (cc 2 0)
> (stack-depth) is 91
> (list (quote cc) amount kinds-of-coins) is (cc 1 1)
> (stack-depth) is 92
> (list (quote cc) amount kinds-of-coins) is (cc 1 0)
> (stack-depth) is 97
> (list (quote cc) amount kinds-of-coins) is (cc 0 1)
> (stack-depth) is 98
> (list (quote cc) amount kinds-of-coins) is (cc 5 2)
> (stack-depth) is 39
> (list (quote cc) amount kinds-of-coins) is (cc 5 1)
> (stack-depth) is 44
> (list (quote cc) amount kinds-of-coins) is (cc 5 0)
> (stack-depth) is 49
> (list (quote cc) amount kinds-of-coins) is (cc 4 1)
> (stack-depth) is 50
> (list (quote cc) amount kinds-of-coins) is (cc 4 0)
> (stack-depth) is 55
> (list (quote cc) amount kinds-of-coins) is (cc 3 1)
> (stack-depth) is 56
> (list (quote cc) amount kinds-of-coins) is (cc 3 0)
> (stack-depth) is 61
> (list (quote cc) amount kinds-of-coins) is (cc 2 1)
> (stack-depth) is 62
> (list (quote cc) amount kinds-of-coins) is (cc 2 0)
> (stack-depth) is 67
> (list (quote cc) amount kinds-of-coins) is (cc 1 1)
> (stack-depth) is 68
> (list (quote cc) amount kinds-of-coins) is (cc 1 0)
> (stack-depth) is 73
> (list (quote cc) amount kinds-of-coins) is (cc 0 1)
> (stack-depth) is 74
> (list (quote cc) amount kinds-of-coins) is (cc 0 2)
> (stack-depth) is 45
> (list (quote cc) amount kinds-of-coins) is (cc 0 3)
> (stack-depth) is 34
> (list (quote cc) amount kinds-of-coins) is (cc -15 4)
> (stack-depth) is 29
> (list (quote cc) amount kinds-of-coins) is (cc -40 5)
> (stack-depth) is 24
> (count-change 10) is 4
> (define (cube x) (* x x x)) is <function cube(x)>
> (define (p x) (- (* 3 x) (* 4 (cube x)))) is <function p(x)>
> (define (sine angle) (if (not (> (abs angle) 0.100000)) angle (p (sine (/ angle 3.000000))))) is <function sine(angle)>
> (define (expt b n) (if (= n 0) 1 (* b (expt b (- n 1))))) is <function expt(b n)>
> (define (expt b n) (expt-iter b n 1)) is <function expt(b n)>
> (define (expt-iter b counter product) (if (= counter 0) product (expt-iter b (- counter 1) (* b product)))) is <function expt-iter(b counter product)>
> (define (fast-expt b n) (cond ((= n 0) 1) ((even? n) (square (fast-expt b (/ n 2)))) (else (* b (fast-expt b (- n 1)))))) is <function fast-expt(b n)>
> (define (even? n) (= (remainder n 2) 0)) is <function even?(n)>
> (define (* a b) (if (= b 0) 0 (+ a (* a (- b 1))))) is <function *(a b)>
> (define (fib n) (fib-iter 1 0 0 1 n)) is <function fib(n)>
> (define (fib-iter a b p q count) (cond ((= count 0) b) ((even? count) (fib-iter a b ??FILL-THIS-IN?? ??FILL-THIS-IN?? (/ count 2))) (else (fib-iter (+ (* b q) (* a q) (* a p)) (+ (* b p) (* a q)) p q (- count 1))))) is <function fib-iter(a b p q count)>
> (define (gcd a b) (if (= b 0) a (gcd b (remainder a b)))) is <function gcd(a b)>
> (define (smallest-divisor n) (find-divisor n 2)) is <function smallest-divisor(n)>
> (define (find-divisor n test-divisor) (cond ((> (square test-divisor) n) n) ((divides? test-divisor n) test-divisor) (else (find-divisor n (+ test-divisor 1))))) is <function find-divisor(n test-divisor)>
> (define (divides? a b) (= (remainder b a) 0)) is <function divides?(a b)>
> (define (prime? n) (= n (smallest-divisor n))) is <function prime?(n)>
> (define (expmod base exp m) (cond ((= exp 0) 1) ((even? exp) (remainder (square (expmod base (/ exp 2) m)) m)) (else (remainder (* base (expmod base (- exp 1) m)) m)))) is <function expmod(base exp m)>
> (define (fermat-test n) (define (try-it a) (= (expmod a n n) a)) (try-it (+ 1 (random (- n 1))))) is <function fermat-test(n)>
> (define (fast-prime? n times) (cond ((= times 0) true) ((fermat-test n) (fast-prime? n (- times 1))) (else false))) is <function fast-prime?(n times)>
> (define (timed-prime-test n) (newline) (display n) (start-prime-test n (runtime))) is <function timed-prime-test(n)>
> (define (start-prime-test n start-time) (if (prime? n) (report-prime (- (runtime) start-time)))) is <function start-prime-test(n start-time)>
> (define (report-prime elapsed-time) (display " *** ") (display elapsed-time)) is <function report-prime(elapsed-time)>
> (define (expmod base exp m) (remainder (fast-expt base exp) m)) is <function expmod(base exp m)>
> (define (expmod base exp m) (cond ((= exp 0) 1) ((even? exp) (remainder (* (expmod base (/ exp 2) m) (expmod base (/ exp 2) m)) m)) (else (remainder (* base (expmod base (- exp 1) m)) m)))) is <function expmod(base exp m)>
> (define * original-*) is <builtIn *(@)>
> (define (cube x) (* x x x)) is <function cube(x)>
> (define (sum-integers a b) (if (> a b) 0 (+ a (sum-integers (+ a 1) b)))) is <function sum-integers(a b)>
> (define (sum-cubes a b) (if (> a b) 0 (+ (cube a) (sum-cubes (+ a 1) b)))) is <function sum-cubes(a b)>
> (define (pi-sum a b) (if (> a b) 0 (+ (/ 1.000000 (* a (+ a 2))) (pi-sum (+ a 4) b)))) is <function pi-sum(a b)>
> (define (sum term a next b) (if (> a b) 0 (+ (term a) (sum term (next a) next b)))) is <function sum(term a next b)>
> (define (inc n) (+ n 1)) is <function inc(n)>
> (define (sum-cubes a b) (sum cube a inc b)) is <function sum-cubes(a b)>
> (sum-cubes 1 10) is 3025
> (define (identity x) x) is <function identity(x)>
> (define (sum-integers a b) (sum identity a inc b)) is <function sum-integers(a b)>
> (sum-integers 1 10) is 55
> (define (pi-sum a b) (define (pi-term x) (/ 1.000000 (* x (+ x 2)))) (define (pi-next x) (+ x 4)) (sum pi-term a pi-next b)) is <function pi-sum(a b)>
> (* 8 (pi-sum 1 100)) is 3.121595
> (define (integral f a b dx) (define (add-dx x) (+ x dx)) (* (sum f (+ a (/ dx 2)) add-dx b) dx)) is <function integral(f a b dx)>
> (integral cube 0 1 0.010000) is 0.249988
> (integral cube 0 1 0.008000) is 0.249992
> (define (pi-sum a b) (sum <lambda ()> a <lambda ()> b)) is <function pi-sum(a b)>
> (define (integral f a b dx) (* (sum f (+ a (/ dx 2.000000)) <lambda ()> b) dx)) is <function integral(f a b dx)>
> (define (plus4 x) (+ x 4)) is <function plus4(x)>
> (define plus4 <lambda ()>) is <function anonymous(x)>
> (<lambda (square z)> 1 2 3) is 12.000000
> (log 10) is 2.302585
> (define (f x y) (define (f-helper a b) (+ (* x (square a)) (* y b) (* a b))) (f-helper (+ 1 (* x y)) (- 1 y))) is <function f(x y)>
> (define (f x y) (<lambda (* a b)> (+ 1 (* x y)) (- 1 y))) is <function f(x y)>
> (define (f x y) (let ((a (+ 1 (* x y))) (b (- 1 y))) (+ (* x (square a)) (* y b) (* a b)))) is <function f(x y)>
> (+ (let ((x 3)) (+ x (* x 10))) x) is 40
> (let ((x 3) (y (+ x 2))) (* x y)) is 27
> (define (f x y) (define a (+ 1 (* x y))) (define b (- 1 y)) (+ (* x (square a)) (* y b) (* a b))) is <function f(x y)>
> (define (f g) (g 2)) is <function f(g)>
> (f square) is 4.000000
> (f <lambda ()>) is 6
> (define (search f neg-point pos-point) (let ((midpoint (average neg-point pos-point))) (if (close-enough? neg-point pos-point) midpoint (let ((test-value (f midpoint))) (cond ((positive? test-value) (search f neg-point midpoint)) ((negative? test-value) (search f midpoint pos-point)) (else midpoint)))))) is <function search(f neg-point pos-point)>
> (define (close-enough? x y) (< (abs (- x y)) 0.001000)) is <function close-enough?(x y)>
> (define (half-interval-method f a b) (let ((a-value (f a)) (b-value (f b))) (cond ((and (negative? a-value) (positive? b-value)) (search f a b)) ((and (negative? b-value) (positive? a-value)) (search f b a)) (else (error "Values are not of opposite sign" a b))))) is <function half-interval-method(f a b)>
> (half-interval-method sin 2.000000 4.000000) is 3.141113
> (half-interval-method <lambda (__label)> 1.000000 2.000000) is 1.893066
> (define tolerance 0.000010) is 0.000010
> (define (fixed-point f first-guess) (define (close-enough? v1 v2) (< (abs (- v1 v2)) tolerance)) (define (try guess) (let ((next (f guess))) (if (close-enough? guess next) next (try next)))) (try first-guess)) is <function fixed-point(f first-guess)>
> (sin 0.707000) is 0.649556
> (cos 0.707000) is 0.760314
> (fixed-point cos 1.000000) is 0.739082
> (fixed-point <lambda ()> 1.000000) is 1.258732
> (define (sqrt x) (fixed-point <lambda ()> 1.000000)) is <function sqrt(x)>
> (define (sqrt x) (fixed-point <lambda ()> 1.000000)) is <function sqrt(x)>
> (define (average-damp f) <lambda ()>) is <function average-damp(f)>
> ((average-damp square) 10) is 55.000000
> (define (sqrt x) (fixed-point (average-damp <lambda ()>) 1.000000)) is <function sqrt(x)>
> (define (cube-root x) (fixed-point (average-damp <lambda ()>) 1.000000)) is <function cube-root(x)>
> (define (deriv g) <lambda ()>) is <function deriv(g)>
> (define dx 0.000010) is 0.000010
> (define (cube x) (* x x x)) is <function cube(x)>
> ((deriv cube) 5) is 75.000150
> (define (newton-transform g) <lambda ()>) is <function newton-transform(g)>
> (define (newtons-method g guess) (fixed-point (newton-transform g) guess)) is <function newtons-method(g guess)>
> (define (sqrt x) (newtons-method <lambda ()> 1.000000)) is <function sqrt(x)>
> (define (fixed-point-of-transform g transform guess) (fixed-point (transform g) guess)) is <function fixed-point-of-transform(g transform guess)>
> (define (sqrt x) (fixed-point-of-transform <lambda ()> average-damp 1.000000)) is <function sqrt(x)>
> (define (sqrt x) (fixed-point-of-transform <lambda ()> newton-transform 1.000000)) is <function sqrt(x)>
------------------------------------------
sicp2.s
------------------------------------------
0a1,1924
> ;;;;CODE FROM CHAPTER 2 OF STRUCTURE AND INTERPRETATION OF COMPUTER PROGRAMS
> 
> ;;; Examples from the book are commented out with ;: so that they
> ;;;  are easy to find and so that they will be omitted if you evaluate a
> ;;;  chunk of the file (programs with intervening examples) in Scheme.
> 
> ;;; BEWARE: Although the whole file can be loaded into Scheme,
> ;;;  you won't want to do so.  For example, you generally do
> ;;;  not want to use the procedural representation of pairs
> ;;;  (cons, car, cdr as defined in section 2.1.3) instead of
> ;;;  Scheme's primitive pairs.
> 
> ;;; Some things require code from other chapters -- see ch2support.scm
> 
> (include "sicp2-support.s")
> 
> (define old-cons cons)
> (define old-car car)
> (define old-cdr cdr)
> 
> (define items '(
> 
> (define (linear-combination a b x y)
>   (+ (* a x) (* b y)))
> 
> (define (linear-combination a b x y)
>   (add (mul a x) (mul b y))) 
> 
> ;;;SECTION 2.1.1
> 
> (define (add-rat x y)
>   (make-rat (+ (* (numer x) (denom y))
>                (* (numer y) (denom x)))
>             (* (denom x) (denom y))))
> 
> (define (sub-rat x y)
>   (make-rat (- (* (numer x) (denom y))
>                (* (numer y) (denom x)))
>             (* (denom x) (denom y))))
> 
> (define (mul-rat x y)
>   (make-rat (* (numer x) (numer y))
>             (* (denom x) (denom y))))
> 
> (define (div-rat x y)
>   (make-rat (* (numer x) (denom y))
>             (* (denom x) (numer y))))
> 
> (define (equal-rat? x y)
>   (= (* (numer x) (denom y))
>      (* (numer y) (denom x))))
> 
> (define x (cons 1 2))
>  
> (car x)
> (cdr x)
> 
> (define x (cons 1 2))
> (define y (cons 3 4))
> (define z (cons x y))
> (car (car z))
> (car (cdr z))
> 
> (define (make-rat n d) (cons n d))
> 
> (define (numer x) (car x))
> 
> (define (denom x) (cdr x))
> 
> ;;footnote -- alternative definitions
> (define make-rat cons)
> (define numer car)
> (define denom cdr)
> 
> (define (print-rat x)
>   (newline)
>   (display (numer x))
>   (display "/")
>   (display (denom x))
>   'ok
>   )
> 
> 
> (define one-half (make-rat 1 2))
> 
> (print-rat one-half)
> 
> (define one-third (make-rat 1 3))
> 
> (print-rat (add-rat one-half one-third))
> (print-rat (mul-rat one-half one-third))
> (print-rat (add-rat one-third one-third))
> 
> 
> ;; reducing to lowest terms in constructor
> ;; (uses gcd from 1.2.5 -- see ch2support.scm)
> 
> (define (make-rat n d)
>   (let ((g (gcd n d)))
>     (cons (/ n g) (/ d g))))
> 
> 
> (print-rat (add-rat one-third one-third))
> 
> 
> ;;;SECTION 2.1.2
> 
> ;; reducing to lowest terms in selectors
> ;; (uses gcd from 1.2.5 -- see ch2support.scm)
> 
> (define (make-rat n d)
>   (cons n d))
> 
> (define (numer x)
>   (let ((g (gcd (car x) (cdr x))))
>     (/ (car x) g)))
> 
> (define (denom x)
>   (let ((g (gcd (car x) (cdr x))))
>     (/ (cdr x) g)))
> 
> ;; EXERCISE 2.2
> (define (print-point p)
>   (newline)
>   (display "(")
>   (display (x-point p))
>   (display ",")
>   (display (y-point p))
>   (display ")"))
> 
> 
> ;;;SECTION 2.1.3
> (define (cons x y)
>   (define (dispatch m)
>     (cond ((= m 0) x)
>           ((= m 1) y)
>           (else (error "Argument not 0 or 1 -- cons" m))))
>   dispatch)
> 
> (cons 1 2)
> z
> (define (car z) (z 0))
> 
> (define (cdr z) (z 1))
> 
> (car (cons 'head 'tail))
> (cdr (cons 'head 'tail))
> 
> 
> ;; EXERCISE 2.4
> 
> (define (cons x y)
>   (lambda (m) (m x y)))
> 
> (define (car z)
>   (z (lambda (p q) p)))
> 
> (car (cons 'head 'tail))
> 
> (set! 'car old-car)
> (set! 'cdr old-cdr)
> (set! 'cons old-cons)
> 
> ;; EXERCISE 2.6
> (define zero (lambda (f) (lambda (x) x)))
> 
> (define (add-1 n)
>   (lambda (f) (lambda (x) (f ((n f) x)))))
> 
> (define (inc x) (+ x 1))
> (define base 0)
> 
> (define one (add-1 zero))
> (define two (add-1 one))
> (define three (add-1 two))
> 
> ((zero inc) base)
> ((one inc) base)
> ((two inc) base)
> ((three inc) base)
> 
> ;;;SECTION 2.1.4
> 
> (define (add-interval x y)
>   (make-interval (+ (lower-bound x) (lower-bound y))
>                  (+ (upper-bound x) (upper-bound y))))
> 
> (define (mul-interval x y)
>   (let ((p1 (* (lower-bound x) (lower-bound y)))
>         (p2 (* (lower-bound x) (upper-bound y)))
>         (p3 (* (upper-bound x) (lower-bound y)))
>         (p4 (* (upper-bound x) (upper-bound y))))
>     (make-interval (min p1 p2 p3 p4)
>                    (max p1 p2 p3 p4))))
> 
> (define (div-interval x y)
>   (mul-interval x 
>                 (make-interval (/ 1.0 (upper-bound y))
>                                (/ 1.0 (lower-bound y)))))
> 
> ;; EXERCISE 2.7
> 
> (define (make-interval a b) (cons a b))
> 
> 
> ;;;SECTION 2.1.4 again
> 
> (define (make-center-width c w)
>   (make-interval (- c w) (+ c w)))
> 
> (define (center i)
>   (/ (+ (lower-bound i) (upper-bound i)) 2))
> 
> (define (width i)
>   (/ (- (upper-bound i) (lower-bound i)) 2))
> 
> ;; parallel resistors
> 
> (define (par1 r1 r2)
>   (div-interval (mul-interval r1 r2)
>                 (add-interval r1 r2)))
> 
> (define (par2 r1 r2)
>   (let ((one (make-interval 1 1))) 
>     (div-interval one
>                   (add-interval (div-interval one r1)
>                                 (div-interval one r2)))))
> ;;;SECTION 2.2.1
> 
> (cons 1
>       (cons 2
>             (cons 3
>                   (cons 4 nil))))
> 
> (define one-through-four (list 1 2 3 4))
> 
> one-through-four
> (car one-through-four)
> (cdr one-through-four)
> (car (cdr one-through-four))
> (cons 10 one-through-four)
> 
> 
> (define (list-ref items n)
>   (if (= n 0)
>       (car items)
>       (list-ref (cdr items) (- n 1))))
> 
> (define squares (list 1 4 9 16 25))
> 
> (list-ref squares 3)
> 
> (define (length items)
>   (if (null? items)
>       0
>       (+ 1 (length (cdr items)))))
> 
> (define odds (list 1 3 5 7))
> 
> (length odds)
> 
> (define (length items)
>   (define (length-iter a count)
>     (if (null? a)
>         count
>         (length-iter (cdr a) (+ 1 count))))
>   (length-iter items 0))
> 
> (length odds)
> (append squares odds)
> (append odds squares)
> 
> 
> (define (append list1 list2)
>   (if (null? list1)
>       list2
>       (cons (car list1) (append (cdr list1) list2))))
> 
> (append squares odds)
> (append odds squares)
> 
> 
> ;; EXERCISE 2.17
> (last-pair (list 23 72 149 34))
> 
> ;; EXERCISE 2.18
> (reverse (list 1 4 9 16 25))
> 
> 
> ;; EXERCISE 2.19
> (define us-coins (list 50 25 10 5 1))
> 
> (define uk-coins (list 100 50 20 10 5 2 1 0.5))
> 
> (define no-more? null?)
> (define except-first-denomination cdr)
> (define first-denomination car)
> 
> (define (cc amount coin-values)
>   (cond ((= amount 0) 1)
>         ((or (< amount 0) (no-more? coin-values)) 0)
>         (else
>          (+ (cc amount
>                 (except-first-denomination coin-values))
>             (cc (- amount
>                    (first-denomination coin-values))
>                 coin-values)))))
> 
> ;:(cc 100 us-coins)
> 
> ;; EXERCISE 2.20
> ;: (same-parity 1 2 3 4 5 6 7)
> ;: (same-parity 2 3 4 5 6 7)
> 
> 
> ;; Mapping over lists
> 
> (define (scale-list items factor)
>   (if (null? items)
>       nil
>       (cons (* (car items) factor)
>             (scale-list (cdr items) factor))))
> 
> (scale-list (list 1 2 3 4 5) 10)
> 
> (map (lambda (x) (* x x)) (list 1 2 3 4 5 6))
> (apply + (list 1 2 3))
> (map + (list 1 2 3) (list 40 50 60) (list 700 800 900))
> 
> (map (lambda (x y) (+ x (* 2 y)))
>       (list 1 2 3)
>       (list 4 5 6))
> 
> (define (map proc items)
>   (if (null? items)
>       nil
>       (cons (proc (car items))
>             (map proc (cdr items)))))
> 
> (map abs (list -10 2.5 -11.6 17))
> 
> (map (lambda (x) (* x x))
>      (list 1 2 3 4))
> 
> (define (scale-list items factor)
>   (map (lambda (x) (* x factor))
>        items))
> 
> 
> ;; EXERCISE 2.21
> ;; EXERCISE 2.22
> (define (square-list items)
>   (define (iter things answer)
>     (if (null? things)
>         answer
>         (iter (cdr things) 
>               (cons (square (car things))
>                     answer))))
>   (iter items nil))
> 
> (square-list (list 1 2 3 4))
> 
> (define (square-list items)
>   (define (iter things answer)
>     (if (null? things)
>         answer
>         (iter (cdr things)
>               (cons answer
>                     (square (car things))))))
>   (iter items nil))
> 
> (square-list (list 1 2 3 4))
> 
> ;; EXERCISE 2.23
> 
> (for-each (lambda (x) (newline) (display x))
>           (list 57 321 88))
> 
> 
> 
> ;;;SECTION 2.2.2
> (cons (list 1 2) (list 3 4))
> 
> (define (count-leaves x)
>   (cond ((null? x) 0)
>         ((not (pair? x)) 1)
>         (else (+ (count-leaves (car x))
>                  (count-leaves (cdr x))))))
> 
> (define x (cons (list 1 2) (list 3 4)))
> (length x)
> (count-leaves x)
> 
> (list x x)
> (length (list x x))
> (count-leaves (list x x))
> 
> ;; EXERCISE 2.24
> (list 1 (list 2 (list 3 4)))
> 
> ;; EXERCISE 2.25
> '(1 3 (5 7) 9)
> '((7))
> '(1 (2 (3 (4 (5 (6 7))))))
> 
> ;; EXERCISE 2.26
> (define x (list 1 2 3))
> (define y (list 4 5 6))
> 
> (append x y)
> (cons x y)
> (list x y)
> 
> 
> ;; EXERCISE 2.27
> 
> (define x (list (list 1 2) (list 3 4)))
> x
> (reverse x)
> '(deep-reverse x)
> 
> 
> ;; EXERCISE 2.28
> 
> (define x (list (list 1 2) (list 3 4)))
> '(fringe x)
> '(fringe (list x x))
> 
> 
> ;; EXERCISE 2.29
> (define (make-mobile left right)
>   (list left right))
> 
> (define (make-branch length structure)
>   (list length structure))
> 
> 
> ;; part d
> (define (make-mobile left right)
>   (cons left right))
> 
> (define (make-branch length structure)
>   (cons length structure))
> 
> 
> ;; Mapping over trees
> 
> (define (scale-tree tree factor)
>   (cond ((null? tree) nil)
>         ((not (pair? tree)) (* tree factor))
>         (else (cons (scale-tree (car tree) factor)
>                     (scale-tree (cdr tree) factor)))))
> 
> 
> (scale-tree (list 1 (list 2 (list 3 4) 5) (list 6 7))
>             10)
> 
> 
> (define (scale-tree tree factor)
>   (map (lambda (sub-tree)
>          (if (pair? sub-tree)
>              (scale-tree sub-tree factor)
>              (* sub-tree factor)))
>        tree))
> 
> (scale-tree (list 1 (list 2 (list 3 4) 5) (list 6 7))
>             10)
> 
> 
> ;; EXERCISE 2.30
> ;: (square-tree
> ;:  (list 1
> ;:        (list 2 (list 3 4) 5)
> ;:        (list 6 7)))
> 
> 
> ;; EXERCISE 2.31
> (define (square-tree tree) (tree-map square tree))
> 
> 
> ;; EXERCISE 2.32
> (define (subsets s)
>   (if (null? s)
>       (list nil)
>       (let ((rest (subsets (cdr s))))
>         (append rest (map ??FILL-THIS-IN?? rest)))))
> 
> 
> ;;;SECTION 2.2.3
> 
> (define (sum-odd-squares tree)
>   (cond ((null? tree) 0)
>         ((not (pair? tree))
>          (if (odd? tree) (square tree) 0))
>         (else (+ (sum-odd-squares (car tree))
>                  (sum-odd-squares (cdr tree))))))
> 
> (define (even-fibs n)
>   (define (next k)
>     (if (> k n)
>         nil
>         (let ((f (fib k)))
>           (if (even? f)
>               (cons f (next (+ k 1)))
>               (next (+ k 1))))))
>   (next 0))
> 
> 
> ;; Sequence operations
> 
> (map square (list 1 2 3 4 5))
> 
> (define (filter predicate sequence)
>   (cond ((null? sequence) nil)
>         ((predicate (car sequence))
>          (cons (car sequence)
>                (filter predicate (cdr sequence))))
>         (else (filter predicate (cdr sequence)))))
> 
> ;: (filter odd? (list 1 2 3 4 5))
> 
> (define (accumulate op initial sequence)
>   (if (null? sequence)
>       initial
>       (op (car sequence)
>           (accumulate op initial (cdr sequence)))))
> 
> (accumulate + 0 (list 1 2 3 4 5))
> (accumulate * 1 (list 1 2 3 4 5))
> (accumulate cons nil (list 1 2 3 4 5))
> 
> (define (enumerate-interval low high)
>   (if (> low high)
>       nil
>       (cons low (enumerate-interval (+ low 1) high))))
> 
> (enumerate-interval 2 7)
> 
> (define (enumerate-tree tree)
>   (cond ((null? tree) nil)
>         ((not (pair? tree)) (list tree))
>         (else (append (enumerate-tree (car tree))
>                       (enumerate-tree (cdr tree))))))
> 
> (enumerate-tree (list 1 (list 2 (list 3 4)) 5))
> 
> (define (sum-odd-squares tree)
>   (accumulate +
>               0
>               (map square
>                    (filter odd?
>                            (enumerate-tree tree)))))
> 
> (define (even-fibs n)
>   (accumulate cons
>               nil
>               (filter even?
>                       (map fib
>                            (enumerate-interval 0 n)))))
> 
> (define (list-fib-squares n)
>   (accumulate cons
>               nil
>               (map square
>                    (map fib
>                         (enumerate-interval 0 n)))))
> 
> (list-fib-squares 10)
> 
> 
> (define (product-of-squares-of-odd-elements sequence)
>   (accumulate *
>               1
>               (map square
>                    (filter odd? sequence))))
> 
> (product-of-squares-of-odd-elements (list 1 2 3 4 5))
> 
> (define (salary-of-highest-paid-programmer records)
>   (accumulate max
>               0
>               (map salary
>                    (filter programmer? records))))
> 
> 
> ;; EXERCISE 2.34
> (define (horner-eval x coefficient-sequence)
>   (accumulate (lambda (this-coeff higher-terms) ??FILL-THIS-IN??)
>               0
>               coefficient-sequence))
> 
> '(horner-eval 2 (list 1 3 0 5 0 1))
> 
> ;; EXERCISE 2.36
> (define (accumulate-n op init seqs)
>   (if (null? (car seqs))
>       nil
>       (cons (accumulate op init ??FILL-THIS-IN??)
>             (accumulate-n op init ??FILL-THIS-IN??))))
> 
> '(accumulate-n + 0 s)
> 
> ;; EXERCISE 2.37
> 
> (define (dot-product v w)
>   (accumulate + 0 (map * v w)))
> 
> 
> ;; EXERCISE 2.38
> 
> (define (fold-left op initial sequence)
>   (define (iter result rest)
>     (if (null? rest)
>         result
>         (iter (op result (car rest))
>               (cdr rest))))
>   (iter initial sequence))
> 
> '(fold-right / 1 (list 1 2 3))
> (fold-left / 1.0 (list 1 2 3))
> '(fold-right list nil (list 1 2 3))
> (fold-left list nil (list 1 2 3))
> 
> 
> ;;Nested mappings
> 
> (define n 5)
> 
> (accumulate append
>             nil
>             (map (lambda (i)
>                    (map (lambda (j) (list i j))
>                         (enumerate-interval 1 (- i 1))))
>                  (enumerate-interval 1 n)))
> 
> (define (flatmap proc seq)
>   (accumulate append nil (map proc seq)))
> 
> (define (prime-sum? pair)
>   (prime? (+ (car pair) (cadr pair))))
> 
> (define (make-pair-sum pair)
>   (list (car pair) (cadr pair) (+ (car pair) (cadr pair))))
> 
> (define (prime-sum-pairs n)
>   (map make-pair-sum
>        (filter prime-sum?
>                (flatmap
>                 (lambda (i)
>                   (map (lambda (j) (list i j))
>                        (enumerate-interval 1 (- i 1))))
>                 (enumerate-interval 1 n)))))
> 
> 
> (define (permutations s)
>   (if (null? s)                         ; empty set?
>       (list nil)                        ; sequence containing empty set
>       (flatmap (lambda (x)
>                  (map (lambda (p) (cons x p))
>                       (permutations (remove x s))))
>                s)))
> 
> (define (remove item sequence)
>   (filter (lambda (x) (not (= x item)))
>           sequence))
> 
> 
> ;; EXERCISE 2.42
> (define (queens board-size)
>   (define (queen-cols k)
>     (if (= k 0)
>         (list empty-board)
>         (filter
>          (lambda (positions) (safe? k positions))
>          (flatmap
>           (lambda (rest-of-queens)
>             (map (lambda (new-row)
>                    (adjoin-position new-row k rest-of-queens))
>                  (enumerate-interval 1 board-size)))
>           (queen-cols (- k 1))))))
>   (queen-cols board-size))
> 
> ;; EXERCISE 2.43
> ;; Louis's version of queens
> (define (queens board-size)
>   (define (queen-cols k)  
>     (if (= k 0)
>         (list empty-board)
>         (filter
>          (lambda (positions) (safe? k positions))
>          ;; next expression changed
>          (flatmap
>           (lambda (new-row)
>             (map (lambda (rest-of-queens)
>                    (adjoin-position new-row k rest-of-queens))
>                  (queen-cols (- k 1))))
>           (enumerate-interval 1 board-size)))))
>   (queen-cols board-size))
> 
> ;;;SECTION 2.2.4
> 
> '(define wave2 (beside wave (flip-vert wave)))
> '(define wave4 (below wave2 wave2))
> 
> (define (flipped-pairs painter)
>   (let ((painter2 (beside painter (flip-vert painter))))
>     (below painter2 painter2)))
> 
> 
> '(define wave4 (flipped-pairs wave))
> 
> 
> (define (right-split painter n)
>   (if (= n 0)
>       painter
>       (let ((smaller (right-split painter (- n 1))))
>         (beside painter (below smaller smaller)))))
> 
> 
> (define (corner-split painter n)
>   (if (= n 0)
>       painter
>       (let ((up (up-split painter (- n 1)))
>             (right (right-split painter (- n 1))))
>         (let ((top-left (beside up up))
>               (bottom-right (below right right))
>               (corner (corner-split painter (- n 1))))
>           (beside (below painter top-left)
>                   (below bottom-right corner))))))
> 
> 
> (define (square-limit painter n)
>   (let ((quarter (corner-split painter n)))
>     (let ((half (beside (flip-horiz quarter) quarter)))
>       (below (flip-vert half) half))))
> 
> 
> ;; Higher-order operations
> 
> (define (square-of-four tl tr bl br)
>   (lambda (painter)
>     (let ((top (beside (tl painter) (tr painter)))
>           (bottom (beside (bl painter) (br painter))))
>       (below bottom top))))
> 
> 
> (define (flipped-pairs painter)
>   (let ((combine4 (square-of-four identity flip-vert
>                                   identity flip-vert)))
>     (combine4 painter)))
> 
> ; footnote
> '(define flipped-pairs
>   (square-of-four identity flip-vert identity flip-vert))
> 
> 
> (define (square-limit painter n)
>   (let ((combine4 (square-of-four flip-horiz identity
>                                   rotate180 flip-vert)))
>     (combine4 (corner-split painter n))))
> 
> 
> ;; EXERCISE 2.45
> 
> '(define right-split (split beside below))
> '(define up-split (split below beside))
> 
> 
> ;; Frames
> 
> (define (frame-coord-map frame)
>   (lambda (v)
>     (add-vect
>      (origin-frame frame)
>      (add-vect (scale-vect (xcor-vect v)
>                            (edge1-frame frame))
>                (scale-vect (ycor-vect v)
>                            (edge2-frame frame))))))
> 
> 
> '((frame-coord-map a-frame) (make-vect 0 0))
> 
> '(origin-frame a-frame)
> 
> 
> ;; EXERCISE 2.47
> 
> (define (make-frame origin edge1 edge2)
>   (list origin edge1 edge2))
> 
> (define (make-frame origin edge1 edge2)
>   (cons origin (cons edge1 edge2)))
> 
> 
> ;; Painters
> 
> (define (segments->painter segment-list)
>   (lambda (frame)
>     (for-each
>      (lambda (segment)
>        (draw-line
>         ((frame-coord-map frame) (start-segment segment))
>         ((frame-coord-map frame) (end-segment segment))))
>      segment-list)))
> 
> 
> (define (transform-painter painter origin corner1 corner2)
>   (lambda (frame)
>     (let ((m (frame-coord-map frame)))
>       (let ((new-origin (m origin)))
>         (painter
>          (make-frame new-origin
>                      (sub-vect (m corner1) new-origin)
>                      (sub-vect (m corner2) new-origin)))))))
> 
> 
> (define (flip-vert painter)
>   (transform-painter painter
>                      (make-vect 0.0 1.0)    ; new origin
>                      (make-vect 1.0 1.0)    ; new end of edge1
>                      (make-vect 0.0 0.0)))  ; new end of edge2
> 
> 
> (define (shrink-to-upper-right painter)
>   (transform-painter painter
>                      (make-vect 0.5 0.5)
>                      (make-vect 1.0 0.5)
>                      (make-vect 0.5 1.0)))
> 
> 
> (define (rotate90 painter)
>   (transform-painter painter
>                      (make-vect 1.0 0.0)
>                      (make-vect 1.0 1.0)
>                      (make-vect 0.0 0.0)))
> 
> 
> (define (squash-inwards painter)
>   (transform-painter painter
>                      (make-vect 0.0 0.0)
>                      (make-vect 0.65 0.35)
>                      (make-vect 0.35 0.65)))
> 
> 
> (define (beside painter1 painter2)
>   (let ((split-point (make-vect 0.5 0.0)))
>     (let ((paint-left
>            (transform-painter painter1
>                               (make-vect 0.0 0.0)
>                               split-point
>                               (make-vect 0.0 1.0)))
>           (paint-right
>            (transform-painter painter2
>                               split-point
>                               (make-vect 1.0 0.0)
>                               (make-vect 0.5 1.0))))
>       (lambda (frame)
>         (paint-left frame)
>         (paint-right frame)))))
> ;;;SECTION 2.3.1
> 
> '(a b c d)
> '(23 45 17)
> '((Norah 12) (Molly 9) (Anna 7) (Lauren 6) (Charlotte 3))
> 
> (define x 3)
> (* (+ 23 45) (+ x 9))
> 
> (define (fact n) (if (= n 1) 1 (* n (fact (- n 1)))))
> 
> 
> (define a 1)
> (define b 2)
> (list a b)
> (list 'a 'b)
> (list 'a b)
> 
> (car '(a b c))
> (cdr '(a b c))
> 
> 
> (define false #f)
> (define (memq item x)
>   (cond ((null? x) false)
>         ((eq? item (car x)) x)
>         (else (memq item (cdr x)))))
> 
> (memq 'apple '(pear banana prune))
> (memq 'apple '(x (apple sauce) y apple pear))
> 
> 
> ;; EXERCISE 2.53
> (list 'a 'b 'c)
> 
> (list (list 'george))
> 
> (cdr '((x1 x2) (y1 y2)))
> 
> (cadr '((x1 x2) (y1 y2)))
> 
> (pair? (car '(a short list)))
> 
> (memq 'red '((red shoes) (blue socks)))
> 
> (memq 'red '(red shoes blue socks))
> 
> 
> ;; EXERCISE 2.54
> (equal? '(this is a list) '(this is a list))
> (equal? '(this is a list) '(this (is a) list))
> (equal? '(this (is a) list) '(this (is a) list))
> 
> ;; EXERCISE 2.55
> (car ''abracadabra)
> 
> 
> ;;;SECTION 2.3.2
> 
> (define (deriv exp var)
>   (cond ((number? exp) 0)
>         ((variable? exp)
>          (if (same-variable? exp var) 1 0))
>         ((sum? exp)
>          (make-sum (deriv (addend exp) var)
>                    (deriv (augend exp) var)))
>         ((product? exp)
>          (make-sum
>            (make-product (multiplier exp)
>                          (deriv (multiplicand exp) var))
>            (make-product (deriv (multiplier exp) var)
>                          (multiplicand exp))))
>         (else
>          (error "unknown expression type -- DERIV" exp))))
> 
> ;; representing algebraic expressions
> 
> (define (variable? x) (symbol? x))
> 
> (define (same-variable? v1 v2)
>   (and (variable? v1) (variable? v2) (eq? v1 v2)))
> 
> (define (make-sum a1 a2) (list '+ a1 a2))
> 
> (define (make-product m1 m2) (list '* m1 m2))
> 
> (define (sum? x)
>   (and (pair? x) (eq? (car x) '+)))
> 
> (define (addend s) (cadr s))
> 
> (define (augend s) (caddr s))
> 
> (define (product? x)
>   (and (pair? x) (eq? (car x) '*)))
> 
> (define (multiplier p) (cadr p))
> 
> (define (multiplicand p) (caddr p))
> 
> (type 3)
> (type 3.3)
> (type "3.3")
> (type '(3))
> (type '3)
> (type 'three)
> (list? (cons 2 3))
> (list? (list 2 3))
> (pair? (cons 2 3))
> (pair? (list 2 3))
> 
> (deriv '(+ x 3) 'x)
> (deriv '(* x y) 'x)
> (deriv '(* (* x y) (+ x 3)) 'x)
> 
> 
> ;; With simplification
> 
> (define (make-sum a1 a2)
>   (cond ((=number? a1 0) a2)
>         ((=number? a2 0) a1)
>         ((and (number? a1) (number? a2)) (+ a1 a2))
>         (else (list '+ a1 a2))))
> 
> (define (=number? exp num)
>   (and (number? exp) (= exp num)))
> 
> (define (make-product m1 m2)
>   (cond ((or (=number? m1 0) (=number? m2 0)) 0)
>         ((=number? m1 1) m2)
>         ((=number? m2 1) m1)
>         ((and (number? m1) (number? m2)) (* m1 m2))
>         (else (list '* m1 m2))))
> 
> 
> (deriv '(+ x 3) 'x)
> (deriv '(* x y) 'x)
> (deriv '(* (* x y) (+ x 3)) 'x)
> 
> 
> ;; EXERCISE 2.57
> (deriv '(* x y (+ x 3)) 'x)
> 
> 
> ;;;SECTION 2.3.3
> 
> ;; UNORDERED
> 
> (define (element-of-set? x set)
>   (cond ((null? set) false)
>         ((equal? x (car set)) true)
>         (else (element-of-set? x (cdr set)))))
> 
> (define (adjoin-set x set)
>   (if (element-of-set? x set)
>       set
>       (cons x set)))
> 
> (define (intersection-set set1 set2)
>   (cond ((or (null? set1) (null? set2)) '())
>         ((element-of-set? (car set1) set2)
>          (cons (car set1)
>                (intersection-set (cdr set1) set2)))
>         (else (intersection-set (cdr set1) set2))))
> 
> 
> ;; ORDERED
> 
> (define (element-of-set? x set)
>   (cond ((null? set) false)
>         ((= x (car set)) true)
>         ((< x (car set)) false)
>         (else (element-of-set? x (cdr set)))))
> 
> (define (intersection-set set1 set2)
>   (if (or (null? set1) (null? set2))
>       '()
>       (let ((x1 (car set1)) (x2 (car set2)))
>         (cond ((= x1 x2)
>                (cons x1
>                      (intersection-set (cdr set1)
>                                        (cdr set2))))
>               ((< x1 x2)
>                (intersection-set (cdr set1) set2))
>               ((< x2 x1)
>                (intersection-set set1 (cdr set2)))))))
> 
> ;; BINARY TREES
> (define (entry tree) (car tree))
> 
> (define (left-branch tree) (cadr tree))
> 
> (define (right-branch tree) (caddr tree))
> 
> (define (make-tree entry left right)
>   (list entry left right))
> 
> (define (element-of-set? x set)
>   (cond ((null? set) false)
>         ((= x (entry set)) true)
>         ((< x (entry set))
>          (element-of-set? x (left-branch set)))
>         ((> x (entry set))
>          (element-of-set? x (right-branch set)))))
> 
> (define (adjoin-set x set)
>   (cond ((null? set) (make-tree x '() '()))
>         ((= x (entry set)) set)
>         ((< x (entry set))
>          (make-tree (entry set) 
>                     (adjoin-set x (left-branch set))
>                     (right-branch set)))
>         ((> x (entry set))
>          (make-tree (entry set)
>                     (left-branch set)
>                     (adjoin-set x (right-branch set))))))
> 
> 
> ;; EXERCISE 2.63
> (define (tree->list-1 tree)
>   (if (null? tree)
>       '()
>       (append (tree->list-1 (left-branch tree))
>               (cons (entry tree)
>                     (tree->list-1 (right-branch tree))))))
> 
> (define (tree->list-2 tree)
>   (define (copy-to-list tree result-list)
>     (if (null? tree)
>         result-list
>         (copy-to-list (left-branch tree)
>                       (cons (entry tree)
>                             (copy-to-list (right-branch tree)
>                                           result-list)))))
>   (copy-to-list tree '()))
> 
> 
> ;; EXERCISE 2.64
> 
> (define (list->tree elements)
>   (car (partial-tree elements (length elements))))
> 
> (define (partial-tree elts n)
>   (if (= n 0)
>       (cons '() elts)
>       (let ((left-size (quotient (- n 1) 2)))
>         (let ((left-result (partial-tree elts left-size)))
>           (let ((left-tree (car left-result))
>                 (non-left-elts (cdr left-result))
>                 (right-size (- n (+ left-size 1))))
>             (let ((this-entry (car non-left-elts))
>                   (right-result (partial-tree (cdr non-left-elts)
>                                               right-size)))
>               (let ((right-tree (car right-result))
>                     (remaining-elts (cdr right-result)))
>                 (cons (make-tree this-entry left-tree right-tree)
>                       remaining-elts))))))))
> 
> ;; INFORMATION RETRIEVAL
> 
> (define (lookup given-key set-of-records)
>   (cond ((null? set-of-records) false)
>         ((equal? given-key (key (car set-of-records)))
>          (car set-of-records))
>         (else (lookup given-key (cdr set-of-records)))))
> 
> 
> ;;;SECTION 2.3.3
> 
> ;; representing
> 
> (define (make-leaf symbol weight)
>   (list 'leaf symbol weight))
> 
> (define (leaf? object)
>   (eq? (car object) 'leaf))
> 
> (define (symbol-leaf x) (cadr x))
> 
> (define (weight-leaf x) (caddr x))
> 
> (define (make-code-tree left right)
>   (list left
>         right
>         (append (symbols left) (symbols right))
>         (+ (weight left) (weight right))))
> 
> (define (left-branch tree) (car tree))
> 
> (define (right-branch tree) (cadr tree))
> 
> (define (symbols tree)
>   (if (leaf? tree)
>       (list (symbol-leaf tree))
>       (caddr tree)))
> 
> (define (weight tree)
>   (if (leaf? tree)
>       (weight-leaf tree)
>       (cadddr tree)))
> 
> ;; decoding
> (define (decode bits tree)
>   (define (decode-1 bits current-branch)
>     (if (null? bits)
>         '()
>         (let ((next-branch
>                (choose-branch (car bits) current-branch)))
>           (if (leaf? next-branch)
>               (cons (symbol-leaf next-branch)
>                     (decode-1 (cdr bits) tree))
>               (decode-1 (cdr bits) next-branch)))))
>   (decode-1 bits tree))
> 
> (define (choose-branch bit branch)
>   (cond ((= bit 0) (left-branch branch))
>         ((= bit 1) (right-branch branch))
>         (else (error "bad bit -- CHOOSE-BRANCH" bit))))
> 
> ;; sets
> 
> (define (adjoin-set x set)
>   (cond ((null? set) (list x))
>         ((< (weight x) (weight (car set))) (cons x set))
>         (else (cons (car set)
>                     (adjoin-set x (cdr set))))))
> 
> (define (make-leaf-set pairs)
>   (if (null? pairs)
>       '()
>       (let ((pair (car pairs)))
>         (adjoin-set (make-leaf (car pair)
>                                (cadr pair))
>                     (make-leaf-set (cdr pairs))))))
> 
> 
> ;; EXERCISE 2.67
> 
> (define sample-tree
>   (make-code-tree (make-leaf 'A 4)
>                   (make-code-tree
>                    (make-leaf 'B 2)
>                    (make-code-tree (make-leaf 'D 1)
>                                    (make-leaf 'C 1)))))
> 
> (define sample-message '(0 1 1 0 0 1 0 1 0 1 1 1 0))
> 
> 
> ;; EXERCISE 2.68
> 
> (define (encode message tree)
>   (if (null? message)
>       '()
>       (append (encode-symbol (car message) tree)
>               (encode (cdr message) tree))))
> 
> ;; EXERCISE 2.69
> 
> (define (generate-huffman-tree pairs)
>   (successive-merge (make-leaf-set pairs)))
> 
> ;;;SECTION 2.4.1
> 
> 
> (define (add-complex z1 z2)
>   (make-from-real-imag (+ (real-part z1) (real-part z2))
>                        (+ (imag-part z1) (imag-part z2))))
> 
> (define (sub-complex z1 z2)
>   (make-from-real-imag (- (real-part z1) (real-part z2))
>                        (- (imag-part z1) (imag-part z2))))
> 
> (define (mul-complex z1 z2)
>   (make-from-mag-ang (* (magnitude z1) (magnitude z2))
>                      (+ (angle z1) (angle z2))))
> 
> (define (div-complex z1 z2)
>   (make-from-mag-ang (/ (magnitude z1) (magnitude z2))
>                      (- (angle z1) (angle z2))))
> 
> 
> ;; Ben (rectangular)
> 
> (define (real-part z) (car z))
> 
> (define (imag-part z) (cdr z))
> 
> (define (magnitude z)
>   (sqrt (+ (square (real-part z)) (square (imag-part z)))))
> 
> (define (angle z)
>   (atan (imag-part z) (real-part z)))
> 
> (define (make-from-real-imag x y) (cons x y))
> 
> (define (make-from-mag-ang r a) 
>   (cons (* r (cos a)) (* r (sin a))))
> 
> 
> ;; Alyssa (polar)
> 
> (define (real-part z)
>   (* (magnitude z) (cos (angle z))))
> 
> (define (imag-part z)
>   (* (magnitude z) (sin (angle z))))
> 
> (define (magnitude z) (car z))
> 
> (define (angle z) (cdr z))
> 
> (define (make-from-real-imag x y) 
>   (cons (sqrt (+ (square x) (square y)))
>         (atan y x)))
> 
> (define (make-from-mag-ang r a) (cons r a))
> 
> (define z (cons 2 3))
> (expt 2 4)
> (expt 2 4.)
> 
> (make-from-real-imag (real-part z) (imag-part z))
> 
> (make-from-mag-ang (magnitude z) (angle z))
> 
> ;;;SECTION 2.4.2
> 
> (define (attach-tag type-tag contents)
>   (cons type-tag contents))
> 
> (define (type-tag datum)
>   (if (pair? datum)
>       (car datum)
>       (error "Bad tagged datum -- TYPE-TAG" datum)))
> 
> (define (contents datum)
>   (if (pair? datum)
>       (cdr datum)
>       (error "Bad tagged datum -- CONTENTS" datum)))
> 
> (define (rectangular? z)
>   (eq? (type-tag z) 'rectangular))
> 
> (define (polar? z)
>   (eq? (type-tag z) 'polar))
> 
> 
> ;; Ben (rectangular)
> 
> (define (real-part-rectangular z) (car z))
> 
> (define (imag-part-rectangular z) (cdr z))
> 
> (define (magnitude-rectangular z)
>   (sqrt (+ (square (real-part-rectangular z))
>            (square (imag-part-rectangular z)))))
> 
> (define (angle-rectangular z)
>   (atan (imag-part-rectangular z)
>         (real-part-rectangular z)))
> 
> (define (make-from-real-imag-rectangular x y)
>   (attach-tag 'rectangular (cons x y)))
> 
> (define (make-from-mag-ang-rectangular r a) 
>   (attach-tag 'rectangular
>               (cons (* r (cos a)) (* r (sin a)))))
> 
> ;; Alyssa (polar)
> 
> (define (real-part-polar z)
>   (* (magnitude-polar z) (cos (angle-polar z))))
> 
> (define (imag-part-polar z)
>   (* (magnitude-polar z) (sin (angle-polar z))))
> 
> (define (magnitude-polar z) (car z))
> 
> (define (angle-polar z) (cdr z))
> 
> (define (make-from-real-imag-polar x y) 
>   (attach-tag 'polar
>                (cons (sqrt (+ (square x) (square y)))
>                      (atan y x))))
> 
> (define (make-from-mag-ang-polar r a)
>   (attach-tag 'polar (cons r a)))
> 
> 
> ;; Generic selectors
> 
> (define (real-part z)
>   (cond ((rectangular? z) 
>          (real-part-rectangular (contents z)))
>         ((polar? z)
>          (real-part-polar (contents z)))
>         (else (error "Unknown type -- REAL-PART" z))))
> 
> (define (imag-part z)
>   (cond ((rectangular? z)
>          (imag-part-rectangular (contents z)))
>         ((polar? z)
>          (imag-part-polar (contents z)))
>         (else (error "Unknown type -- IMAG-PART" z))))
> 
> (define (magnitude z)
>   (cond ((rectangular? z)
>          (magnitude-rectangular (contents z)))
>         ((polar? z)
>          (magnitude-polar (contents z)))
>         (else (error "Unknown type -- MAGNITUDE" z))))
> 
> (define (angle z)
>   (cond ((rectangular? z)
>          (angle-rectangular (contents z)))
>         ((polar? z)
>          (angle-polar (contents z)))
>         (else (error "Unknown type -- ANGLE" z))))
> 
> ;; same as before
> (define (add-complex z1 z2)
>   (make-from-real-imag (+ (real-part z1) (real-part z2))
>                        (+ (imag-part z1) (imag-part z2))))
> 
> ;; Constructors for complex numbers
> 
> (define (make-from-real-imag x y)
>   (make-from-real-imag-rectangular x y))
> 
> (define (make-from-mag-ang r a)
>   (make-from-mag-ang-polar r a))
> 
> ;;;SECTION 2.4.3
> 
> ;; uses get/put (from 3.3.3) -- see ch2support.scm
> 
> (define (install-rectangular-package)
>   ;; internal procedures
>   (define (real-part z) (car z))
>   (define (imag-part z) (cdr z))
>   (define (make-from-real-imag x y) (cons x y))
>   (define (magnitude z)
>     (sqrt (+ (square (real-part z))
>              (square (imag-part z)))))
>   (define (angle z)
>     (atan (imag-part z) (real-part z)))
>   (define (make-from-mag-ang r a) 
>     (cons (* r (cos a)) (* r (sin a))))
> 
>   ;; interface to the rest of the system
>   (define (tag x) (attach-tag 'rectangular x))
>   (put 'real-part '(rectangular) real-part)
>   (put 'imag-part '(rectangular) imag-part)
>   (put 'magnitude '(rectangular) magnitude)
>   (put 'angle '(rectangular) angle)
>   (put 'make-from-real-imag 'rectangular
>        (lambda (x y) (tag (make-from-real-imag x y))))
>   (put 'make-from-mag-ang 'rectangular
>        (lambda (r a) (tag (make-from-mag-ang r a))))
>   'done)
> 
> (define (install-polar-package)
>   ;; internal procedures
>   (define (magnitude z) (car z))
>   (define (angle z) (cdr z))
>   (define (make-from-mag-ang r a) (cons r a))
>   (define (real-part z)
>     (* (magnitude z) (cos (angle z))))
>   (define (imag-part z)
>     (* (magnitude z) (sin (angle z))))
>   (define (make-from-real-imag x y) 
>     (cons (sqrt (+ (square x) (square y)))
>           (atan y x)))
> 
>   ;; interface to the rest of the system
>   (define (tag x) (attach-tag 'polar x))
>   (put 'real-part '(polar) real-part)
>   (put 'imag-part '(polar) imag-part)
>   (put 'magnitude '(polar) magnitude)
>   (put 'angle '(polar) angle)
>   (put 'make-from-real-imag 'polar
>        (lambda (x y) (tag (make-from-real-imag x y))))
>   (put 'make-from-mag-ang 'polar
>        (lambda (r a) (tag (make-from-mag-ang r a))))
>   'done)
> 
> ;;footnote
> (apply + (list 1 2 3 4))
> 
> (define (apply-generic op . args)
>   (let ((type-tags (map type-tag args)))
>     (let ((proc (get op type-tags)))
>       (if proc
>           (apply proc (map contents args))
>           (error
>             "No method for these types -- APPLY-GENERIC"
>             (list op type-tags))))))
> 
> ;; Generic selectors
> 
> (define (real-part z) (apply-generic 'real-part z))
> (define (imag-part z) (apply-generic 'imag-part z))
> (define (magnitude z) (apply-generic 'magnitude z))
> (define (angle z) (apply-generic 'angle z))
> 
> 
> ;; Constructors for complex numbers
> 
> (define (make-from-real-imag x y)
>   ((get 'make-from-real-imag 'rectangular) x y))
> 
> (define (make-from-mag-ang r a)
>   ((get 'make-from-mag-ang 'polar) r a))
> 
> 
> 
> ;; EXERCISE 2.73
> (define (deriv exp var)
>   (cond ((number? exp) 0)
>         ((variable? exp) (if (same-variable? exp var) 1 0))
>         ((sum? exp)
>          (make-sum (deriv (addend exp) var)
>                    (deriv (augend exp) var)))
>         ((product? exp)
>          (make-sum
>            (make-product (multiplier exp)
>                          (deriv (multiplicand exp) var))
>            (make-product (deriv (multiplier exp) var)
>                          (multiplicand exp))))
>         (else (error "unknown expression type -- DERIV" exp))))
> 
> 
> (define (deriv exp var)
>    (cond ((number? exp) 0)
>          ((variable? exp) (if (same-variable? exp var) 1 0))
>          (else ((get 'deriv (operator exp)) (operands exp)
>                                             var))))
> 
> (define (operator exp) (car exp))
> 
> (define (operands exp) (cdr exp))
> 
> 
> ;((get (operator exp) 'deriv) (operands exp) var)
> 
> ;; Message passing
> (define (make-from-real-imag x y)
>   (define (dispatch op)
>     (cond ((eq? op 'real-part) x)
>           ((eq? op 'imag-part) y)
>           ((eq? op 'magnitude)
>            (sqrt (+ (square x) (square y))))
>           ((eq? op 'angle) (atan y x))
>           (else
>            (error "Unknown op -- MAKE-FROM-REAL-IMAG" op))))
>   dispatch)
> 
> (define (apply-generic op arg) (arg op))
> 
> ;;;SECTION 2.5.1
> 
> (define (add x y) (apply-generic 'add x y))
> (define (sub x y) (apply-generic 'sub x y))
> (define (mul x y) (apply-generic 'mul x y))
> (define (div x y) (apply-generic 'div x y))
> 
> (define (install-scheme-number-package)
>   (define (tag x)
>     (attach-tag 'scheme-number x))
>   (put 'add '(scheme-number scheme-number)
>        (lambda (x y) (tag (+ x y))))
>   (put 'sub '(scheme-number scheme-number)
>        (lambda (x y) (tag (- x y))))
>   (put 'mul '(scheme-number scheme-number)
>        (lambda (x y) (tag (* x y))))
>   (put 'div '(scheme-number scheme-number)
>        (lambda (x y) (tag (/ x y))))
>   (put 'make 'scheme-number
>        (lambda (x) (tag x)))
>   'done)
> 
> (define (make-scheme-number n)
>   ((get 'make 'scheme-number) n))
> 
> (define (install-rational-package)
>   ;; internal procedures
>   (define (numer x) (car x))
>   (define (denom x) (cdr x))
>   (define (make-rat n d)
>     (let ((g (gcd n d)))
>       (cons (/ n g) (/ d g))))
>   (define (add-rat x y)
>     (make-rat (+ (* (numer x) (denom y))
>                  (* (numer y) (denom x)))
>               (* (denom x) (denom y))))
>   (define (sub-rat x y)
>     (make-rat (- (* (numer x) (denom y))
>                  (* (numer y) (denom x)))
>               (* (denom x) (denom y))))
>   (define (mul-rat x y)
>     (make-rat (* (numer x) (numer y))
>               (* (denom x) (denom y))))
>   (define (div-rat x y)
>     (make-rat (* (numer x) (denom y))
>               (* (denom x) (numer y))))
>   ;; interface to rest of the system
>   (define (tag x) (attach-tag 'rational x))
>   (put 'add '(rational rational)
>        (lambda (x y) (tag (add-rat x y))))
>   (put 'sub '(rational rational)
>        (lambda (x y) (tag (sub-rat x y))))
>   (put 'mul '(rational rational)
>        (lambda (x y) (tag (mul-rat x y))))
>   (put 'div '(rational rational)
>        (lambda (x y) (tag (div-rat x y))))
> 
>   (put 'make 'rational
>        (lambda (n d) (tag (make-rat n d))))
>   'done)
> 
> (define (make-rational n d)
>   ((get 'make 'rational) n d))
> 
> (define (install-complex-package)
>   ;; imported procedures from rectangular and polar packages
>   (define (make-from-real-imag x y)
>     ((get 'make-from-real-imag 'rectangular) x y))
>   (define (make-from-mag-ang r a)
>     ((get 'make-from-mag-ang 'polar) r a))
>   ;; internal procedures
>   (define (add-complex z1 z2)
>     (make-from-real-imag (+ (real-part z1) (real-part z2))
>                          (+ (imag-part z1) (imag-part z2))))
>   (define (sub-complex z1 z2)
>     (make-from-real-imag (- (real-part z1) (real-part z2))
>                          (- (imag-part z1) (imag-part z2))))
>   (define (mul-complex z1 z2)
>     (make-from-mag-ang (* (magnitude z1) (magnitude z2))
>                        (+ (angle z1) (angle z2))))
>   (define (div-complex z1 z2)
>     (make-from-mag-ang (/ (magnitude z1) (magnitude z2))
>                        (- (angle z1) (angle z2))))
> 
>   ;; interface to rest of the system
>   (define (tag z) (attach-tag 'complex z))
>   (put 'add '(complex complex)
>        (lambda (z1 z2) (tag (add-complex z1 z2))))
>   (put 'sub '(complex complex)
>        (lambda (z1 z2) (tag (sub-complex z1 z2))))
>   (put 'mul '(complex complex)
>        (lambda (z1 z2) (tag (mul-complex z1 z2))))
>   (put 'div '(complex complex)
>        (lambda (z1 z2) (tag (div-complex z1 z2))))
>   (put 'make-from-real-imag 'complex
>        (lambda (x y) (tag (make-from-real-imag x y))))
>   (put 'make-from-mag-ang 'complex
>        (lambda (r a) (tag (make-from-mag-ang r a))))
>   'done)
> 
> (define (make-complex-from-real-imag x y)
>   ((get 'make-from-real-imag 'complex) x y))
> 
> (define (make-complex-from-mag-ang r a)
>   ((get 'make-from-mag-ang 'complex) r a))
> 
> 
> ;; EXERCISE 2.77
> ;; to put in complex package
> 
> (put 'real-part '(complex) real-part)
> (put 'imag-part '(complex) imag-part)
> (put 'magnitude '(complex) magnitude)
> (put 'angle '(complex) angle)
> 
> ;;;SECTION 2.5.2
> 
> ;; to be included in the complex package
> (define (add-complex-to-schemenum z x)
>   (make-from-real-imag (+ (real-part z) x)
>                        (imag-part z)))
> 
> (put 'add '(complex scheme-number)
>      (lambda (z x) (tag (add-complex-to-schemenum z x))))
> 
> 
> ;; Coercion
> 
> (define (scheme-number->complex n)
>   (make-complex-from-real-imag (contents n) 0))
> 
> '(put-coercion 'scheme-number 'complex scheme-number->complex)
> 
> 
> (define (apply-generic op . args)
>   (let ((type-tags (map type-tag args)))
>     (let ((proc (get op type-tags)))
>       (if proc
>           (apply proc (map contents args))
>           (if (= (length args) 2)
>               (let ((type1 (car type-tags))
>                     (type2 (cadr type-tags))
>                     (a1 (car args))
>                     (a2 (cadr args)))
>                 (let ((t1->t2 (get-coercion type1 type2))
>                       (t2->t1 (get-coercion type2 type1)))
>                   (cond (t1->t2
>                          (apply-generic op (t1->t2 a1) a2))
>                         (t2->t1
>                          (apply-generic op a1 (t2->t1 a2)))
>                         (else
>                          (error "No method for these types"
>                                 (list op type-tags))))))
>               (error "No method for these types"
>                      (list op type-tags)))))))
> 
> ;; EXERCISE 2.81
> 
> (define (scheme-number->scheme-number n) n)
> (define (complex->complex z) z)
> '(put-coercion 'scheme-number 'scheme-number
>               scheme-number->scheme-number)
> '(put-coercion 'complex 'complex complex->complex)
> 
> (define (exp x y) (apply-generic 'exp x y))
> (put 'exp '(scheme-number scheme-number)
>       (lambda (x y) (tag (expt x y))))
> 
> ;;;SECTION 2.5.3
> 
> ;;; ALL procedures in 2.5.3 except make-polynomial
> ;;; should be inserted in install-polynomial-package, as indicated
> 
> (define (add-poly p1 p2)
>   (if (same-variable? (variable p1) (variable p2))
>       (make-poly (variable p1)
>                  (add-terms (term-list p1)
>                             (term-list p2)))
>       (error "Polys not in same var -- ADD-POLY"
>              (list p1 p2))))
> 
> (define (mul-poly p1 p2)
>   (if (same-variable? (variable p1) (variable p2))
>       (make-poly (variable p1)
>                  (mul-terms (term-list p1)
>                             (term-list p2)))
>       (error "Polys not in same var -- MUL-POLY"
>              (list p1 p2))))
> 
> ;; *incomplete* skeleton of package
> (define (install-polynomial-package)
>   ;; internal procedures
>   ;; representation of poly
>   (define (make-poly variable term-list)
>     (cons variable term-list))
>   (define (variable p) (car p))
>   (define (term-list p) (cdr p))
>   ;;[procedures same-variable? and variable? from section 2.3.2]
> 
>   ;; representation of terms and term lists
>   ;;[procedures adjoin-term ... coeff from text below]
> 
>   ;;(define (add-poly p1 p2) ... )
>   ;;[procedures used by add-poly]
> 
>   ;;(define (mul-poly p1 p2) ... )
>   ;;[procedures used by mul-poly]
> 
>   ;; interface to rest of the system
>   (define (tag p) (attach-tag 'polynomial p))
>   (put 'add '(polynomial polynomial) 
>        (lambda (p1 p2) (tag (add-poly p1 p2))))
>   (put 'mul '(polynomial polynomial) 
>        (lambda (p1 p2) (tag (mul-poly p1 p2))))
> 
>   (put 'make 'polynomial
>        (lambda (var terms) (tag (make-poly var terms))))
>   'done)
> 
> (define (add-terms L1 L2)
>   (cond ((empty-termlist? L1) L2)
>         ((empty-termlist? L2) L1)
>         (else
>          (let ((t1 (first-term L1)) (t2 (first-term L2)))
>            (cond ((> (order t1) (order t2))
>                   (adjoin-term
>                    t1 (add-terms (rest-terms L1) L2)))
>                  ((< (order t1) (order t2))
>                   (adjoin-term
>                    t2 (add-terms L1 (rest-terms L2))))
>                  (else
>                   (adjoin-term
>                    (make-term (order t1)
>                               (add (coeff t1) (coeff t2)))
>                    (add-terms (rest-terms L1)
>                               (rest-terms L2)))))))))
> 
> (define (mul-terms L1 L2)
>   (if (empty-termlist? L1)
>       (the-empty-termlist)
>       (add-terms (mul-term-by-all-terms (first-term L1) L2)
>                  (mul-terms (rest-terms L1) L2))))
> 
> (define (mul-term-by-all-terms t1 L)
>   (if (empty-termlist? L)
>       (the-empty-termlist)
>       (let ((t2 (first-term L)))
>         (adjoin-term
>          (make-term (+ (order t1) (order t2))
>                     (mul (coeff t1) (coeff t2)))
>          (mul-term-by-all-terms t1 (rest-terms L))))))
> 
> 
> ;; Representing term lists
> 
> (define (adjoin-term term term-list)
>   (if (=zero? (coeff term))
>       term-list
>       (cons term term-list)))
> 
> (define (the-empty-termlist) '())
> (define (first-term term-list) (car term-list))
> (define (rest-terms term-list) (cdr term-list))
> (define (empty-termlist? term-list) (null? term-list))
> 
> (define (make-term order coeff) (list order coeff))
> (define (order term) (car term))
> (define (coeff term) (cadr term))
> 
> 
> ;; Constructor
> (define (make-polynomial var terms)
>   ((get 'make 'polynomial) var terms))
> 
> 
> ;; EXERCISE 2.91
> 
> (define (div-terms L1 L2)
>   (if (empty-termlist? L1)
>       (list (the-empty-termlist) (the-empty-termlist))
>       (let ((t1 (first-term L1))
>             (t2 (first-term L2)))
>         (if (> (order t2) (order t1))
>             (list (the-empty-termlist) L1)
>             (let ((new-c (div (coeff t1) (coeff t2)))
>                   (new-o (- (order t1) (order t2))))
>               (let ((rest-of-result
>                      ??FILL-THIS-IN?? ;compute rest of result recursively
>                      ))
>                 ??FILL-THIS-IN?? ;form complete result
>                 ))))))
> 
> 
> ;; EXERCISE 2.93
> '(define p1 (make-polynomial 'x '((2 1)(0 1))))
> '(define p2 (make-polynomial 'x '((3 1)(0 1))))
> '(define rf (make-rational p2 p1))
> 
> 
> 
> ;; Rational functions
> 
> (define (gcd a b)
>   (if (= b 0)
>       a
>       (gcd b (remainder a b))))
> 
> (define (gcd-terms a b)
>   (if (empty-termlist? b)
>       a
>       (gcd-terms b (remainder-terms a b))))
> 
> 
> ;; EXERCISE 2.94
> '(define p1 (make-polynomial 'x '((4 1) (3 -1) (2 -2) (1 2))))
> '(define p2 (make-polynomial 'x '((3 1) (1 -1))))
> '(greatest-common-divisor p1 p2)
> 
> ;; EXERCISE 2.97
> 
> (define (reduce-integers n d)
>   (let ((g (gcd n d)))
>     (list (/ n g) (/ d g))))
> 
> '(define p1 (make-polynomial 'x '((1 1)(0 1))))
> '(define p2 (make-polynomial 'x '((3 1)(0 -1))))
> '(define p3 (make-polynomial 'x '((1 1))))
> '(define p4 (make-polynomial 'x '((2 1)(0 -1))))
> 
> '(define rf1 (make-rational p1 p2))
> '(define rf2 (make-rational p3 p4))
> 
> '(add rf1 rf2)
> )) ;end of items
> 
> (define (process items #)
>     (define old-car car)
>     (define old-cdr cdr)
>     (define (iter items)
>         (cond
>             ((null? items) 'done)
>             (else
>                 (define result (eval (old-car items) #))
>                 (println (old-car items) " is " result)
>                 ;(inspect (stack-depth))
>                 (iter (old-cdr items))
>                 )
>             )
>         )
>     (iter items)
>     )
> 
> (process items)
> 
> ------------------------------------------
> (define (linear-combination a b x y) (+ (* a x) (* b y))) is <function linear-combination(a b x y)>
> (define (linear-combination a b x y) (add (mul a x) (mul b y))) is <function linear-combination(a b x y)>
> (define (add-rat x y) (make-rat (+ (* (numer x) (denom y)) (* (numer y) (denom x))) (* (denom x) (denom y)))) is <function add-rat(x y)>
> (define (sub-rat x y) (make-rat (- (* (numer x) (denom y)) (* (numer y) (denom x))) (* (denom x) (denom y)))) is <function sub-rat(x y)>
> (define (mul-rat x y) (make-rat (* (numer x) (numer y)) (* (denom x) (denom y)))) is <function mul-rat(x y)>
> (define (div-rat x y) (make-rat (* (numer x) (denom y)) (* (denom x) (numer y)))) is <function div-rat(x y)>
> (define (equal-rat? x y) (= (* (numer x) (denom y)) (* (numer y) (denom x)))) is <function equal-rat?(x y)>
> (define x (cons 1 2)) is (1 . 2)
> (car x) is 1
> (cdr x) is 2
> (define x (cons 1 2)) is (1 . 2)
> (define y (cons 3 4)) is (3 . 4)
> (define z (cons x y)) is ((1 . 2) 3 . 4)
> (car (car z)) is 1
> (car (cdr z)) is 3
> (define (make-rat n d) (cons n d)) is <function make-rat(n d)>
> (define (numer x) (car x)) is <function numer(x)>
> (define (denom x) (cdr x)) is <function denom(x)>
> (define make-rat cons) is <builtIn cons(a b)>
> (define numer car) is <builtIn car(items)>
> (define denom cdr) is <builtIn cdr(items)>
> (define (print-rat x) (newline) (display (numer x)) (display "/") (display (denom x)) (quote ok)) is <function print-rat(x)>
> (define one-half (make-rat 1 2)) is (1 . 2)
> 
> 1/2(print-rat one-half) is ok
> (define one-third (make-rat 1 3)) is (1 . 3)
> 
> 5/6(print-rat (add-rat one-half one-third)) is ok
> 
> 1/6(print-rat (mul-rat one-half one-third)) is ok
> 
> 6/9(print-rat (add-rat one-third one-third)) is ok
> (define (make-rat n d) (let ((g (gcd n d))) (cons (/ n g) (/ d g)))) is <function make-rat(n d)>
> 
> 2/3(print-rat (add-rat one-third one-third)) is ok
> (define (make-rat n d) (cons n d)) is <function make-rat(n d)>
> (define (numer x) (let ((g (gcd (car x) (cdr x)))) (/ (car x) g))) is <function numer(x)>
> (define (denom x) (let ((g (gcd (car x) (cdr x)))) (/ (cdr x) g))) is <function denom(x)>
> (define (print-point p) (newline) (display "(") (display (x-point p)) (display ",") (display (y-point p)) (display ")")) is <function print-point(p)>
> (define (cons x y) (define (dispatch m) (cond ((= m 0) x) ((= m 1) y) (else (error "Argument not 0 or 1 -- cons" m)))) dispatch) is <function cons(x y)>
> (cons 1 2) is <function dispatch(m)>
> z is ((1 . 2) 3 . 4)
> (define (car z) (z 0)) is <function car(z)>
> (define (cdr z) (z 1)) is <function cdr(z)>
> (car (cons (quote head) (quote tail))) is head
> (cdr (cons (quote head) (quote tail))) is tail
> (define (cons x y) <lambda ()>) is <function cons(x y)>
> (define (car z) (z <lambda ()>)) is <function car(z)>
> (car (cons (quote head) (quote tail))) is head
> EXCEPTION: generalException
> file sicp2.s,line 160: set identifier resolved to type CONS, not SYMBOL
------------------------------------------
sicp2-support.s
------------------------------------------
0a1,67
> ;;; CODE FROM OTHER CHAPTERS OF STRUCTURE AND INTERPRETATION OF
> ;;;  COMPUTER PROGRAMS NEEDED BY CHAPTER 2
> 
> ;;;from chapter 1
> (define (square x) (* x x))
> 
> ;;;from section 1.2.5, for Section 2.1.1
> (define (gcd a b)
>   (if (= b 0)
>       a
>       (gcd b (remainder a b))))
> 
> ;;;from section 1.2.2, for Section 2.2.3
> (define (fib n)
>   (cond ((= n 0) 0)
>         ((= n 1) 1)
>         (else (+ (fib (- n 1))
>                  (fib (- n 2))))))
> 
> ;;; ***not in book, but needed for code before quote is introduced*** 
> ;NOT-NEEDED: (define nil '())
> 
> ;;;-----------
> ;;;from section 3.3.3 for section 2.4.3
> ;;; to support operation/type table for data-directed dispatch
> 
> (define (assoc key records)
>   (cond ((null? records) false)
>         ((equal? key (caar records)) (car records))
>         (else (assoc key (cdr records)))))
> 
> (define (make-table)
>   (let ((local-table (list '*table*)))
>     (define (lookup key-1 key-2)
>       (let ((subtable (assoc key-1 (cdr local-table))))
>         (if subtable
>             (let ((record (assoc key-2 (cdr subtable))))
>               (if record
>                   (cdr record)
>                   false))
>             false)))
>     (define (insert! key-1 key-2 value)
>       (let ((subtable (assoc key-1 (cdr local-table))))
>         (if subtable
>             (let ((record (assoc key-2 (cdr subtable))))
>               (if record
>                   (set-cdr! record value)
>                   (set-cdr! subtable
>                             (cons (cons key-2 value)
>                                   (cdr subtable)))))
>             (set-cdr! local-table
>                       (cons (list key-1
>                                   (cons key-2 value))
>                             (cdr local-table)))))
>       'ok)    
>     (define (dispatch m)
>       (cond ((eq? m 'lookup-proc) lookup)
>             ((eq? m 'insert-proc!) insert!)
>             (else (error "Unknown operation -- TABLE" m))))
>     dispatch))
> 
> (define operation-table (make-table))
> (define get (operation-table 'lookup-proc))
> (define put (operation-table 'insert-proc!))
> 
> ;;;-----------
> ------------------------------------------
------------------------------------------
sicp3.s
------------------------------------------
0a1,1761
> ;;;;CODE FROM CHAPTER 3 OF STRUCTURE AND INTERPRETATION OF COMPUTER PROGRAMS
> 
> ;;; Examples from the book are commented out with ;: so that they
> ;;;  are easy to find and so that they will be omitted if you evaluate a
> ;;;  chunk of the file (programs with intervening examples) in Scheme.
> 
> ;;; BEWARE: Although the whole file can be loaded into Scheme,
> ;;;  you won't want to do so.  For example, you generally do
> ;;;  not want to use the procedural representation of pairs
> ;;;  (cons, car, cdr as defined in section 3.3.1) instead of
> ;;;  Scheme's primitive pairs.
> 
> ;;; Some things require code that is not in the book -- see ch3support.scm
> 
> 
> (include "sicp3-support.s")
> 
> (define items '(
> 
> ;;;;SECTION 3.1
> 
> ;;;SECTION 3.1.1
> 
> (define balance 100)
> 
> (define (withdraw amount)
>   (if (>= balance amount)
>       (begin (set! 'balance (- balance amount))
>              balance)
>       "Insufficient funds"))
> 
> 
> (define new-withdraw
>   (let ((balance 100))
>     (lambda (amount)
>       (if (>= balance amount)
>           (begin (set! 'balance (- balance amount))
>                  balance)
>           "Insufficient funds"))))
> 
> 
> (define (make-withdraw balance)
>   (lambda (amount)
>     (if (>= balance amount)
>         (begin (set! 'balance (- balance amount))
>                balance)
>         "Insufficient funds")))
> 
> 
> (withdraw 25)
> (withdraw 25)
> (withdraw 60)
> (withdraw 15)
> 
> (define W1 (make-withdraw 100))
> (define W2 (make-withdraw 100))
> (W1 50)
> (W2 70)
> (W2 40)
> (W1 40)
> 
> (define (make-account balance)
>   (define (withdraw amount)
>     (if (>= balance amount)
>         (begin (set! 'balance (- balance amount))
>                balance)
>         "Insufficient funds"))
>   (define (deposit amount)
>     (set! 'balance (+ balance amount))
>     balance)
>   (define (dispatch m)
>     (cond ((eq? m 'withdraw) withdraw)
>           ((eq? m 'deposit) deposit)
>           (else (error "Unknown request -- MAKE-ACCOUNT"
>                        m))))
>   dispatch)
> 
> (define acc (make-account 100))
> 
> ((acc 'withdraw) 50)
> ((acc 'withdraw) 60)
> ((acc 'deposit) 40)
> ((acc 'withdraw) 60)
> 
> (define acc2 (make-account 100))
> 
> 
> ;; EXERCISE 3.1
> '(define A (make-accumulator 5))
> '(A 10)
> '(A 10)
> 
> 
> ;; EXERCISE 3.2
> '(define s (make-monitored sqrt))
> '(s 100)
> '(s 'how-many-calls?)
> 
> 
> ;; EXERCISE 3.3
> '(define acc (make-account 100 'secret-password))
> '((acc 'secret-password 'withdraw) 40)
> '((acc 'some-other-password 'deposit) 50)
> 
> 
> ;;;SECTION 3.1.2
> 
> ;; *following uses rand-update -- see ch3support.scm
> ;; *also must set random-init to some value
> (define random-init 7)                  ;**not in book**
> (define rand
>   (let ((x random-init))
>     (lambda ()
>       (set! 'x (rand-update x))
>       x)))
> 
> 
> (define (estimate-pi trials)
>   (sqrt (/ 6 (monte-carlo trials cesaro-test))))
> 
> (define (cesaro-test)
>    (= (gcd (rand) (rand)) 1))
> 
> (define (monte-carlo trials experiment)
>   (define (iter trials-remaining trials-passed)
>     (cond ((= trials-remaining 0)
>            (/ trials-passed trials))
>           ((experiment)
>            (iter (- trials-remaining 1) (+ trials-passed 1)))
>           (else
>            (iter (- trials-remaining 1) trials-passed))))
>   (iter trials 0))
> 
> ;; second version (no assignment)
> (define (estimate-pi trials)
>   (sqrt (/ 6 (random-gcd-test trials random-init))))
> 
> (define (random-gcd-test trials initial-x)
>   (define (iter trials-remaining trials-passed x)
>     (let ((x1 (rand-update x)))
>       (let ((x2 (rand-update x1)))
>         (cond ((= trials-remaining 0)   
>                (/ trials-passed trials))
>               ((= (gcd x1 x2) 1)
>                (iter (- trials-remaining 1)
>                      (+ trials-passed 1)
>                      x2))
>               (else
>                (iter (- trials-remaining 1)
>                      trials-passed
>                      x2))))))
>   (iter trials 0 initial-x))
> 
> 
> ;; EXERCISE 3.5
> (define (random-in-range low high)
>   (let ((range (- high low)))
>     (+ low (random range))))
> 
> 
> ;;;SECTION 3.1.3
> 
> (define (make-simplified-withdraw balance)
>   (lambda (amount)
>     (set! 'balance (- balance amount))
>     balance))
> 
> 
> (define W (make-simplified-withdraw 25))
> (W 20)
> (W 10)
> 
> 
> (define (make-decrementer balance)
>   (lambda (amount)
>     (- balance amount)))
> 
> (define D (make-decrementer 25))
> (D 20)
> (D 10)
> 
> ((make-decrementer 25) 20)
> ((lambda (amount) (- 25 amount)) 20)
> (- 25 20)
> 
> ((make-simplified-withdraw 25) 20)
> 
> ((lambda (amount) (set! 'balance (- 25 amount)) 25) 20)
> balance
> (set! 'balance (- 25 20)) 25
> balance
> 
> ;;;Sameness and change
> 
> (define D1 (make-decrementer 25))
> (define D2 (make-decrementer 25))
> 
> (define W1 (make-simplified-withdraw 25))
> (define W2 (make-simplified-withdraw 25))
> 
> (W1 20)
> (W1 20)
> (W2 20)
> 
> (define peter-acc (make-account 100))
> (define paul-acc (make-account 100))
> 
> (define peter-acc (make-account 100))
> (define paul-acc peter-acc)
> 
> ;;;Pitfalls of imperative programming
> 
> (define (factorial n)
>   (define (iter product counter)
>     (if (> counter n)
>         product
>         (iter (* counter product)
>               (+ counter 1))))
>   (iter 1 1))
> 
> (define (factorial n)
>   (let ((product 1)
>         (counter 1))
>     (define (iter)
>       (if (> counter n)
>           product
>           (begin (set! 'product (* counter product))
>                  (set! 'counter (+ counter 1))
>                  (iter))))
>     (iter)))
> 
> 
> ;; EXERCISE 3.7
> '(define paul-acc
>   (make-joint peter-acc 'open-sesame 'rosebud))
> 
> ;;;;SECTION 3.2
> 
> ;;;SECTION 3.2.1
> 
> (define (square x)
>   (* x x))
> 
> (square 4)
> (define square
>   (lambda (x) (* x x)))
> (square 4)
> 
> 
> ;;;SECTION 3.2.2
> 
> (define (square x)
>   (* x x))
> 
> (define (sum-of-squares x y)
>   (+ (square x) (square y)))
> 
> (define (f a)
>   (sum-of-squares (+ a 1) (* a 2)))
> 
> (catch (sum-of-squares (+ a 1) (* a 2)))
> 
> 
> ;; EXERCISE 3.9
> 
> (define (factorial n)
>   (if (= n 1)
>       1
>       (* n (factorial (- n 1)))))
> 
> (define (factorial n)
>   (fact-iter 1 1 n))
> 
> (define (fact-iter product counter max-count)
>   (if (> counter max-count)
>       product
>       (fact-iter (* counter product)
>                  (+ counter 1)
>                  max-count)))
> 
> 
> ;;;SECTION 3.2.3
> 
> (define (make-withdraw balance)
>   (lambda (amount)
>     (if (>= balance amount)
>         (begin (set! 'balance (- balance amount))
>                balance)
>         "Insufficient funds")))
> 
> (define W1 (make-withdraw 100))
> (W1 50)
> 
> (define W2 (make-withdraw 100))
> (W2 0)
> 
> ;; EXERCISE 3.10
> 
> (define (make-withdraw initial-amount)
>   (let ((balance initial-amount))
>     (lambda (amount)
>       (if (>= balance amount)
>           (begin (set! 'balance (- balance amount))
>                  balance)
>           "Insufficient funds"))))
> 
> 
> (define W1 (make-withdraw 100))
> (W1 50)
> (define W2 (make-withdraw 100))
> (W2 0)
> 
> 
> ;;;SECTION 3.2.4
> 
> ;; same as in section 1.1.8
> (define (sqrt x)
>   (define (good-enough? guess)
>     (< (abs (- (square guess) x)) 0.001))
>   (define (improve guess)
>     (average guess (/ x guess)))
>   (define (sqrt-iter guess)
>     (if (good-enough? guess)
>         guess
>         (sqrt-iter (improve guess))))
>   (sqrt-iter 1.0))
> 
> 
> ;; EXERCISE 3.11
> 
> (define (make-account balance)
>   (define (withdraw amount)
>     (if (>= balance amount)
>         (begin (set! 'balance (- balance amount))
>                balance)
>         "Insufficient funds"))
>   (define (deposit amount)
>     (set! 'balance (+ balance amount))
>     balance)
>   (define (dispatch m)
>     (cond ((eq? m 'withdraw) withdraw)
>           ((eq? m 'deposit) deposit)
>           (else (error "Unknown request -- MAKE-ACCOUNT"
>                        m))))
>   dispatch)
> 
> (define acc (make-account 50))
> 
> ((acc 'deposit) 40)
> ((acc 'withdraw) 60)
> 
> (define acc2 (make-account 100))
> 
> 
> ;;;;SECTION 3.3
> 
> ;;;SECTION 3.3.1
> 
> (define old-cons cons)
> (define (get-new-pair) (old-cons nil nil))
> 
> (define (cons x y)
>   (let ((new (get-new-pair)))
>     (set-car! new x)
>     (set-cdr! new y)
>     new))
> 
> 
> ;; EXERCISE 3.12
> (define (append x y)
>   (if (null? x)
>       y
>       (cons (car x) (append (cdr x) y))))
> 
> (define (append! x y)
>   (set-cdr! (last-pair x) y)
>   x)
> 
> (define (last-pair x)
>   (if (null? (cdr x))
>       x
>       (last-pair (cdr x))))
> 
> (define x (list 'a 'b))
> (define y (list 'c 'd))
> (define z (append  x y))
> z
> (cdr x)
> 
> (define w (append! x y))
> w
> (cdr x)
> 
> 
> ;; EXERCISE 3.13
> (define (make-cycle x)
>   (set-cdr! (last-pair x) x)
>   x)
> 
> (define z)
> (begin (set! 'z (make-cycle (list 'a 'b 'c))) 'ok)
> (car z)
> (cadr z)
> (caddr z)
> (cadddr z)
> (caddddr z)
> (cadddddr z)
> 
> ;; EXERCISE 3.14
> (define (mystery x)
>   (define (loop x y)
>     (if (null? x)
>         y
>         (let ((temp (cdr x)))
>           (set-cdr! x y)
>           (loop temp x))))
>   (loop x '()))
> 
> 
> ;;; Sharing and identity
> 
> (define x (list 'a 'b))
> (define z1 (cons x x))
> (define z2 (cons (list 'a 'b) (list 'a 'b)))
> 
> (define (set-to-wow! x)
>   (set-car! (car x) 'wow)
>   x)
> 
> z1
> (set-to-wow! z1)
> z2
> (set-to-wow! z2)
> 
> 
> ;; EXERCISE 3.16
> (define (count-pairs x)
>   (if (not (pair? x))
>       0
>       (+ (count-pairs (car x))
>          (count-pairs (cdr x))
>          1)))
> 
> 
> ;;;Mutation as assignment
> 
> (define (cons x y)
>   (define (dispatch m)
>     (cond ((eq? m 'car) x)
>           ((eq? m 'cdr) y)
>           (else (error "Undefined operation -- CONS" m))))
>   dispatch)
> 
> (define (car z) (z 'car))
> (define (cdr z) (z 'cdr))
> 
> 
> (define (cons x y)
>   (define (set-x! v) (set! 'x v))
>   (define (set-y! v) (set! 'y v))
>   (define (dispatch m)
>     (cond ((eq? m 'car) x)
>           ((eq? m 'cdr) y)
>           ((eq? m 'set-car!) set-x!)
>           ((eq? m 'set-cdr!) set-y!)
>           (else (error "Undefined operation -- CONS" m))))
>   dispatch)
> 
> (define (car z) (z 'car))
> (define (cdr z) (z 'cdr))
> 
> (define (set-car! z new-value)
>   ((z 'set-car!) new-value)
>   z)
> 
> (define (set-cdr! z new-value)
>   ((z 'set-cdr!) new-value)
>   z)
> 
> 
> ;; EXERCISE 3.20
> (define x (cons 1 2))
> (define z (cons x x))
> (set-car! (cdr z) 17)
> (car x)
> 
> 
> ;;;SECTION 3.3.2
> 
> (define (front-ptr queue) (car queue))
> (define (rear-ptr queue) (cdr queue))
> (define (set-front-ptr! queue item) (set-car! queue item))
> (define (set-rear-ptr! queue item) (set-cdr! queue item))
> 
> (define (empty-queue? queue) (null? (front-ptr queue)))
> (define (make-queue) (cons '() '()))
> 
> (define (front-queue queue)
>   (if (empty-queue? queue)
>       (error "FRONT called with an empty queue" queue)
>       (car (front-ptr queue))))
> 
> (define (insert-queue! queue item)
>   (let ((new-pair (cons item '())))
>     (cond ((empty-queue? queue)
>            (set-front-ptr! queue new-pair)
>            (set-rear-ptr! queue new-pair)
>            queue)
>           (else
>            (set-cdr! (rear-ptr queue) new-pair)
>            (set-rear-ptr! queue new-pair)
>            queue)))) 
> 
> (define (delete-queue! queue)
>   (cond ((empty-queue? queue)
>          (error "DELETE! called with an empty queue" queue))
>         (else
>          (set-front-ptr! queue (cdr (front-ptr queue)))
>          queue))) 
> 
> 
> ;; EXERCISE 3.21
> (define q1 (make-queue))
> (insert-queue! q1 'a)
> (insert-queue! q1 'b)
> (delete-queue! q1)
> (delete-queue! q1)
> 
> 
> ;;;SECTION 3.3.3
> 
> (define (lookup key table)
>   (let ((record (assoc key (cdr table))))
>     (if record
>         (cdr record)
>         false)))
> 
> (define (assoc key records)
>   (cond ((null? records) false)
>         ((equal? key (caar records)) (car records))
>         (else (assoc key (cdr records)))))
> 
> (define (insert! key value table)
>   (let ((record (assoc key (cdr table))))
>     (if record
>         (set-cdr! record value)
>         (set-cdr! table
>                   (cons (cons key value) (cdr table)))))
>   'ok)
> 
> (define (make-table)
>   (list '*table*))
> 
> ;; two-dimensional
> (define (lookup key-1 key-2 table)
>   (let ((subtable (assoc key-1 (cdr table))))
>     (if subtable
>         (let ((record (assoc key-2 (cdr subtable))))
>           (if record
>               (cdr record)
>               false))
>         false)))
> 
> (define (insert! key-1 key-2 value table)
>   (let ((subtable (assoc key-1 (cdr table))))
>     (if subtable
>         (let ((record (assoc key-2 (cdr subtable))))
>           (if record
>               (set-cdr! record value)
>               (set-cdr! subtable
>                         (cons (cons key-2 value)
>                               (cdr subtable)))))
>         (set-cdr! table
>                   (cons (list key-1
>                               (cons key-2 value))
>                         (cdr table)))))
>   'ok)
> 
> ;; local tables
> (define (make-table)
>   (let ((local-table (list '*table*)))
>     (define (lookup key-1 key-2)
>       (let ((subtable (assoc key-1 (cdr local-table))))
>         (if subtable
>             (let ((record (assoc key-2 (cdr subtable))))
>               (if record
>                   (cdr record)
>                   false))
>             false)))
>     (define (insert! key-1 key-2 value)
>       (let ((subtable (assoc key-1 (cdr local-table))))
>         (if subtable
>             (let ((record (assoc key-2 (cdr subtable))))
>               (if record
>                   (set-cdr! record value)
>                   (set-cdr! subtable
>                             (cons (cons key-2 value)
>                                   (cdr subtable)))))
>             (set-cdr! local-table
>                       (cons (list key-1
>                                   (cons key-2 value))
>                             (cdr local-table)))))
>       'ok)    
>     (define (dispatch m)
>       (cond ((eq? m 'lookup-proc) lookup)
>             ((eq? m 'insert-proc!) insert!)
>             (else (error "Unknown operation -- TABLE" m))))
>     dispatch))
> 
> (define operation-table (make-table))
> (define get (operation-table 'lookup-proc))
> (define put (operation-table 'insert-proc!))
> 
> 
> ;; EXERCISE 3.27
> (define (fib n)
>   (cond ((= n 0) 0)
>         ((= n 1) 1)
>         (else (+ (fib (- n 1))
>                  (fib (- n 2))))))
> 
> (define (memoize f)
>   (let ((table (make-table)))
>     (lambda (x)
>       (let ((previously-computed-result (lookup x table)))
>         (or previously-computed-result
>             (let ((result (f x)))
>               (insert! x result table)
>               result))))))
> 
> (define memo-fib
>   (memoize (lambda (n)
>              (cond ((= n 0) 0)
>                    ((= n 1) 1)
>                    (else (+ (memo-fib (- n 1))
>                             (memo-fib (- n 2))))))))
> 
> ;;;SECTION 3.3.4
> 
> 
> ;;NB. To use half-adder, need or-gate from exercise 3.28
> (define (half-adder a b s c)
>   (let ((d (make-wire)) (e (make-wire)))
>     (or-gate a b d)
>     (and-gate a b c)
>     (inverter c e)
>     (and-gate d e s)
>     'ok))
> 
> (define (full-adder a b c-in sum c-out)
>   (let ((s (make-wire))
>         (c1 (make-wire))
>         (c2 (make-wire)))
>     (half-adder b c-in s c1)
>     (half-adder a s sum c2)
>     (or-gate c1 c2 c-out)
>     'ok))
> 
> (define (inverter input output)
>   (define (invert-input)
>     (let ((new-value (logical-not (get-signal input))))
>       (after-delay inverter-delay
>                    (lambda ()
>                      (set-signal! output new-value)))))
>   (add-action! input invert-input)
>   'ok)
> 
> (define (logical-not s)
>   (cond ((= s 0) 1)
>         ((= s 1) 0)
>         (else (error "Invalid signal" s))))
> 
> ;; *following uses logical-and -- see ch3support.scm
> 
> (define (and-gate a1 a2 output)
>   (define (and-action-procedure)
>     (let ((new-value
>            (logical-and (get-signal a1) (get-signal a2))))
>       (after-delay and-gate-delay
>                    (lambda ()
>                      (set-signal! output new-value)))))
>   (add-action! a1 and-action-procedure)
>   (add-action! a2 and-action-procedure)
>   'ok)
> 
> 
> (define (make-wire)
>   (let ((signal-value 0) (action-procedures '()))
>     (define (set-my-signal! new-value)
>       (if (not (= signal-value new-value))
>           (begin (set! 'signal-value new-value)
>                  (call-each action-procedures))
>           'done))
>     (define (accept-action-procedure! proc)
>       (set! 'action-procedures (cons proc action-procedures))
>       (proc))
>     (define (dispatch m)
>       (cond ((eq? m 'get-signal) signal-value)
>             ((eq? m 'set-signal!) set-my-signal!)
>             ((eq? m 'add-action!) accept-action-procedure!)
>             (else (error "Unknown operation -- WIRE" m))))
>     dispatch))
> 
> (define (call-each procedures)
>   (if (null? procedures)
>       'done
>       (begin
>         ((car procedures))
>         (call-each (cdr procedures)))))
> 
> (define (get-signal wire)
>   (wire 'get-signal))
> 
> (define (set-signal! wire new-value)
>   ((wire 'set-signal!) new-value))
> 
> (define (add-action! wire action-procedure)
>   ((wire 'add-action!) action-procedure))
> 
> (define (after-delay delay action)
>   (add-to-agenda! (+ delay (current-time the-agenda))
>                   action
>                   the-agenda))
> 
> (define (propagate)
>   (if (empty-agenda? the-agenda)
>       'done
>       (let ((first-item (first-agenda-item the-agenda)))
>         (first-item)
>         (remove-first-agenda-item! the-agenda)
>         (propagate))))
> 
> (define (probe name wire)
>   (add-action! wire
>                (lambda ()        
>                  (newline)
>                  (display name)
>                  (display " ")
>                  (display (current-time the-agenda))
>                  (display "  New-value = ")
>                  (display (get-signal wire)))))
> 
> (define a (make-wire))
> (define b (make-wire))
> (define c (make-wire))
> (define d (make-wire))
> (define e (make-wire))
> (define s (make-wire))
> 
> (or-gate a b d)
> (and-gate a b c)
> (inverter c e)
> (and-gate d e s)
> 
> 
> ;{
> ;;; Sample simulation
> 
> ;: (define the-agenda (make-agenda))
> ;: (define inverter-delay 2)
> ;: (define and-gate-delay 3)
> ;: (define or-gate-delay 5)
> ;: 
> ;: (define input-1 (make-wire))
> ;: (define input-2 (make-wire))
> ;: (define sum (make-wire))
> ;: (define carry (make-wire))
> ;: 
> ;: (probe 'sum sum)
> ;: (probe 'carry carry)
> ;: 
> ;: (half-adder input-1 input-2 sum carry)
> ;: (set-signal! input-1 1)
> ;: (propagate)
> ;: 
> ;: (set-signal! input-2 1)
> ;: (propagate)
> 
> 
> ;; EXERCISE 3.31
> ;: (define (accept-action-procedure! proc)
> ;:   (set! 'action-procedures (cons proc action-procedures)))
> 
> 
> ;;;Implementing agenda
> 
> (define (make-time-segment time queue)
>   (cons time queue))
> (define (segment-time s) (car s))
> (define (segment-queue s) (cdr s))
> 
> (define (make-agenda) (list 0))
> 
> (define (current-time agenda) (car agenda))
> (define (set-current-time! agenda time)
>   (set-car! agenda time))
> 
> (define (segments agenda) (cdr agenda))
> (define (set-segments! agenda segments)
>   (set-cdr! agenda segments))
> (define (first-segment agenda) (car (segments agenda)))
> (define (rest-segments agenda) (cdr (segments agenda)))
> 
> (define (empty-agenda? agenda)
>   (null? (segments agenda)))
> 
> (define (add-to-agenda! time action agenda)
>   (define (belongs-before? segments)
>     (or (null? segments)
>         (< time (segment-time (car segments)))))
>   (define (make-new-time-segment time action)
>     (let ((q (make-queue)))
>       (insert-queue! q action)
>       (make-time-segment time q)))
>   (define (add-to-segments! segments)
>     (if (= (segment-time (car segments)) time)
>         (insert-queue! (segment-queue (car segments))
>                        action)
>         (let ((rest (cdr segments)))
>           (if (belongs-before? rest)
>               (set-cdr!
>                segments
>                (cons (make-new-time-segment time action)
>                      (cdr segments)))
>               (add-to-segments! rest)))))
>   (let ((segments (segments agenda)))
>     (if (belongs-before? segments)
>         (set-segments!
>          agenda
>          (cons (make-new-time-segment time action)
>                segments))
>         (add-to-segments! segments))))
> 
> (define (remove-first-agenda-item! agenda)
>   (let ((q (segment-queue (first-segment agenda))))
>     (delete-queue! q)
>     (if (empty-queue? q)
>         (set-segments! agenda (rest-segments agenda)))))
> 
> (define (first-agenda-item agenda)
>   (if (empty-agenda? agenda)
>       (error "Agenda is empty -- FIRST-AGENDA-ITEM")
>       (let ((first-seg (first-segment agenda)))
>         (set-current-time! agenda (segment-time first-seg))
>         (front-queue (segment-queue first-seg)))))
> 
> 
> ;;;SECTION 3.3.5
> 
> ;: (define C (make-connector))
> ;: (define F (make-connector))
> ;: (celsius-fahrenheit-converter C F)
> 
> (define (celsius-fahrenheit-converter c f)
>   (let ((u (make-connector))
>         (v (make-connector))
>         (w (make-connector))
>         (x (make-connector))
>         (y (make-connector)))
>     (multiplier c w u)
>     (multiplier v x u)
>     (adder v y f)
>     (constant 9 w)
>     (constant 5 x)
>     (constant 32 y)
>     'ok))
> 
> ;: (probe "Celsius temp" C)
> ;: (probe "Fahrenheit temp" F)
> ;: (set-value! C 25 'user)
> ;: (set-value! F 212 'user)
> ;: (forget-value! C 'user)
> ;: (set-value! F 212 'user)
> 
> 
> (define (adder a1 a2 sum)
>   (define (process-new-value)
>     (cond ((and (has-value? a1) (has-value? a2))
>            (set-value! sum
>                        (+ (get-value a1) (get-value a2))
>                        me))
>           ((and (has-value? a1) (has-value? sum))
>            (set-value! a2
>                        (- (get-value sum) (get-value a1))
>                        me))
>           ((and (has-value? a2) (has-value? sum))
>            (set-value! a1
>                        (- (get-value sum) (get-value a2))
>                        me))))
>   (define (process-forget-value)
>     (forget-value! sum me)
>     (forget-value! a1 me)
>     (forget-value! a2 me)
>     (process-new-value))
>   (define (me request)
>     (cond ((eq? request 'I-have-a-value)  
>            (process-new-value))
>           ((eq? request 'I-lost-my-value) 
>            (process-forget-value))
>           (else 
>            (error "Unknown request -- ADDER" request))))
>   (connect a1 me)
>   (connect a2 me)
>   (connect sum me)
>   me)
> 
> (define (inform-about-value constraint)
>   (constraint 'I-have-a-value))
> 
> (define (inform-about-no-value constraint)
>   (constraint 'I-lost-my-value))
> 
> (define (multiplier m1 m2 product)
>   (define (process-new-value)
>     (cond ((or (and (has-value? m1) (= (get-value m1) 0))
>                (and (has-value? m2) (= (get-value m2) 0)))
>            (set-value! product 0 me))
>           ((and (has-value? m1) (has-value? m2))
>            (set-value! product
>                        (* (get-value m1) (get-value m2))
>                        me))
>           ((and (has-value? product) (has-value? m1))
>            (set-value! m2
>                        (/ (get-value product) (get-value m1))
>                        me))
>           ((and (has-value? product) (has-value? m2))
>            (set-value! m1
>                        (/ (get-value product) (get-value m2))
>                        me))))
>   (define (process-forget-value)
>     (forget-value! product me)
>     (forget-value! m1 me)
>     (forget-value! m2 me)
>     (process-new-value))
>   (define (me request)
>     (cond ((eq? request 'I-have-a-value)
>            (process-new-value))
>           ((eq? request 'I-lost-my-value)
>            (process-forget-value))
>           (else
>            (error "Unknown request -- MULTIPLIER" request))))
>   (connect m1 me)
>   (connect m2 me)
>   (connect product me)
>   me)
> 
> (define (constant value connector)
>   (define (me request)
>     (error "Unknown request -- CONSTANT" request))
>   (connect connector me)
>   (set-value! connector value me)
>   me)
> 
> (define (probe name connector)
>   (define (print-probe value)
>     (newline)
>     (display "Probe: ")
>     (display name)
>     (display " = ")
>     (display value))
>   (define (process-new-value)
>     (print-probe (get-value connector)))
>   (define (process-forget-value)
>     (print-probe "?"))
>   (define (me request)
>     (cond ((eq? request 'I-have-a-value)
>            (process-new-value))
>           ((eq? request 'I-lost-my-value)
>            (process-forget-value))
>           (else
>            (error "Unknown request -- PROBE" request))))
>   (connect connector me)
>   me)
> 
> (define (make-connector)
>   (let ((value false) (informant false) (constraints '()))
>     (define (set-my-value newval setter)
>       (cond ((not (has-value? me))
>              (set! 'value newval)
>              (set! 'informant setter)
>              (for-each-except setter
>                               inform-about-value
>                               constraints))
>             ((not (= value newval))
>              (error "Contradiction" (list value newval)))
>             (else 'ignored)))
>     (define (forget-my-value retractor)
>       (if (eq? retractor informant)
>           (begin (set! 'informant false)
>                  (for-each-except retractor
>                                   inform-about-no-value
>                                   constraints))
>           'ignored))
>     (define (connect new-constraint)
>       (if (not (memq new-constraint constraints))
>           (set! 'constraints 
>                 (cons new-constraint constraints)))
>       (if (has-value? me)
>           (inform-about-value new-constraint))
>       'done)
>     (define (me request)
>       (cond ((eq? request 'has-value?)
>              (if informant true false))
>             ((eq? request 'value) value)
>             ((eq? request 'set-value!) set-my-value)
>             ((eq? request 'forget) forget-my-value)
>             ((eq? request 'connect) connect)
>             (else (error "Unknown operation -- CONNECTOR"
>                          request))))
>     me))
> 
> (define (for-each-except exception procedure list)
>   (define (loop items)
>     (cond ((null? items) 'done)
>           ((eq? (car items) exception) (loop (cdr items)))
>           (else (procedure (car items))
>                 (loop (cdr items)))))
>   (loop list))
> 
> (define (has-value? connector)
>   (connector 'has-value?))
> 
> (define (get-value connector)
>   (connector 'value))
> 
> (define (set-value! connector new-value informant)
>   ((connector 'set-value!) new-value informant))
> 
> (define (forget-value! connector retractor)
>   ((connector 'forget) retractor))
> 
> (define (connect connector new-constraint)
>   ((connector 'connect) new-constraint))
> 
> 
> ;; EXERCISE 3.34
> 
> (define (squarer a b)
>   (multiplier a a b))
> 
> 
> 
> ;; EXERCISE 3.36
> ;: (define a (make-connector))
> ;: (define b (make-connector))
> ;: (set-value! a 10 'user)
> 
> 
> ;; EXERCISE 3.37
> 
> (define (celsius-fahrenheit-converter x)
>   (c+ (c* (c/ (cv 9) (cv 5))
>           x)
>       (cv 32)))
> 
> ;: (define C (make-connector))
> ;: (define F (celsius-fahrenheit-converter C))
> 
> (define (c+ x y)
>   (let ((z (make-connector)))
>     (adder x y z)
>     z))
> 
> 
> ;;;SECTION 3.4
> ;;;**Need parallel-execute, available for MIT Scheme
> 
> ;;;SECTION 3.4.1
> 
> (define (withdraw amount)
>   (if (>= balance amount)
>       (begin (set! 'balance (- balance amount))
>              balance)
>       "Insufficient funds"))
> 
> 
> ;; EXERCISE 3.38
> ;: (set! 'balance (+ balance 10))
> ;: (set! 'balance (- balance 20))
> ;: (set! 'balance (- balance (/ balance 2)))
> 
> 
> ;;;SECTION 3.4.2
> 
> ;: (define x 10)
> ;: (parallel-execute (lambda () (set! 'x (* x x)))
> ;:                   (lambda () (set! 'x (+ x 1))))
> 
> ;: (define x 10)
> ;: (define s (make-serializer))
> ;: (parallel-execute (s (lambda () (set! 'x (* x x))))
> ;:                   (s (lambda () (set! 'x (+ x 1)))))
> 
> 
> (define (make-account balance)
>   (define (withdraw amount)
>     (if (>= balance amount)
>         (begin (set! 'balance (- balance amount))
>                balance)
>         "Insufficient funds"))
>   (define (deposit amount)
>     (set! 'balance (+ balance amount))
>     balance)
>   (let ((protected (make-serializer)))
>     (define (dispatch m)
>       (cond ((eq? m 'withdraw) (protected withdraw))
>             ((eq? m 'deposit) (protected deposit))
>             ((eq? m 'balance) balance)
>             (else (error "Unknown request -- MAKE-ACCOUNT"
>                          m))))
>     dispatch))
> 
> 
> ;; EXERCISE 3.39
> 
> ;: (define x 10)
> ;: (define s (make-serializer))
> ;: (parallel-execute (lambda () (set! 'x ((s (lambda () (* x x))))))
> ;:                   (s (lambda () (set! 'x (+ x 1)))))
> 
> 
> ;; EXERCISE 3.40
> 
> ;: (define x 10)
> ;: (parallel-execute (lambda () (set! 'x (* x x)))
> ;:                   (lambda () (set! 'x (* x x x))))
> ;: 
> ;: 
> ;: (define x 10)
> ;: (define s (make-serializer))
> ;: (parallel-execute (s (lambda () (set! 'x (* x x))))
> ;:                   (s (lambda () (set! 'x (* x x x)))))
> 
> 
> ;; EXERCISE 3.41
> 
> (define (make-account balance)
>   (define (withdraw amount)
>     (if (>= balance amount)
>         (begin (set! 'balance (- balance amount))
>                balance)
>         "Insufficient funds"))
>   (define (deposit amount)
>     (set! 'balance (+ balance amount))
>     balance)
>   (let ((protected (make-serializer)))
>     (define (dispatch m)
>       (cond ((eq? m 'withdraw) (protected withdraw))
>             ((eq? m 'deposit) (protected deposit))
>             ((eq? m 'balance)
>              ((protected (lambda () balance))))
>             (else (error "Unknown request -- MAKE-ACCOUNT"
>                          m))))
>     dispatch))
> 
> ;; EXERCISE 3.42
> 
> (define (make-account balance)
>   (define (withdraw amount)
>     (if (>= balance amount)
>         (begin (set! 'balance (- balance amount))
>                balance)
>         "Insufficient funds"))
>   (define (deposit amount)
>     (set! 'balance (+ balance amount))
>     balance)
>   (let ((protected (make-serializer)))
>     (let ((protected-withdraw (protected withdraw))
>           (protected-deposit (protected deposit)))
>       (define (dispatch m)
>         (cond ((eq? m 'withdraw) protected-withdraw)
>               ((eq? m 'deposit) protected-deposit)
>               ((eq? m 'balance) balance)
>               (else (error "Unknown request -- MAKE-ACCOUNT"
>                            m))))
>       dispatch)))
> 
> ;;;Multiple shared resources
> 
> (define (exchange account1 account2)
>   (let ((difference (- (account1 'balance)
>                        (account2 'balance))))
>     ((account1 'withdraw) difference)
>     ((account2 'deposit) difference)))
> 
> (define (make-account-and-serializer balance)
>   (define (withdraw amount)
>     (if (>= balance amount)
>         (begin (set! 'balance (- balance amount))
>                balance)
>         "Insufficient funds"))
>   (define (deposit amount)
>     (set! 'balance (+ balance amount))
>     balance)
>   (let ((balance-serializer (make-serializer)))
>     (define (dispatch m)
>       (cond ((eq? m 'withdraw) withdraw)
>             ((eq? m 'deposit) deposit)
>             ((eq? m 'balance) balance)
>             ((eq? m 'serializer) balance-serializer)
>             (else (error "Unknown request -- MAKE-ACCOUNT"
>                          m))))
>     dispatch))
> 
> 
> (define (deposit account amount)
>   (let ((s (account 'serializer))
>         (d (account 'deposit)))
>     ((s d) amount)))
> 
> (define (serialized-exchange account1 account2)
>   (let ((serializer1 (account1 'serializer))
>         (serializer2 (account2 'serializer)))
>     ((serializer1 (serializer2 exchange))
>      account1
>      account2)))
> 
> 
> ;; EXERCISE 3.44
> 
> (define (transfer from-account to-account amount)
>   ((from-account 'withdraw) amount)
>   ((to-account 'deposit) amount))
> 
> 
> ;; EXERCISE 3.45
> 
> (define (make-account-and-serializer balance)
>   (define (withdraw amount)
>     (if (>= balance amount)
>         (begin (set! 'balance (- balance amount))
>                balance)
>         "Insufficient funds"))
>   (define (deposit amount)
>     (set! 'balance (+ balance amount))
>     balance)
>   (let ((balance-serializer (make-serializer)))
>     (define (dispatch m)
>       (cond ((eq? m 'withdraw) (balance-serializer withdraw))
>             ((eq? m 'deposit) (balance-serializer deposit))
>             ((eq? m 'balance) balance)
>             ((eq? m 'serializer) balance-serializer)
>             (else (error "Unknown request -- MAKE-ACCOUNT"
>                          m))))
>     dispatch))
> 
> (define (deposit account amount)
>  ((account 'deposit) amount))
> 
> 
> ;;;Implementing serializers
> 
> (define (make-serializer)
>   (let ((mutex (make-mutex)))
>     (lambda (p)
>       (define (serialized-p . args)
>         (mutex 'acquire)
>         (let ((val (apply p args)))
>           (mutex 'release)
>           val))
>       serialized-p)))
> 
> (define (make-mutex)
>   (let ((cell (list false)))            
>     (define (the-mutex m)
>       (cond ((eq? m 'acquire)
>              (if (test-and-set! cell)
>                  (the-mutex 'acquire)))
>             ((eq? m 'release) (clear! cell))))
>     the-mutex))
> 
> (define (clear! cell)
>   (set-car! cell false))
> 
> (define (test-and-set! cell)
>   (if (car cell)
>       true
>       (begin (set-car! cell true)
>              false)))
> 
> ;;from footnote -- MIT Scheme
> (define (test-and-set! cell)
>   (without-interrupts
>    (lambda ()
>      (if (car cell)
>          true
>          (begin (set-car! cell true)
>                 false)))))
> 
> ;;;SECTION 3.5
> 
> (define (stream-map proc . argstreams)
>   (if (<??> (car argstreams))
>       the-empty-stream
>       (<??>
>        (apply proc (map <??> argstreams))
>        (apply stream-map
>               (cons proc (map <??> argstreams))))))
> 
> ;;;SECTION 3.5.1
> 
> (define (sum-primes a b)
>   (define (iter count accum)
>     (cond ((> count b) accum)
>           ((prime? count) (iter (+ count 1) (+ count accum)))
>           (else (iter (+ count 1) accum))))
>   (iter a 0))
> 
> 
> (define (sum-primes a b)
>   (accumulate +
>               0
>               (filter prime? (enumerate-interval a b))))
> 
> ;: (car (cdr (filter prime?
> ;:                   (enumerate-interval 10000 1000000))))
> 
> (define (stream-ref s n)
>   (if (= n 0)
>       (stream-car s)
>       (stream-ref (stream-cdr s) (- n 1))))
> 
> (define (stream-map proc s)
>   (if (stream-null? s)
>       the-empty-stream
>       (cons-stream (proc (stream-car s))
>                    (stream-map proc (stream-cdr s)))))
> 
> (define (stream-for-each proc s)
>   (if (stream-null? s)
>       'done
>       (begin (proc (stream-car s))
>              (stream-for-each proc (stream-cdr s)))))
> 
> (define (display-stream s)
>   (stream-for-each display-line s))
> 
> (define (display-line x)
>   (newline)
>   (display x))
> 
> 
> 
> ;; stream-car and stream-cdr would normally be built into
> ;;  the stream implementation
> ;: (define (stream-car stream) (car stream))
> ;: (define (stream-cdr stream) (force (cdr stream)))
> 
> ;: (stream-car
> ;:  (stream-cdr
> ;:   (stream-filter prime?
> ;:                  (stream-enumerate-interval 10000 1000000))))
> 
> (define (stream-enumerate-interval low high)
>   (if (> low high)
>       the-empty-stream
>       (cons-stream
>        low
>        (stream-enumerate-interval (+ low 1) high))))
> 
> (define (stream-filter pred stream)
>   (cond ((stream-null? stream) the-empty-stream)
>         ((pred (stream-car stream))
>          (cons-stream (stream-car stream)
>                       (stream-filter pred
>                                      (stream-cdr stream))))
>         (else (stream-filter pred (stream-cdr stream)))))
> 
> 
> ;; force would normally be built into
> ;;  the stream implementation
> ;: (define (force delayed-object)
> ;:   (delayed-object))
> 
> (define (memo-proc proc)
>   (let ((already-run? false) (result false))
>     (lambda ()
>       (if (not already-run?)
>           (begin (set! 'result (proc))
>                  (set! 'already-run? true)
>                  result)
>           result))))
> 
> 
> ;; EXERCISE 3.51
> 
> (define (show x)
>   (display-line x)
>   x)
> 
> ;: (define x (stream-map show (stream-enumerate-interval 0 10)))
> ;: (stream-ref x 5)
> ;: (stream-ref x 7)
> 
> 
> ;; EXERCISE 3.52
> 
> (define sum 0)
> 
> (define (accum x)
>   (set! 'sum (+ x sum))
>   sum)
> 
> ;: (define seq (stream-map accum (stream-enumerate-interval 1 20)))
> ;: (define y (stream-filter even? seq))
> ;: (define z (stream-filter (lambda (x) (= (remainder x 5) 0))
> ;:                          seq))
> 
> ;: (stream-ref y 7)
> ;: (display-stream z)
> 
> 
> ;;;SECTION 3.5.2
> 
> (define (integers-starting-from n)
>   (cons-stream n (integers-starting-from (+ n 1))))
> 
> (define integers (integers-starting-from 1))
> 
> (define (divisible? x y) (= (remainder x y) 0))
> 
> (define no-sevens
>   (stream-filter (lambda (x) (not (divisible? x 7)))
>                  integers))
> 
> ;: (stream-ref no-sevens 100)
> 
> (define (fibgen a b)
>   (cons-stream a (fibgen b (+ a b))))
> 
> (define fibs (fibgen 0 1))
> 
> (define (sieve stream)
>   (cons-stream
>    (stream-car stream)
>    (sieve (stream-filter
>            (lambda (x)
>              (not (divisible? x (stream-car stream))))
>            (stream-cdr stream)))))
> 
> (define primes (sieve (integers-starting-from 2)))
> 
> ;: (stream-ref primes 50)
> 
> 
> ;;;Defining streams implicitly;;;Defining streams implicitly
> 
> (define ones (cons-stream 1 ones))
> 
> (define (add-streams s1 s2)
>   (stream-map + s1 s2))
> 
> (define integers (cons-stream 1 (add-streams ones integers)))
> 
> (define fibs
>   (cons-stream 0
>                (cons-stream 1
>                             (add-streams (stream-cdr fibs)
>                                          fibs))))
> 
> (define (scale-stream stream factor)
>   (stream-map (lambda (x) (* x factor)) stream))
> 
> (define double (cons-stream 1 (scale-stream double 2)))
> 
> (define primes
>   (cons-stream
>    2
>    (stream-filter prime? (integers-starting-from 3))))
> 
> (define (prime? n)
>   (define (iter ps)
>     (cond ((> (square (stream-car ps)) n) true)
>           ((divisible? n (stream-car ps)) false)
>           (else (iter (stream-cdr ps)))))
>   (iter primes))
> 
> 
> ;; EXERCISE 3.53
> ;: (define s (cons-stream 1 (add-streams s s)))
> 
> 
> ;; EXERCISE 3.56
> (define (merge s1 s2)
>   (cond ((stream-null? s1) s2)
>         ((stream-null? s2) s1)
>         (else
>          (let ((s1car (stream-car s1))
>                (s2car (stream-car s2)))
>            (cond ((< s1car s2car)
>                   (cons-stream s1car (merge (stream-cdr s1) s2)))
>                  ((> s1car s2car)
>                   (cons-stream s2car (merge s1 (stream-cdr s2))))
>                  (else
>                   (cons-stream s1car
>                                (merge (stream-cdr s1)
>                                       (stream-cdr s2)))))))))
> 
> 
> ;; EXERCISE 3.58
> (define (expand num den radix)
>   (cons-stream
>    (quotient (* num radix) den)
>    (expand (remainder (* num radix) den) den radix)))
> 
> 
> ;; EXERCISE 3.59
> ;: (define exp-series
> ;:   (cons-stream 1 (integrate-series exp-series)))
> 
> 
> ;;;SECTION 3.5.3
> 
> (define (sqrt-improve guess x)
>   (average guess (/ x guess)))
> 
> 
> (define (sqrt-stream x)
>   (define guesses
>     (cons-stream 1.0
>                  (stream-map (lambda (guess)
>                                (sqrt-improve guess x))
>                              guesses)))
>   guesses)
> 
> ;: (display-stream (sqrt-stream 2))
> 
> 
> (define (pi-summands n)
>   (cons-stream (/ 1.0 n)
>                (stream-map - (pi-summands (+ n 2)))))
> 
> ;: (define pi-stream
> ;:   (scale-stream (partial-sums (pi-summands 1)) 4))
> 
> ;: (display-stream pi-stream)
> 
> 
> (define (euler-transform s)
>   (let ((s0 (stream-ref s 0))
>         (s1 (stream-ref s 1))    
>         (s2 (stream-ref s 2)))
>     (cons-stream (- s2 (/ (square (- s2 s1))
>                           (+ s0 (* -2 s1) s2)))
>                  (euler-transform (stream-cdr s)))))
> 
> ;: (display-stream (euler-transform pi-stream))
> 
> 
> (define (make-tableau transform s)
>   (cons-stream s
>                (make-tableau transform
>                              (transform s))))
> 
> (define (accelerated-sequence transform s)
>   (stream-map stream-car
>               (make-tableau transform s)))
> 
> ;: (display-stream (accelerated-sequence euler-transform
> ;:                                       pi-stream))
> 
> 
> ;; EXERCISE 3.63
> (define (sqrt-stream x)
>   (cons-stream 1.0
>                (stream-map (lambda (guess)
>                              (sqrt-improve guess x))
>                            (sqrt-stream x))))
> 
> ;; EXERCISE 3.64
> (define (sqrt x tolerance)
>   (stream-limit (sqrt-stream x) tolerance))
> 
> 
> ;;; Infinite streams of pairs
> 
> ;: (stream-filter (lambda (pair)
> ;:                  (prime? (+ (car pair) (cadr pair))))
> ;:                int-pairs)
> 
> (define (stream-append s1 s2)
>   (if (stream-null? s1)
>       s2
>       (cons-stream (stream-car s1)
>                    (stream-append (stream-cdr s1) s2))))
> 
> 
> ;: (pairs integers integers)
> 
> 
> (define (interleave s1 s2)
>   (if (stream-null? s1)
>       s2
>       (cons-stream (stream-car s1)
>                    (interleave s2 (stream-cdr s1)))))
> 
> (define (pairs s t)
>   (cons-stream
>    (list (stream-car s) (stream-car t))
>    (interleave
>     (stream-map (lambda (x) (list (stream-car s) x))
>                 (stream-cdr t))
>     (pairs (stream-cdr s) (stream-cdr t)))))
> 
> 
> ;; EXERCISE 3.68
> 
> (define (pairs s t)
>   (interleave
>    (stream-map (lambda (x) (list (stream-car s) x))
>                t)
>    (pairs (stream-cdr s) (stream-cdr t))))
> 
> 
> ;;; Streams as signals
> 
> (define (integral integrand initial-value dt)
>   (define int
>     (cons-stream initial-value
>                  (add-streams (scale-stream integrand dt)
>                               int)))
>   int)
> 
> 
> ;; EXERCISE 3.74
> 
> (define (make-zero-crossings input-stream last-value)
>   (cons-stream
>    (sign-change-detector (stream-car input-stream) last-value)
>    (make-zero-crossings (stream-cdr input-stream)
>                         (stream-car input-stream))))
> 
> ;: (define zero-crossings (make-zero-crossings sense-data 0))
> 
> 
> 
> ;; EXERCISE 3.75
> 
> (define (make-zero-crossings input-stream last-value)
>   (let ((avpt (/ (+ (stream-car input-stream) last-value) 2)))
>     (cons-stream (sign-change-detector avpt last-value)
>                  (make-zero-crossings (stream-cdr input-stream)
>                                       avpt))))
> 
> 
> ;;;SECTION 3.5.4
> 
> (define (solve f y0 dt)
>   (define y (integral dy y0 dt))
>   (define dy (stream-map f y))
>   y)
> 
> (define (integral delayed-integrand initial-value dt)
>   (define int
>     (cons-stream initial-value
>                  (let ((integrand (force delayed-integrand)))
>                    (add-streams (scale-stream integrand dt)
>                                 int))))
>   int)
> 
> (define (solve f y0 dt)
>   (define y (integral (delay dy) y0 dt))
>   (define dy (stream-map f y))
>   y)
> 
> 
> ;: (stream-ref (solve (lambda (y) y) 1 0.001) 1000)
> 
> 
> ;; EXERCISE 3.77
> 
> (define (integral integrand initial-value dt)
>   (cons-stream initial-value
>                (if (stream-null? integrand)
>                    the-empty-stream
>                    (integral (stream-cdr integrand)
>                              (+ (* dt (stream-car integrand))
>                                 initial-value)
>                              dt))))
> 
> ;;;SECTION 3.5.5
> 
> ;; same as in section 3.1.2
> (define rand
>   (let ((x random-init))
>     (lambda ()
>       (set! 'x (rand-update x))
>       x)))
> 
> 
> (define random-numbers
>   (cons-stream random-init
>                (stream-map rand-update random-numbers)))
> 
> 
> ;: (define cesaro-stream
> ;:   (map-successive-pairs (lambda (r1 r2) (= (gcd r1 r2) 1))
> ;:                         random-numbers))
> 
> (define (map-successive-pairs f s)
>   (cons-stream
>    (f (stream-car s) (stream-car (stream-cdr s)))
>    (map-successive-pairs f (stream-cdr (stream-cdr s)))))
> 
> 
> (define (monte-carlo experiment-stream passed failed)
>   (define (next passed failed)
>     (cons-stream
>      (/ passed (+ passed failed))
>      (monte-carlo
>       (stream-cdr experiment-stream) passed failed)))
>   (if (stream-car experiment-stream)
>       (next (+ passed 1) failed)
>       (next passed (+ failed 1))))
> 
> ;: (define pi
> ;:   (stream-map (lambda (p) (sqrt (/ 6 p)))
> ;:               (monte-carlo cesaro-stream 0 0)))
> 
> 
> ;; same as in section 3.1.3
> (define (make-simplified-withdraw balance)
>   (lambda (amount)
>     (set! 'balance (- balance amount))
>     balance))
> 
> (define (stream-withdraw balance amount-stream)
>   (cons-stream
>    balance
>    (stream-withdraw (- balance (stream-car amount-stream))
>                     (stream-cdr amount-stream))))
> ;}
> 
> )) ;end of items
> 
> (define (process items #)
>     (define old-car car)
>     (define old-cdr cdr)
>     (define (iter items)
>         (cond
>             ((null? items) 'done)
>             (else
>                 (define result (eval (old-car items) #))
>                 (println (old-car items) " is " result)
>                 ;(inspect (stack-depth))
>                 (iter (old-cdr items))
>                 )
>             )
>         )
>     (iter items)
>     )
> 
> (process items)
> 
> ------------------------------------------
> (define balance 100) is 100
> (define (withdraw amount) (if (>= balance amount) (begin (set! (quote balance) (- balance amount)) balance) "Insufficient funds")) is <function withdraw(amount)>
> (define new-withdraw (let ((balance 100)) <lambda ((nil 0 nil <object 64> ["ORBIT_SOCKETDIR=/tmp/orbit-lusth","SSH_AGENT_PID=1323","SHELL=/bin/bash","TERM=xterm","XDG_SESSION_COOKIE=dc80d65daba271e709a4e90b00000009-1316202786.634674-1575432060","WINDOWID=52448343","GNOME_KEYRING_CONTROL=/tmp/keyring-hiWWAO","GTK_MODULES=canberra-gtk-module","USER=lusth","LS_COLORS=rs=0:di=01;34:ln=01;36:mh=00:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:su=37;41:sg=30;43:ca=30;41:tw=30;42:ow=34;42:st=37;44:ex=01;32:*.tar=01;31:*.tgz=01;31:*.arj=01;31:*.taz=01;31:*.lzh=01;31:*.lzma=01;31:*.tlz=01;31:*.txz=01;31:*.zip=01;31:*.z=01;31:*.Z=01;31:*.dz=01;31:*.gz=01;31:*.lz=01;31:*.xz=01;31:*.bz2=01;31:*.bz=01;31:*.tbz=01;31:*.tbz2=01;31:*.tz=01;31:*.deb=01;31:*.rpm=01;31:*.jar=01;31:*.rar=01;31:*.ace=01;31:*.zoo=01;31:*.cpio=01;31:*.7z=01;31:*.rz=01;31:*.jpg=01;35:*.jpeg=01;35:*.gif=01;35:*.bmp=01;35:*.pbm=01;35:*.pgm=01;35:*.ppm=01;35:*.tga=01;35:*.xbm=01;35:*.xpm=01;35:*.tif=01;35:*.tiff=01;35:*.png=01;35:*.svg=01;35:*.svgz=01;35:*.mng=01;35:*.pcx=01;35:*.mov=01;35:*.mpg=01;35:*.mpeg=01;35:*.m2v=01;35:*.mkv=01;35:*.ogm=01;35:*.mp4=01;35:*.m4v=01;35:*.mp4v=01;35:*.vob=01;35:*.qt=01;35:*.nuv=01;35:*.wmv=01;35:*.asf=01;35:*.rm=01;35:*.rmvb=01;35:*.flc=01;35:*.avi=01;35:*.fli=01;35:*.flv=01;35:*.gl=01;35:*.dl=01;35:*.xcf=01;35:*.xwd=01;35:*.yuv=01;35:*.cgm=01;35:*.emf=01;35:*.axv=01;35:*.anx=01;35:*.ogv=01;35:*.ogx=01;35:*.aac=00;36:*.au=00;36:*.flac=00;36:*.mid=00;36:*.midi=00;36:*.mka=00;36:*.mp3=00;36:*.mpc=00;36:*.ogg=00;36:*.ra=00;36:*.wav=00;36:*.axa=00;36:*.oga=00;36:*.spx=00;36:*.xspf=00;36:","SSH_AUTH_SOCK=/tmp/keyring-hiWWAO/ssh","DEFAULTS_PATH=/usr/share/gconf/gnome-classic.default.path","USERNAME=lusth","SESSION_MANAGER=local/goblin:@/tmp/.ICE-unix/1290,unix/goblin:/tmp/.ICE-unix/1290","XDG_CONFIG_DIRS=/etc/xdg/xdg-gnome-classic:/etc/xdg","DESKTOP_SESSION=gnome-classic","PATH=/home/lusth/bin:/home/lusth/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/home/lusth/android/tools:/home/lusth/android/platform-tools:.","PWD=/home/lusth/scam/testing","GDM_KEYBOARD_LAYOUT=us","EDITOR=vim","LANG=en_US.UTF-8","GNOME_KEYRING_PID=1271","MANDATORY_PATH=/usr/share/gconf/gnome-classic.mandatory.path","GDM_LANG=en_US.utf8","UBUNTU_MENUPROXY=libappmenu.so","GDMSESSION=gnome-classic","HOME=/home/lusth","SHLVL=2","LANGUAGE=en_US:en","GNOME_DESKTOP_SESSION_ID=this-is-deprecated","LOGNAME=lusth","DBUS_SESSION_BUS_ADDRESS=unix:abstract=/tmp/dbus-E58H1584u0,guid=18338084dae6f82274bd6d1f00000023","XDG_DATA_DIRS=/usr/share/gnome-classic:/usr/share/gnome:/usr/local/share/:/usr/share/","LESSOPEN=| /usr/bin/lesspipe %s","WINDOWPATH=7","DISPLAY=:0.0","LESSCLOSE=/usr/bin/lesspipe %s %s","XAUTHORITY=/var/run/gdm/auth-for-lusth-WKYjxG/database","COLORTERM=gnome-terminal","_=/home/lusth/bin/scam"] ["scam","sicp3.s"] <builtIn fileName(item)> <builtIn lineNumber(item)> <builtIn stack-depth()> <builtIn set-cdr!(spot value)> <builtIn set-car!(spot value)> <builtIn set(id value # @)> <builtIn get(id # @)> <builtIn !=(@)> <builtIn =(@)> <builtIn neq?(@)> <builtIn ==(@)> <builtIn eq?(@)> <builtIn >=(@)> <builtIn >(@)> <builtIn <=(@)> <builtIn <(@)> <builtIn not(value)> <builtIn address(item)> <builtIn while(# $test $)> <builtIn if(# test $then $)> <builtIn cond(# $)> <builtIn lambda(# $params $)> <builtIn quote($item)> <builtIn expt(base exponent)> <builtIn atan(y x)> <builtIn cos(n)> <builtIn sin(n)> <builtIn log(n)> <builtIn exp(n)> <builtIn %(@)> <builtIn /(@)> <builtIn *(@)> <builtIn -(@)> <builtIn +(@)> <builtIn pp(a)> <builtIn fmt(format value)> <builtIn display(item)> <builtIn addSymbol(name init env)> <builtIn define(# $)> <builtIn return(# $item)> <builtIn begin(# $)> <builtIn scope(# $)> <builtIn inspect(# $expr)> <builtIn apply(f args)> <builtIn eval(expr context)> <builtIn include(# $fileName)> <builtIn list(@)> <builtIn list?(item)> <builtIn pair?(item)> <builtIn null?(item)> <builtIn type(item)> <builtIn car(items)> <builtIn cdr(items)> <builtIn cons(a b)> <builtIn gensym?(id)> <builtIn gensym(@)> <builtIn eof?(#)> <builtIn close(port)> <builtIn getInputPort(#)> <builtIn getOutputPort(#)> <builtIn setPort(port)> <builtIn open(name mode)> <builtIn pushBack(string)> <builtIn readUntil(string)> <builtIn readWhile(string)> <builtIn readLine(#)> <builtIn readToken(#)> <builtIn readString(#)> <builtIn readReal(#)> <builtIn readInt(#)> <builtIn readRawChar(#)> <builtIn readChar(#)> <builtIn time()> <builtIn exec(str)> <builtIn system(str)> <builtIn bindings(object)> <builtIn array(@)> <builtIn allocate(size)> <builtIn length(item)> <builtIn setElement(item index value)> <builtIn getElement(item index)> <builtIn symbol(str)> <builtIn throw(code @)> <builtIn catch(# $expr)> <builtIn string(item)> <builtIn real(item)> <builtIn int(item)> <builtIn ascii(str)> <builtIn trim(str)> <builtIn substring(needle haystack)> <builtIn stringWhile(str chars)> <builtIn stringUntil(expr chars)> <builtIn suffix(str size)> <builtIn prefix(str size)> <builtIn string-equal?(a b)> <builtIn string+(a b)> <builtIn gc()>) . "nsufficient funds")>)) is <function anonymous(amount)>
> (define (make-withdraw balance) <lambda ((nil 0 nil <object 64> ["ORBIT_SOCKETDIR=/tmp/orbit-lusth","SSH_AGENT_PID=1323","SHELL=/bin/bash","TERM=xterm","XDG_SESSION_COOKIE=dc80d65daba271e709a4e90b00000009-1316202786.634674-1575432060","WINDOWID=52448343","GNOME_KEYRING_CONTROL=/tmp/keyring-hiWWAO","GTK_MODULES=canberra-gtk-module","USER=lusth","LS_COLORS=rs=0:di=01;34:ln=01;36:mh=00:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:su=37;41:sg=30;43:ca=30;41:tw=30;42:ow=34;42:st=37;44:ex=01;32:*.tar=01;31:*.tgz=01;31:*.arj=01;31:*.taz=01;31:*.lzh=01;31:*.lzma=01;31:*.tlz=01;31:*.txz=01;31:*.zip=01;31:*.z=01;31:*.Z=01;31:*.dz=01;31:*.gz=01;31:*.lz=01;31:*.xz=01;31:*.bz2=01;31:*.bz=01;31:*.tbz=01;31:*.tbz2=01;31:*.tz=01;31:*.deb=01;31:*.rpm=01;31:*.jar=01;31:*.rar=01;31:*.ace=01;31:*.zoo=01;31:*.cpio=01;31:*.7z=01;31:*.rz=01;31:*.jpg=01;35:*.jpeg=01;35:*.gif=01;35:*.bmp=01;35:*.pbm=01;35:*.pgm=01;35:*.ppm=01;35:*.tga=01;35:*.xbm=01;35:*.xpm=01;35:*.tif=01;35:*.tiff=01;35:*.png=01;35:*.svg=01;35:*.svgz=01;35:*.mng=01;35:*.pcx=01;35:*.mov=01;35:*.mpg=01;35:*.mpeg=01;35:*.m2v=01;35:*.mkv=01;35:*.ogm=01;35:*.mp4=01;35:*.m4v=01;35:*.mp4v=01;35:*.vob=01;35:*.qt=01;35:*.nuv=01;35:*.wmv=01;35:*.asf=01;35:*.rm=01;35:*.rmvb=01;35:*.flc=01;35:*.avi=01;35:*.fli=01;35:*.flv=01;35:*.gl=01;35:*.dl=01;35:*.xcf=01;35:*.xwd=01;35:*.yuv=01;35:*.cgm=01;35:*.emf=01;35:*.axv=01;35:*.anx=01;35:*.ogv=01;35:*.ogx=01;35:*.aac=00;36:*.au=00;36:*.flac=00;36:*.mid=00;36:*.midi=00;36:*.mka=00;36:*.mp3=00;36:*.mpc=00;36:*.ogg=00;36:*.ra=00;36:*.wav=00;36:*.axa=00;36:*.oga=00;36:*.spx=00;36:*.xspf=00;36:","SSH_AUTH_SOCK=/tmp/keyring-hiWWAO/ssh","DEFAULTS_PATH=/usr/share/gconf/gnome-classic.default.path","USERNAME=lusth","SESSION_MANAGER=local/goblin:@/tmp/.ICE-unix/1290,unix/goblin:/tmp/.ICE-unix/1290","XDG_CONFIG_DIRS=/etc/xdg/xdg-gnome-classic:/etc/xdg","DESKTOP_SESSION=gnome-classic","PATH=/home/lusth/bin:/home/lusth/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/home/lusth/android/tools:/home/lusth/android/platform-tools:.","PWD=/home/lusth/scam/testing","GDM_KEYBOARD_LAYOUT=us","EDITOR=vim","LANG=en_US.UTF-8","GNOME_KEYRING_PID=1271","MANDATORY_PATH=/usr/share/gconf/gnome-classic.mandatory.path","GDM_LANG=en_US.utf8","UBUNTU_MENUPROXY=libappmenu.so","GDMSESSION=gnome-classic","HOME=/home/lusth","SHLVL=2","LANGUAGE=en_US:en","GNOME_DESKTOP_SESSION_ID=this-is-deprecated","LOGNAME=lusth","DBUS_SESSION_BUS_ADDRESS=unix:abstract=/tmp/dbus-E58H1584u0,guid=18338084dae6f82274bd6d1f00000023","XDG_DATA_DIRS=/usr/share/gnome-classic:/usr/share/gnome:/usr/local/share/:/usr/share/","LESSOPEN=| /usr/bin/lesspipe %s","WINDOWPATH=7","DISPLAY=:0.0","LESSCLOSE=/usr/bin/lesspipe %s %s","XAUTHORITY=/var/run/gdm/auth-for-lusth-WKYjxG/database","COLORTERM=gnome-terminal","_=/home/lusth/bin/scam"] ["scam","sicp3.s"] <builtIn fileName(item)> <builtIn lineNumber(item)> <builtIn stack-depth()> <builtIn set-cdr!(spot value)> <builtIn set-car!(spot value)> <builtIn set(id value # @)> <builtIn get(id # @)> <builtIn !=(@)> <builtIn =(@)> <builtIn neq?(@)> <builtIn ==(@)> <builtIn eq?(@)> <builtIn >=(@)> <builtIn >(@)> <builtIn <=(@)> <builtIn <(@)> <builtIn not(value)> <builtIn address(item)> <builtIn while(# $test $)> <builtIn if(# test $then $)> <builtIn cond(# $)> <builtIn lambda(# $params $)> <builtIn quote($item)> <builtIn expt(base exponent)> <builtIn atan(y x)> <builtIn cos(n)> <builtIn sin(n)> <builtIn log(n)> <builtIn exp(n)> <builtIn %(@)> <builtIn /(@)> <builtIn *(@)> <builtIn -(@)> <builtIn +(@)> <builtIn pp(a)> <builtIn fmt(format value)> <builtIn display(item)> <builtIn addSymbol(name init env)> <builtIn define(# $)> <builtIn return(# $item)> <builtIn begin(# $)> <builtIn scope(# $)> <builtIn inspect(# $expr)> <builtIn apply(f args)> <builtIn eval(expr context)> <builtIn include(# $fileName)> <builtIn list(@)> <builtIn list?(item)> <builtIn pair?(item)> <builtIn null?(item)> <builtIn type(item)> <builtIn car(items)> <builtIn cdr(items)> <builtIn cons(a b)> <builtIn gensym?(id)> <builtIn gensym(@)> <builtIn eof?(#)> <builtIn close(port)> <builtIn getInputPort(#)> <builtIn getOutputPort(#)> <builtIn setPort(port)> <builtIn open(name mode)> <builtIn pushBack(string)> <builtIn readUntil(string)> <builtIn readWhile(string)> <builtIn readLine(#)> <builtIn readToken(#)> <builtIn readString(#)> <builtIn readReal(#)> <builtIn readInt(#)> <builtIn readRawChar(#)> <builtIn readChar(#)> <builtIn time()> <builtIn exec(str)> <builtIn system(str)> <builtIn bindings(object)> <builtIn array(@)> <builtIn allocate(size)> <builtIn length(item)> <builtIn setElement(item index value)> <builtIn getElement(item index)> <builtIn symbol(str)> <builtIn throw(code @)> <builtIn catch(# $expr)> <builtIn string(item)> <builtIn real(item)> <builtIn int(item)> <builtIn ascii(str)> <builtIn trim(str)> <builtIn substring(needle haystack)> <builtIn stringWhile(str chars)> <builtIn stringUntil(expr chars)> <builtIn suffix(str size)> <builtIn prefix(str size)> <builtIn string-equal?(a b)> <builtIn string+(a b)> <builtIn gc()>) . "nsufficient funds")>) is <function make-withdraw(balance)>
> EXCEPTION: generalException
> file sicp3.s,line 28: set identifier resolved to type CONS, not SYMBOL
------------------------------------------
sicp3-support.s
------------------------------------------
0a1,51
> ;;; CODE TO SUPPORT CHAPTER 3 OF STRUCTURE AND INTERPRETATION OF
> ;;;  COMPUTER PROGRAMS
> ;;; NB. This code is *not* from the book
> 
> ;;; In addition to code supplied here
> ;;;**For 3.4, might want parallel-execute as implemented for MIT Scheme
> ;;;**For 3.5, need stream special forms, which are not in Standard Scheme
> 
> 
> ;;For Section 3.1.2 -- written as suggested in footnote,
> ;; though the values of a, b, m may not be very "appropriately chosen"
> (define (rand-update x)
>   (let ((a 27) (b 26) (m 127))
>     (modulo (+ (* a x) b) m)))
> 
> 
> ;;For Section 3.3.4, used by and-gate
> ;;Note: logical-and should test for valid signals, as logical-not does
> (define (logical-and x y)
>   (if (and (= x 1) (= y 1))
>       1
>       0))
> 
> 
> ;;For Section 3.5 -- useful for looking at finite amounts of infinite streams
> ;;Print the first n elements of the stream s.
> ;;One version prints on one line, one on separate lines
> 
> (define (print-n s n)
>   (if (> n 0)
>       (begin (display (stream-car s))
>              (display ",")
>              (print-n (stream-cdr s) (- n 1)))))
> 
> (define (print-n s n)
>   (if (> n 0)
>       (begin (newline)
>              (display (stream-car s))
>              (print-n (stream-cdr s) (- n 1)))))
> 
> 
> ;;For Section 3.5.2, to check power series (exercises 3.59-3.62)
> ;;Evaluate and accumulate n terms of the series s at the given x
> ;;Uses horner-eval from ex 2.34
> (define (eval-power-series s x n)
>   (horner-eval x (first-n-of-series s n)))
> (define (first-n-of-series s n)
>   (if (= n 0)
>       '()
>       (cons (stream-car s) (first-n-of-series (stream-cdr s) (- n 1)))))
> ------------------------------------------
------------------------------------------
sine.s
------------------------------------------
37,86c37,38
< # x     y
< -2.0000000000   -0.9092974268
< -1.7500000000   -0.9839859469
< -1.5000000000   -0.9974949866
< -1.2500000000   -0.9489846194
< -1.0000000000   -0.8414709848
< -0.7500000000   -0.6816387600
< -0.5000000000   -0.4794255386
< -0.2500000000   -0.2474039593
< 0.000000e+00    0.000000e+00
< 0.2500000000    0.2474039593
< 0.5000000000    0.4794255386
< 0.7500000000    0.6816387600
< 1.0000000000    0.8414709848
< 1.2500000000    0.9489846194
< 1.5000000000    0.9974949866
< 1.7500000000    0.9839859469
< 2.0000000000    0.9092974268
< 2.2500000000    0.7780731969
< 2.5000000000    0.5984721441
< 2.7500000000    0.3816609921
< 3.0000000000    0.1411200081
< 3.2500000000    -0.1081951345
< 3.5000000000    -0.3507832277
< 3.7500000000    -0.5715613187
< 4.0000000000    -0.7568024953
< 4.2500000000    -0.8949893582
< 4.5000000000    -0.9775301177
< 4.7500000000    -0.9992927890
< 5.0000000000    -0.9589242747
< 5.2500000000    -0.8589344934
< 5.5000000000    -0.7055403256
< 5.7500000000    -0.5082790775
< 6.0000000000    -0.2794154982
< 6.2500000000    -0.0331792165
< 6.5000000000    0.2151199881
< 6.7500000000    0.4500440738
< 7.0000000000    0.6569865987
< 7.2500000000    0.8230808790
< 7.5000000000    0.9379999768
< 7.7500000000    0.9945987791
< 8.0000000000    0.9893582466
< 8.2500000000    0.9226042102
< 8.5000000000    0.7984871126
< 8.7500000000    0.6247239538
< 9.0000000000    0.4121184852
< 9.2500000000    0.1738894854
< 9.5000000000    -0.0751511205
< 9.7500000000    -0.3195191936
< 10.0000000000   -0.5440211109
---
> EXCEPTION: nonFunction
> file sine.s,line 1: attempted to call STRING as a function
------------------------------------------
stack2.s
------------------------------------------
33,37c33,34
< EVALUATION ERROR: :stackError
< stack2.s,line 10: pop on empty stack
< 42
< world
< hello
---
> EXCEPTION: nonFunction
> file stack2.s,line 1: attempted to call STRING as a function
------------------------------------------
stack.s
------------------------------------------
38,40c38,39
< 42
< world
< hello
---
> EXCEPTION: undefinedVariable
> file stack.s,line 1: variable function is undefined
------------------------------------------
stream.s
------------------------------------------
40c40,41
< [ 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 ]
---
> EXCEPTION: undefinedVariable
> file stream.s,line 1: variable function is undefined
------------------------------------------
subset.s
------------------------------------------
61,68c61,62
< [ ] 
< [ 3 ] 
< [ 2 ] 
< [ 2 3 ] 
< [ 1 ] 
< [ 1 3 ] 
< [ 1 2 ] 
< [ 1 2 3 ] 
---
> EXCEPTION: undefinedVariable
> file subset.s,line 1: variable function is undefined
------------------------------------------
super.s
------------------------------------------
32,34c32,33
< hello, there
< hello, goodbye
< hello, world
---
> EXCEPTION: undefinedVariable
> file super.s,line 1: variable function is undefined
------------------------------------------
swap.s
------------------------------------------
15c15,16
< a is b and b is a
---
> EXCEPTION: undefinedVariable
> file swap.s,line 1: variable function is undefined
------------------------------------------
symbol2.s
------------------------------------------
26,42c26,27
< created a thunk...
< thunk is <THUNK 3237>
< changing a thunk...
< sqr is <function sqr(x)>
< thunk . code = head(sqr . parameters) is x
< <THUNK 3237>:
<     context: <OBJECT 966>
<     code: x
< forcing thunk, x is ID, x is declared globally with value 10...
< force(thunk) is 10
< changing a thunk...
< thunk . code = symbol("x") is :x
< <THUNK 3237>:
<     context: <OBJECT 966>
<     code: :x
< forcing thunk, x is SYMBOL...
< force(thunk) is :x
---
> EXCEPTION: undefinedVariable
> file symbol2.s,line 1: variable function is undefined
------------------------------------------
symbol.s
------------------------------------------
34,40c34,35
< obj's a was 2 (should be 2)
< obj's a is hello (should be hello)
< obj's a now is 3.2000000000 (should be 3.2)
< separate calls to symbol("a") compare equal
< a was wow
< a is 5
< a now is 6
---
> EXCEPTION: undefinedVariable
> file symbol.s,line 1: variable var is undefined
------------------------------------------
tailassign.s
------------------------------------------
27,50c27,28
< a is (1,2,3,4,5)
< after set a to its tail, a is (2,3,4,5)
< length(a) is 4
< type(a) is :LIST
< b was set to the original a
< b is (1,2,3,4,5)
< length(b) is 5
< type(b) is :LIST
< a is (2,3,4 # [11,12,13,14])
< a is (3,4 # [11,12,13,14])
< a is (4 # [11,12,13,14])
< a is [11,12,13,14]
< a is [12,13,14]
< a is [13,14]
< a is [14]
< 
< b is (1,2,3,4 # [11,12,13,14])
< b is (2,3,4 # [11,12,13,14])
< b is (3,4 # [11,12,13,14])
< b is (4 # [11,12,13,14])
< b is [11,12,13,14]
< b is [12,13,14]
< b is [13,14]
< b is [14]
---
> EXCEPTION: nonFunction
> file tailassign.s,line 1: attempted to call STRING as a function
------------------------------------------
throw.s
------------------------------------------
20c20,21
< f() returns "throw.s,line 5: variable a is undefined"
---
> EXCEPTION: undefinedVariable
> file throw.s,line 1: variable //var is undefined
------------------------------------------
toString.s
------------------------------------------
34,52c34,35
< list(1,2) is [1,2]
< ----------------
< "array" + string(array(1,2,3)) is "array[1,2,3]"
< ----------------
< fo is <f x:20>
< ----------------
< fa is [<f x:20>,<f x:20>]
< ----------------
< a is [<f x:1>,<f x:2>,<f x:<f x:20>>,<f x:[<f x:20>,<f x:20>]>]
< ----------------
< map(string,a) is ("<f x:1>","<f x:2>","<f x:<f x:20>>","<f x:[<f x:20>,<f x:20>]>")
< ----------------
< [<f x:1>,<f x:2>,<f x:<f x:20>>,<f x:[<f x:20>,<f x:20>]>]
< ----------------
< map: <f x:1>
< map: <f x:2>
< map: <f x:<f x:20>>
< map: <f x:[<f x:20>,<f x:20>]>
< ----------------
---
> EXCEPTION: syntaxException
> file toString.s,line 33: expecting CLOSE_PARENTHESIS, found END_OF_INPUT instead
------------------------------------------
trace.s
------------------------------------------
23,32c23,24
< tracing f...
< trace.s,line 5: var result = x,y = 0; 
< trace.s,line 6: result = x + result; 
< trace.s,line 7: if (x > 0) { var i = 42; g(); }
< tracing f...
< trace.s,line 9: var i = 42; 
< trace.s,line 10: g(); 
< in g...
< trace.s,line 12: result; 
< f(5) is 10
---
> EXCEPTION: nonFunction
> file trace.s,line 1: attempted to call STRING as a function
------------------------------------------
tree2.s
------------------------------------------
111,117c111,112
< inserting 2
< inserting 3
< inserting 1
< looking for 4: not found!
< looking for 2: it's an interior node!
< looking for 1: it's a leaf!
< good-bye!
---
> EXCEPTION: undefinedVariable
> file tree2.s,line 1: variable function is undefined
------------------------------------------
tree3.s
------------------------------------------
90,96c90,91
< inserting 2
< inserting 3
< inserting 1
< looking for 4: not found!
< looking for 2: it's an interior node!
< looking for 1: it's a leaf!
< good-bye!
---
> EXCEPTION: undefinedVariable
> file tree3.s,line 1: variable function is undefined
------------------------------------------
tree.s
------------------------------------------
112,120c112,113
< hello
< 1 inserted.
< 2 inserted.
< 3 inserted.
< insertion phase complete, tree is (1 () (2 () (3 () ()))).
< looking for 4: not found!
< looking for 2: it's an interior node!
< looking for 3: it's a leaf!
< good-bye!
---
> EXCEPTION: undefinedVariable
> file tree.s,line 1: variable var is undefined
------------------------------------------
try.s
------------------------------------------
28,30c28,29
< ERROR OBJECT: :mathError
< try.s,line 17: division: cannot divide by zero
< try block has a divide error
---
> EXCEPTION: undefinedVariable
> file try.s,line 1: variable function is undefined
------------------------------------------
tyro2.s
------------------------------------------
16,18c16,17
< EVALUATION ERROR: :styleViolation
< tyro2.s,line 6: 
< indentation is not properly aligned, should be 4 spaces, not 0
---
> EXCEPTION: nonFunction
> file tyro2.s,line 1: attempted to call STRING as a function
------------------------------------------
tyro.s
------------------------------------------
14,16c14,15
< EVALUATION ERROR: :styleViolation
< tyro.s,line 8: 
< next line continues this line, perhaps a missing semicolon?
---
> EXCEPTION: nonFunction
> file tyro.s,line 1: attempted to call STRING as a function
------------------------------------------
uninit.s
------------------------------------------
5,6c5,6
< EVALUATION ERROR: :uninitializedVariable
< uninit.s,line 3: variable x is uninitialized
---
> EXCEPTION: undefinedVariable
> file uninit.s,line 1: variable var is undefined
------------------------------------------
variadic.s
------------------------------------------
16,17c16,17
< goodbye, cruel world
< goodbye, cruel world
\ No newline at end of file
---
> EXCEPTION: undefinedVariable
> file variadic.s,line 1: variable function is undefined
------------------------------------------
variation2.s
------------------------------------------
34,39c34,35
< (x()) . a() yields...
< x:a() -> hello
< x:b() -> goodbye
< (y()) . a() yields...
< x:a() -> hello
< y:b() -> au revoir
---
> EXCEPTION: undefinedVariable
> file variation2.s,line 1: variable function is undefined
------------------------------------------
variation3.s
------------------------------------------
36,42c36,37
< x-obj . a() yields...
< x:a() -> hello
< x:b() -> goodbye
< y-obj . a() yields...
< x:a() -> hello
< y:b() -> au revoir
< run the old version of b, via prior: x:b() -> goodbye
---
> EXCEPTION: undefinedVariable
> file variation3.s,line 1: variable function is undefined
------------------------------------------
variation.s
------------------------------------------
32,37c32,33
< (x()) . a() yields...
< x:a() -> hello
< x:b() -> goodbye
< (y()) . a() yields...
< x:a() -> hello
< y:b() -> au revoir
---
> EXCEPTION: undefinedVariable
> file variation.s,line 1: variable function is undefined
------------------------------------------
virtual2.s
------------------------------------------
21,23c21,22
< a: x is 0
< b: x is 1
< a: x is 1
---
> EXCEPTION: undefinedVariable
> file virtual2.s,line 1: variable function is undefined
------------------------------------------
virtual.s
------------------------------------------
62,83c62,63
< number of x objects created: 2
< 5: x's a, calling b
<    x's b, calling a
< 4: x's a, calling b
<    x's b, calling a
< 3: x's a, calling b
<    x's b, calling a
< 2: x's a, calling b
<    x's b, calling a
< 1: x's a, calling b
<    x's b, calling a
< 0: x's a
< ------------------------------
< y's a, calling b
< y's b, calling x's version of a
< 3: x's a, calling b
< y's b, calling x's version of a
< 2: x's a, calling b
< y's b, calling x's version of a
< 1: x's a, calling b
< y's b, calling x's version of a
< 0: x's a
---
> EXCEPTION: undefinedVariable
> file virtual.s,line 1: variable var is undefined
------------------------------------------
while2.s
------------------------------------------
55,65c55,56
< before calling f(0)
< in while, returning!
< after calling f(0)
< before calling f(1)
< in fwhile, returning!
< after calling f(1)
< before calling g()
<     calling function r()
<     in function r
<     done calling function r()
< after calling g()
---
> EXCEPTION: undefinedVariable
> file while2.s,line 1: variable function is undefined
------------------------------------------
while3.s
------------------------------------------
36,57c36,37
< run through i and j, stopping when i * j is 9
< 0 * 0 is 0
< 0 * 1 is 0
< 0 * 2 is 0
< 0 * 3 is 0
< 0 * 4 is 0
< 0 * 5 is 0
< 0 * 6 is 0
< 0 * 7 is 0
< 0 * 8 is 0
< 0 * 9 is 0
< 1 * 0 is 0
< 1 * 1 is 1
< 1 * 2 is 2
< 1 * 3 is 3
< 1 * 4 is 4
< 1 * 5 is 5
< 1 * 6 is 6
< 1 * 7 is 7
< 1 * 8 is 8
< 1 * 9 is 9
< done
---
> EXCEPTION: undefinedVariable
> file while3.s,line 1: variable function is undefined
------------------------------------------
while-else.s
------------------------------------------
39,44c39,40
< i is 0
< i is 1
< i is 2
< i is 3
< i is 4
< i was too large!
---
> EXCEPTION: undefinedVariable
> file while-else.s,line 1: variable var is undefined
------------------------------------------
while.s
------------------------------------------
33,58c33,34
< while as imperative statement
< i is 0
< i is 1
< i is 2
< i is 3
< i is 4
< i is 5
< i is 6
< i is 7
< i is 8
< i is 9
< while as a function call
< i is 9
< i is 8
< i is 7
< i is 6
< i is 5
< i is 4
< i is 3
< i is 2
< i is 1
< i is 0
< user while that returns from global scope
< forcing test
< forcing body
< returning!
---
> EXCEPTION: undefinedVariable
> file while.s,line 1: variable function is undefined
------------------------------------------
wire.s
------------------------------------------
1,25c1,19
< function wire()
<     {
<     var value = 0;  //initial (nonsensical) value
<     var downstream = :null;
<     function register(object)
<         {
<         downstream = object join downstream;
<         object . recalculate();
<         }
<     function inform(object)
<         {
<         object . recalculate();
<         }
<     function set(newValue)
<         {
<         if (newValue != value)
<             {
<             value = newValue;
<             map(inform, downstream);
<             }
<         }
<     function get()
<         {
<         return(value);
<         }
---
> (define (wire )
>     (define value 0)  ;initial (nonsensical) value
>     (define downstream nil)
>     (define (register object)
>         (assign downstream (cons object downstream))
>         ((. object recalculate))
>         )
>     (define (inform object)
>         ((. object recalculate))
>         )
>     (define (set newValue)
>         (if (!= newValue value)
>             (begin
>                 (assign value newValue)
>                 (map inform downstream)
>                 )
>             )
>         )
>     (define (get) value)
27,28c21,22
<     this;
<     }
---
>     this
>     )
------------------------------------------
with.s
------------------------------------------
26,29c26,27
< o . x is 3
< o . y is 4
< o . x is 10
< o . y is 13
---
> EXCEPTION: nonFunction
> file with.s,line 1: attempted to call STRING as a function
------------------------------------------
x.s
------------------------------------------
10c10,11
< this is defined!
---
> EXCEPTION: undefinedVariable
> file x.s,line 1: variable defined? is undefined
------------------------------------------
z.s
------------------------------------------
16,18c16,17
< obj . a is 4
< obj . a is 4
< obj . a is 4
---
> EXCEPTION: undefinedVariable
> file z.s,line 1: variable function is undefined
------------------------------------------
zsieve.s
------------------------------------------
65,66c65,66
< this takes a while...
< [ 2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97 101 103 107 109 113 127 131 137 139 149 151 157 163 167 173 179 181 191 193 197 199 211 223 227 229 ]
---
> EXCEPTION: undefinedVariable
> file zsieve.s,line 1: variable function is undefined
------------------------------------------
