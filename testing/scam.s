(define (head x) (car x))
(define (tail x) (cdr x))
(define (join x,y) (cons x y))

(define (for # init $test $increment $)
    (while (eval $test #)
        (evalList $ #)
        (eval $increment #)
        )
    )

(define (for-each2 # $indexVar items $)
    (define result #f)
    (while (!= items nil)
        (set! $indexVar (car items) #)
        (set! 'result (evalList $ #))
        (set! 'items (cdr items))
        )
    result
    )

(define (for-each f x)
    (define (iter items)
        (cond
            ((null? items) nil)
            (else (f (car items)) (iter (cdr items)))
            )
        )
    (iter x)
    )

(define (+= # $v value) (set! $v (+ (eval $v #) value) #))
(define (-= # $v value) (set! $v (- (eval $v #) value) #))
(define (*= # $v value) (set! $v (* (eval $v #) value) #))
(define (/= # $v value) (set! $v (/ (eval $v #) value) #))

; object-related functions

(define old-type type)

(define (type x)
    (if (and (eq? (old-type x) 'CONS) (eq? (car x) 'object))
        (get 'label x)
        (old-type x)
        )
    )

(define (. obj $field) (get $field obj))

(define scam.s-old-plus +)
(define (+ @)
    (define (iter result items)
        (if (null? items)
            result
            (iter (scam.s-old-plus result (car items)) (cdr items))
            )
        )
    (iter 0 @)
    )
(define scam.s-old-times *)
(define (* @)
    (define (iter result items)
        (if (null? items)
            result
            (iter (scam.s-old-times result (car items)) (cdr items))
            )
        )
    (iter 1 @)
    )
(define scam.s-old-minus -)
(define (- @)
    (define (iter result items)
        (if (null? items)
            result
            (iter (scam.s-old-minus result (car items)) (cdr items))
            )
        )
    (cond 
        ((null? @) 0)
        ((null? (cdr @)) (iter 0 @))
        (else (iter (car @) (cdr @)))
        )
    )
(define scam.s-old-divides /)
(define (/ @)
    (define (iter result items)
        (if (null? items)
            result
            (iter (scam.s-old-divides result (car items)) (cdr items))
            )
        )
    (cond 
        ((null? @) 1)
        ((null? (cdr @)) (iter 1 @))
        (else (iter (car @) (cdr @)))
        )
    )
(define scam.s-old-and and)
(define (and # $)
    (define (iter items)
        (cond
           ((null? items) #t)
           ((eval (car items) #) (iter (cdr items)))
           (else #f)
           )
        )
    (iter $)
    )
(define scam.s-old-or or)
(define (or # $)
    (define (iter items)
        (cond
           ((null? items) #f)
           ((eval (car items) #) #t)
           (else (iter (cdr items)))
           )
        )
    (iter $)
    )
(define (dec x) (- x 1))
(define (inc x) (+ x 1))

(define (let # $inits $)
    (define v nil)
    (define e (scope this))
    (set! 'context # e)
    (for-each2 v $inits
        (addSymbol (car v) (eval (car (cdr v)) #) e)
        ;(println "adding " (car v) " from " $inits)
        ;(println "    its value is " (eval (car (cdr v)) #))
        ;(inspect e)
        )
    (evalList $ e)
    )

(define (let* # $inits $)
    (define v nil)
    (define e (scope this))
    (set! 'context # e)
    (for-each2 v $inits
        (addSymbol (car v) (eval (car (cdr v)) e) e)
        )
    (evalList $ e)
    )

(define (negative? n) (< n 0))
(define (positive? n) (> n 0))

(define (newline) (println))
(define (display x) (print x))
(define remainder %)
(define (append a b)
    (cond
        ((null? a) b)
        (else (cons (car a) (append (cdr a) b)))
        )
    )
(define (last-pair x)
    (cond
        ((null? x) nil)
        ((null? (cdr x)) x)
        (else (last-pair (cdr x)))
        )
    )
(define (reverse x)
    (define (iter store rest)
        (cond
            ((null? rest) store)
            (else (iter (cons (car rest) store) (cdr rest)))
            )
        )
    (iter nil x)
    )

(define (map op @)
    (define (map1 items)
        (cond
            ((null? items) nil)
            (else (cons (op (car items)) (map1 (cdr items))))
            )
        )
    (define (iter items)
        (cond
            ((null? (car items)) nil)
            (else (cons (apply op (map car items)) (iter (map cdr items))))
            )
        )
    (cond
        ((= (length @) 1) (map1 (car @)))
        (else (iter @))
        )
    )
(define (abs x) (if (< x 0) (- x) x))
(define (even? n) (= (% n 2) 0))
(define (odd? n) (= (% n 2) 1))
(define (integer? x) (eq? (type x) 'INTEGER))
(define (real? x) (eq? (type x) 'REAL))
(define (number? x) (or (integer? x) (real? x)))
(define (string? x) (eq? (type x) 'STRING))
(define (symbol? x) (eq? (type x) 'SYMBOL))

(define (caar x) (car (car x)))
(define (cadr x) (car (cdr x)))
(define (caddr x) (car (cdr (cdr x))))
(define (cadddr x) (car (cdr (cdr (cdr x)))))
(define (caddddr x) (car (cdr (cdr (cdr (cdr x))))))
(define (cadddddr x) (car (cdr (cdr (cdr (cdr (cdr x)))))))

(define (equal? a b)
    (cond
        ((null? a)
            (null? b))
        ((pair? a)
            (and (pair? b) (equal? (car a) (car b)) (equal? (cdr a) (cdr b))))
        (else
            (eq? a b))
        )
    )

(define (sqrt x) (expt x 0.5))

(define (cons-stream # a $b)
    (cons a (lambda () (eval $b #)))
    )

(define (stream-car s) (car s))
(define (stream-cdr s) ((cdr s)))
(define (stream-null? s) (null? s))
