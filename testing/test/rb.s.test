(define root nil)
(define (assert # $x)
    (if (not (eval $x #))
        (throw 'assertionError $x)
        )
    )

(define (node value left right)
    (define parent nil)
    (define color nil)

    (define (display)
        (println "value:  "  value)
        (println "left:   "  left)
        (println "right:  "  right)
        (println "parent: "  parent)
        (println "color:  "  color)
        )

    this
    )

(define (printTree t)
    (define (iter r indent)
        (if (null? r)
            (println "null")
            (begin
                (println (. r value)  "("  (. r color)  ")")
                (print indent "left:  ")
                (iter (. r left) (string+ indent "    "))
                (print indent  "right: ")
                (iter (. r right) (string+ indent "    "))
                )
            )
        )

    (iter t "   ")
    )

(define (insert t v op)
    (if (null? t)
        (begin
            (assign root (node v nil nil))
            (assign (. root parent) root)
            (insertionFixup root)
            )
        (begin
            (define lessThan (op v (. t value)))

            (cond
                ((and lessThan (valid? (. t left)))
                    (insert (. t left)  v  op)
                    )
                (lessThan
                    (assign (. t left) (node v nil nil))
                    (assign (. (. t left) parent) t)
                    (insertionFixup (. t left))
                    )
                ((valid? (. t right))
                    (insert (. t right)  v  op)
                    )
                (else
                    (assign (. t right) (node v nil nil))
                    (assign (. (. t right) parent) t)
                    (insertionFixup (. t right))
                    )
                )
            )
        )
    )
(define (prune x)
    (assert (leaf? x))
    (cond
        ((leftChild? x)
            (assign (. (parent x) left) nil)
            )
        ((rightChild? x)
            (assign (. (parent x) right) nil)
            )
        (else
            (assign root nil)
            )
        )
    )

(define (swapToLeaf x)
    (if (not (leaf? x))
        (begin
            (define y nil)
            (define temp nil)

            (if (valid? (. x right))
                (assign y (findMin (. x right)))
                (assign y (findMax (. x left)))
                )

            (assign temp (. x value))
            (assign (. x value) (. y value))
            (assign (. y value) temp)

            (swapToLeaf y)
            )
        x
        )
    )

(define (findMin x)
    (while (valid? (. x left))
        (assign x (. x left))
        )
    x
    )

(define (findMax x)
    (while (valid? (. x right))
        (assign x (. x right))
        )
    x
    )

(define (delete x)
    (assign x (swapToLeaf x))
    (deletionFixup x)
    ; (println "pruning "  (. x value))
    (prune x)
    )

(define (deletionFixup x)
    (while (and (false? (root? x)) (eq? (. x color) 'black))
        (cond
            ((red? (sibling x))
                (assign (. (parent x) color) 'red)
                (assign (. (sibling x) color) 'black)
                (rotate (sibling x) (parent x))
                ; should have black sibling now
                (assert (eq? (. (sibling x) color) 'black))
                )
            ((red? (nephew x))
                (assign (. (sibling x) color) (. (parent x) color))
                (assign (. (parent x) color) 'black)
                (assign (. (nephew x) color) 'black)
                (rotate (sibling x) (parent x))
                (assign x root)
                ; subtree is bh balanced
                ; with proper bh contribution
                )
            ((red? (niece x))
                ; nephew must be black
                (assign (. (niece x) color) 'black)
                (assign (. (sibling x) color) 'red)
                (rotate (niece x) (sibling x))
                ; should have red nephew now
                (assert (eq? (. (nephew x) color) 'red))
                )
            (else
                ; sibling  niece  and nephew must be black
                (assign (. (sibling x) color) 'red)
                (assign x (parent x))
                ; subtree is bh balanced
                ; but has deficit in bh contribution
                )
            )

        (assign (. x color) 'black)
        )
    )

(define (insertionFixup x)
    (assign (. x color) 'red)

    (while (and (not (root? x)) (eq? (. (. x parent) color) 'red))
        (if (red? (uncle x))
            (begin
                (assign (. (parent x) color) 'black)
                (assign (. (uncle x) color) 'black)
                (assign (. (grandparent x) color) 'red)
                (assign x (grandparent x))
                )
            (begin
                ; uncle must be black

                (if (not (linear? x (parent x) (grandparent x)))
                    (begin
                        (define oldParent (parent x))
                        (rotate x (parent x))
                        (assign x oldParent)
                        )
                    )

                (assign (. (parent x) color) 'black)
                ;(inspect (. (parent x) color))
                (assert (eq? (. (. x parent) color) 'black))
                (assign (. (grandparent x) color) 'red)
                (rotate (parent x) (grandparent x))
                )
            )
        )
    (assign (. root color) 'black)
    )

(define (root? x) (eq? x (. x parent)))
(define (leftChild? x) (eq? (. (parent x) left) x))
(define (rightChild? x) (eq? (. (parent x) right) x))
(define (leaf? x) (and (null? (. x left))(null? (. x right))))
(define (red? x) (and (valid? x) (eq? (. x color) 'red)))
(define (black? x) (or  (null? x) (eq? (. x color) 'black)))

(define (sibling x)
    (cond
        ((leftChild? x)
            (. (. x parent) right)
            )
        ((rightChild? x)
            (. (. x parent) left)
            )
        (else
            nil
            )
        )
    )

(define (niece x)       ; precondition: sibling exists
    (if (leftChild? x)
        (. (sibling x) left)
        (. (sibling x) right)
        )
    )

(define (nephew x)      ; precondition: sibling exists
    ;(inspect (sibling x))
    (if (leftChild? x)
        (. (sibling x) right)
        (. (sibling x) left)
        )
    )

(define (parent x) (. x parent))
(define (grandparent x) (parent (parent x)))
(define (uncle x)
    (cond
        ((leftChild? (parent x))
            (. (grandparent x) right))
        ((rightChild? (parent x))
            (. (grandparent x) left))
        (else
            nil)
        )
    )

(define (linear? x y z)
    (or
        (and (leftChild? x) (leftChild? y))
        (and (rightChild? x) (rightChild? y))
        )
    )

(define (rotate x p)
    (cond
        ((eq? (. p left) x) 
            ; rotate right
            (println "rotating right")
            (rotator x p 'right 'left)
            )
        ((eq? (. p right) x)
            ; rotate left
            (println "rotating left")
            (rotator x p 'left 'right)
            )
        (else
            (throw 'redBlackException "rotate error")
            )
        )
    )

(define (id x) x)

(define (rotator x p direction oppositeDirection)
    (define gp (parent p))
    (define beta (. x (id direction)))

    (assign (. p (id oppositeDirection)) beta)
    (if (valid? beta) (assign (. beta parent) p))

    (assign (. x (id direction)) p)
    (assign (. p parent) x)

    (if (eq? p gp)
        (begin
            (assign root x)
            (assign (. x parent) x)
            )
        (begin
            (if (eq? (. gp (id direction)) p)
                (assign (. gp (id direction)) x)
                (assign (. gp (id oppositeDirection)) x)
                )
            (assign (. x parent) gp)
            )
        )
    )

(define (findNode t v op)
    (cond
        ((or (null? t) (eq? v (. t value)))
            t
            )
        ((op v (. t value))
            (findNode (. t left) v op)
            )
        (else
            (findNode (. t right) v op)
            )
        )
    )

(define (main)
    (define i nil)
    (define num nil)
    (define x nil)
    (define input (array 1  2  9  3  6  4  7  8  5))

    (assign i 0)
    (while (< i (length input))
        (assign num (getElement input i))
        (println "inserting!")
        (insert root num <)
        (println num " inserted.")
        (printTree root)
        (assign i (+ i 1))
        )
    
    (println "insertion phase complete  tree is...")
    (printTree root)
    (println "deletion phase begins...")

    (assign i 0)
    (while (< i (length input))
        (assign num (getElement input i))
        (assign x (findNode root num <))
        (delete x)
        (println num " deleted.")
        (printTree root)
        (assign i (+ i 1))
        )

    (println "deletion phase complete  tree is...")
    (println "good-bye!")
    )

(println "hello");
(main)
------------------------------------------
def args: : (<object 4795> (else #t))
def args: : (<object 4795> (__builtin __context))
def args: : (<object 4795> (__main-lib this))
def args: : (<object 4795> (nil? null?))
def args: : (<object 4795> ((valid? x) (not (null? x))))
def args: : (<object 4795> ((head x) (car x)))
def args: : (<object 4795> ((tail x) (cdr x)))
def args: : (<object 4795> ((join x y) (cons x y)))
def args: : (<object 4795> (^ expt))
def args: : (<object 4795> (** expt))
def args: : (<object 4795> ((backquote # $items) (define (helper items) (inspect items) (inspect (get (quote __context) this)) (cond ((null? items) ) ((eq? (car items) (quote ,)) (cons (eval (cadr items) #) (helper (cddr items)))) (else (cons (car items) (helper (cdr items)))))) (helper $items)))
def args: : (<object 4795> ((set! # $x y @) (define env (if (null? @) # (car @))) (set $x y env)))
def args: : (<object 4795> ((set* @) (define obj (car @)) (define fields (cdr @)) (while (valid? (cddr fields)) (set (quote obj) (obj (car fields))) (set (quote fields) (cdr fields))) (set (car fields) (cadr fields) obj)))
def args: : (<object 4795> ((get* @) (define obj (car @)) (define fields (cdr @)) (while (valid? (cdr fields)) (set (quote obj) (obj (car fields))) (set (quote fields) (cdr fields))) (get (car fields) obj)))
def args: : (<object 4795> ((for # init $fortest $increment $) (define forresult ) (while (eval $fortest #) (set (quote forresult) (evalList $ #)) (eval $increment #)) forresult))
def args: : (<object 4795> ((for-each2 # $indexVar items $) (define result #f) (while (!= items ) (set $indexVar (car items) #) (set (quote result) (evalList $ #)) (set (quote items) (cdr items))) result))
def args: : (<object 4795> ((for-each f x) (define (iter items) (cond ((null? items) ) (else (f (car items)) (iter (cdr items))))) (iter x)))
def args: : (<object 4795> ((+= # $v value) (set $v (+ (eval $v #) value) #)))
def args: : (<object 4795> ((-= # $v value) (set $v (- (eval $v #) value) #)))
def args: : (<object 4795> ((*= # $v value) (set $v (* (eval $v #) value) #)))
def args: : (<object 4795> ((/= # $v value) (set $v (/ (eval $v #) value) #)))
def args: : (<object 4795> ((++ # $v) (set $v (+ (eval $v #) 1) #)))
def args: : (<object 4795> ((-- # $v) (set $v (- (eval $v #) 1) #)))
def args: : (<object 4795> (__type type))
def args: : (<object 4795> ((type x) (if (and (eq? (__type x) (quote CONS)) (eq? (car x) (quote __object))) (get (quote __label) x) (__type x))))
def args: : (<object 4795> ((class x) (get (quote __label) x)))
def args: : (<object 4795> ((is? x y) (cond ((null? x) #f) ((not (environment? x)) (eq? (type x) y)) ((and (environment? x) (or (eq? y (quote environment)) (eq? y (quote object)))) #t) ((and (valid? (get (quote __constructor) x)) (eq? (get* x (quote __constructor) (quote name)) y)) #t) (else (and (local? (quote parent) x) (is? (get (quote parent) x) y))))))
def args: : (<object 4795> ((object? x) (and (pair? x) (eq? (car x) (quote __object)))))
def args: : (<object 4795> ((closure? x) (and (object? x) (eq? (class x) (quote closure)))))
def args: : (<object 4795> ((builtin? x) (and (object? x) (eq? (class x) (quote builtIn)))))
def args: : (<object 4795> ((error? x) (and (object? x) (eq? (class x) (quote error)))))
def args: : (<object 4795> ((environment? x) (and (object? x) (eq? (class x) (quote environment)))))
def args: : (<object 4795> (function? closure?))
def args: : (<object 4795> ((and # $) (define (iter items) (cond ((null? items) #t) ((eval (car items) #) (iter (cdr items))) (else #f))) (iter $)))
def args: : (<object 4795> ((or # $) (define (iter items) (cond ((null? items) #f) ((eval (car items) #) #t) (else (iter (cdr items))))) (iter $)))
def args: : (<object 4795> ((dec x) (- x 1)))
def args: : (<object 4795> ((inc x) (+ x 1)))
def args: : (<object 4795> (__display display))
def args: : (<object 4795> ((print @) (while (valid? @) (display (car @)) (set! @ (cdr @))) (quote print-done)))
def args: : (<object 4795> ((println @) (apply print @) (print "
")))
def args: : (<object 4795> ((let # $inits $) (define v ) (define e (scope this)) (set (quote __context) # e) (for-each2 v $inits (addSymbol (car v) (eval (car (cdr v)) #) e)) (evalList $ e)))
def args: : (<object 4795> ((let* # $inits $) (define v ) (define e (scope this)) (set (quote __context) # e) (for-each2 v $inits (addSymbol (car v) (eval (car (cdr v)) e) e)) (evalList $ e)))
def args: : (<object 4795> ((evalList listOfitems env) (while (valid? (cdr listOfitems)) (eval (car listOfitems) env) (set (quote listOfitems) (cdr listOfitems))) (eval (car listOfitems) env)))
def args: : (<object 4795> ((negative? n) (< n 0)))
def args: : (<object 4795> ((positive? n) (> n 0)))
def args: : (<object 4795> ((newline) (println)))
def args: : (<object 4795> (remainder %))
def args: : (<object 4795> ((append a b) (cond ((null? a) b) (else (cons (car a) (append (cdr a) b))))))
def args: : (<object 4795> ((last-pair x) (cond ((null? x) ) ((null? (cdr x)) x) (else (last-pair (cdr x))))))
def args: : (<object 4795> ((reverse x) (define (iter store rest) (cond ((null? rest) store) (else (iter (cons (car rest) store) (cdr rest))))) (iter  x)))
def args: : (<object 4795> ((map op @) (define (map1 items) (cond ((null? items) ) (else (cons (op (car items)) (map1 (cdr items)))))) (define (iter items) (cond ((null? (car items)) ) (else (cons (apply op (map car items)) (iter (map cdr items)))))) (cond ((= (length @) 1) (map1 (car @))) (else (iter @)))))
def args: : (<object 4795> (integer int))
def args: : (<object 4795> ((abs x) (if (< x 0) (- x) x)))
def args: : (<object 4795> ((even? n) (= (% n 2) 0)))
def args: : (<object 4795> ((odd? n) (= (% n 2) 1)))
def args: : (<object 4795> ((integer? x) (eq? (type x) (quote INTEGER))))
def args: : (<object 4795> ((real? x) (eq? (type x) (quote REAL))))
def args: : (<object 4795> ((number? x) (or (integer? x) (real? x))))
def args: : (<object 4795> ((string? x) (eq? (type x) (quote STRING))))
def args: : (<object 4795> ((symbol? x) (eq? (type x) (quote SYMBOL))))
def args: : (<object 4795> ((array? x) (eq? (type x) (quote ARRAY))))
def args: : (<object 4795> ((true? x) x))
def args: : (<object 4795> ((false? x) (not x)))
def args: : (<object 4795> ((literal? x) (or (null? x) (eq? x #t) (eq? x #f) (string? x) (array? x) (integer? x) (real? x) (and (pair? x) (eq? (car x) (quote quote))))))
def args: : (<object 4795> ((atom? x) (not (or (pair? x) (string? x) (array? x)))))
def args: : (<object 4795> ((car-cdr items @) (while (valid? @) (cond ((= (car @) 0) (set (quote items) (car items))) (else (set (quote items) (cdr items)))) (set (quote @) (cdr @))) items))
def args: : (<object 4795> ((caar x) (car-cdr x 0 0)))
def args: : (<object 4795> ((cadr x) (car-cdr x 1 0)))
def args: : (<object 4795> ((caddr x) (car-cdr x 1 1 0)))
def args: : (<object 4795> ((cadddr x) (car-cdr x 1 1 1 0)))
def args: : (<object 4795> ((caddddr x) (car-cdr x 1 1 1 1 0)))
def args: : (<object 4795> ((cadddddr x) (car-cdr x 1 1 1 1 1 0)))
def args: : (<object 4795> ((cddr x) (cdr (cdr x))))
def args: : (<object 4795> ((cddr x) (car-cdr x 1 1)))
def args: : (<object 4795> ((cdddr x) (car-cdr x 1 1 1)))
def args: : (<object 4795> ((cddddr x) (car-cdr x 1 1 1 1)))
def args: : (<object 4795> ((cdddddr x) (car-cdr x 1 1 1 1 1)))
def args: : (<object 4795> ((equal? a b) (cond ((null? a) (null? b)) ((pair? a) (and (pair? b) (equal? (car a) (car b)) (equal? (cdr a) (cdr b)))) ((string? a) (string-equal? a b)) ((array? a) (array-equal? a b)) (else (eq? a b)))))
def args: : (<object 4795> ((array-equal? a b) (cond ((null? a) (null? b)) ((null? b) #f) (else (and (equal? (car a) (car b)) (array-equal? (cdr a) (cdr b)))))))
def args: : (<object 4795> ((string-compare a b) (cond ((and (null? a) (null? b)) 0) ((null? a) (- 0 (ascii (getElement b 0)))) ((null? b) (ascii (getElement a 0))) (else (if (== (ascii (getElement a 0)) (ascii (getElement b 0))) (string-compare (cdr a) (cdr b)) (- (ascii (getElement a 0)) (ascii (getElement b 0))))))))
def args: : (<object 4795> ((sqrt x) (expt x 0.500000)))
def args: : (<object 4795> ((stream-car s) (car s)))
def args: : (<object 4795> ((stream-cdr s) (define scdr (cdr s)) (define scddr (cdr scdr)) (cond ((null? (car scddr)) (car scdr)) (else (set-car! scdr (apply eval scdr)) (set-car! scddr ) (car scdr)))))
def args: : (<object 4795> ((cons-stream # a $b) (list a $b #)))
def args: : (<object 4795> ((stream-null? s) (null? s)))
def args: : (<object 4795> ((code $s) $s))
def args: : (<object 4795> ((member? x items) (valid? (member x items))))
def args: : (<object 4795> ((member x items) (cond ((null? items) ) ((eq? x (car items)) items) (else (member x (cdr items))))))
def args: : (<object 4795> ((nequal? a b) (not (equal? a b))))
def args: : (<object 4795> ((getElement items @) (define __getElement (get (quote getElement) (get (quote __context) __context))) (while (valid? @) (set (quote items) (__getElement items (car @))) (set (quote @) (cdr @))) items))
def args: : (<object 4795> (__string+ string+))
def args: : (<object 4795> ((string+ str @) (while (valid? @) (set (quote str) (__string+ str (string (car @)))) (set (quote @) (cdr @))) str))
def args: : (<object 4795> (__string string))
def args: : (<object 4795> ((string x) (cond ((pair? x) (list-to-string x)) (else (__string x)))))
def args: : (<object 4795> ((list-to-string x) (define (iter z) (cond ((null? (cdr z)) (string+ (string (car z)) ")")) ((pair? (cdr z)) (string+ (string (car z)) " " (iter (cdr z)))) (else (string+ (string (car z)) " . " (string (cdr z)) ")")))) (cond ((thunk? x) (string+ "<thunk " (address x) ">")) ((closure? x) (string+ "<closure " (address x) ">")) ((error? x) (string+ "<error " (address x) ">")) ((environment? x) (string+ "<environment " (address x) ">")) ((object? x) (string+ "<object " (address x) ">")) (else (string+ "(" (iter x))))))
def args: : (<object 4795> ((thunk code environment) (define memo #f) this))
def args: : (<object 4795> ((thunk? item) (is? item (quote thunk))))
def args: : (<object 4795> ((force item) (eval (get (quote code) item) (get (quote environment) item))))
def args: : (<object 4795> ((assoc x y) (cond ((null? y) #f) ((equal? x (caar y)) (car y)) (else (assoc x (cdr y))))))
def args: : (<object 4795> ((make-assoc xs ys) (cond ((null? xs) ) (else (cons (list (car xs) (car ys)) (make-assoc (cdr xs) (cdr ys)))))))
def args: : (<object 4795> ((local? id env) (member? id (localNames env))))
def args: : (<object 4795> ((localNames env) (cadr env)))
def args: : (<object 4795> ((localValues env) (caddr env)))
def args: : (<object 4795> ((defined? id env) (not (error? (catch (eval id env))))))
def args: : (<object 4795> ((dot obj $name) (get $name obj)))
def args: : (<object 4795> ((builtinFunctions) (define vars (cadr __builtin)) (define vals (caddr __builtin)) (println "-----Builtin Functions-----") (while (valid? vars) (if (neq? (car (string (car vars))) "_") (if (builtin? (car vals)) (println "    " (car vals)))) (set! vars (cdr vars)) (set! vals (cdr vals)))))
def args: : (<object 4795> ((mainLibraryFunctions) (define vars (cadr __main-lib)) (define vals (caddr __main-lib)) (println "-----Main Library Functions-----") (while (valid? vars) (if (neq? (car (string (car vars))) "_") (if (closure? (car vals)) (println "    " (car vals)))) (set! vars (cdr vars)) (set! vals (cdr vals)))))
def args: : (<object 12462> (root ))
def args: : (<object 12462> ((assert # $x) (if (not (eval $x #)) (throw (quote assertionError) $x))))
def args: : (<object 12462> ((node value left right) (define parent ) (define color ) (define (display) (println "value:  " value) (println "left:   " left) (println "right:  " right) (println "parent: " parent) (println "color:  " color)) this))
def args: : (<object 12462> ((printTree t) (define (iter r indent) (if (null? r) (println "null") (begin (println (. r value) "(" (. r color) ")") (print indent "left:  ") (iter (. r left) (string+ indent "    ")) (print indent "right: ") (iter (. r right) (string+ indent "    "))))) (iter t "   ")))
def args: : (<object 12462> ((insert t v op) (if (null? t) (begin (assign root (node v  )) (assign (. root parent) root) (insertionFixup root)) (begin (define lessThan (op v (. t value))) (cond ((and lessThan (valid? (. t left))) (insert (. t left) v op)) (lessThan (assign (. t left) (node v  )) (assign (. (. t left) parent) t) (insertionFixup (. t left))) ((valid? (. t right)) (insert (. t right) v op)) (else (assign (. t right) (node v  )) (assign (. (. t right) parent) t) (insertionFixup (. t right))))))))
def args: : (<object 12462> ((prune x) (assert (leaf? x)) (cond ((leftChild? x) (assign (. (parent x) left) )) ((rightChild? x) (assign (. (parent x) right) )) (else (assign root )))))
def args: : (<object 12462> ((swapToLeaf x) (if (not (leaf? x)) (begin (define y ) (define temp ) (if (valid? (. x right)) (assign y (findMin (. x right))) (assign y (findMax (. x left)))) (assign temp (. x value)) (assign (. x value) (. y value)) (assign (. y value) temp) (swapToLeaf y)) x)))
def args: : (<object 12462> ((findMin x) (while (valid? (. x left)) (assign x (. x left))) x))
def args: : (<object 12462> ((findMax x) (while (valid? (. x right)) (assign x (. x right))) x))
def args: : (<object 12462> ((delete x) (assign x (swapToLeaf x)) (deletionFixup x) (prune x)))
def args: : (<object 12462> ((deletionFixup x) (while (and (false? (root? x)) (eq? (. x color) (quote black))) (cond ((red? (sibling x)) (assign (. (parent x) color) (quote red)) (assign (. (sibling x) color) (quote black)) (rotate (sibling x) (parent x)) (assert (eq? (. (sibling x) color) (quote black)))) ((red? (nephew x)) (assign (. (sibling x) color) (. (parent x) color)) (assign (. (parent x) color) (quote black)) (assign (. (nephew x) color) (quote black)) (rotate (sibling x) (parent x)) (assign x root)) ((red? (niece x)) (assign (. (niece x) color) (quote black)) (assign (. (sibling x) color) (quote red)) (rotate (niece x) (sibling x)) (assert (eq? (. (nephew x) color) (quote red)))) (else (assign (. (sibling x) color) (quote red)) (assign x (parent x)))) (assign (. x color) (quote black)))))
def args: : (<object 12462> ((insertionFixup x) (assign (. x color) (quote red)) (while (and (not (root? x)) (eq? (. (. x parent) color) (quote red))) (if (red? (uncle x)) (begin (assign (. (parent x) color) (quote black)) (assign (. (uncle x) color) (quote black)) (assign (. (grandparent x) color) (quote red)) (assign x (grandparent x))) (begin (if (not (linear? x (parent x) (grandparent x))) (begin (define oldParent (parent x)) (rotate x (parent x)) (assign x oldParent))) (assign (. (parent x) color) (quote black)) (assert (eq? (. (. x parent) color) (quote black))) (assign (. (grandparent x) color) (quote red)) (rotate (parent x) (grandparent x))))) (assign (. root color) (quote black))))
def args: : (<object 12462> ((root? x) (eq? x (. x parent))))
def args: : (<object 12462> ((leftChild? x) (eq? (. (parent x) left) x)))
def args: : (<object 12462> ((rightChild? x) (eq? (. (parent x) right) x)))
def args: : (<object 12462> ((leaf? x) (and (null? (. x left)) (null? (. x right)))))
def args: : (<object 12462> ((red? x) (and (valid? x) (eq? (. x color) (quote red)))))
def args: : (<object 12462> ((black? x) (or (null? x) (eq? (. x color) (quote black)))))
def args: : (<object 12462> ((sibling x) (cond ((leftChild? x) (. (. x parent) right)) ((rightChild? x) (. (. x parent) left)) (else ))))
def args: : (<object 12462> ((niece x) (if (leftChild? x) (. (sibling x) left) (. (sibling x) right))))
def args: : (<object 12462> ((nephew x) (if (leftChild? x) (. (sibling x) right) (. (sibling x) left))))
def args: : (<object 12462> ((parent x) (. x parent)))
def args: : (<object 12462> ((grandparent x) (parent (parent x))))
def args: : (<object 12462> ((uncle x) (cond ((leftChild? (parent x)) (. (grandparent x) right)) ((rightChild? (parent x)) (. (grandparent x) left)) (else ))))
def args: : (<object 12462> ((linear? x y z) (or (and (leftChild? x) (leftChild? y)) (and (rightChild? x) (rightChild? y)))))
def args: : (<object 12462> ((rotate x p) (cond ((eq? (. p left) x) (println "rotating right") (rotator x p (quote right) (quote left))) ((eq? (. p right) x) (println "rotating left") (rotator x p (quote left) (quote right))) (else (throw (quote redBlackException) "rotate error")))))
def args: : (<object 12462> ((id x) x))
def args: : (<object 12462> ((rotator x p direction oppositeDirection) (define gp (parent p)) (define beta (. x (id direction))) (assign (. p (id oppositeDirection)) beta) (if (valid? beta) (assign (. beta parent) p)) (assign (. x (id direction)) p) (assign (. p parent) x) (if (eq? p gp) (begin (assign root x) (assign (. x parent) x)) (begin (if (eq? (. gp (id direction)) p) (assign (. gp (id direction)) x) (assign (. gp (id oppositeDirection)) x)) (assign (. x parent) gp)))))
def args: : (<object 12462> ((findNode t v op) (cond ((or (null? t) (eq? v (. t value))) t) ((op v (. t value)) (findNode (. t left) v op)) (else (findNode (. t right) v op)))))
def args: : (<object 12462> ((main) (define i ) (define num ) (define x ) (define input (array 1 2 9 3 6 4 7 8 5)) (assign i 0) (while (< i (length input)) (assign num (getElement input i)) (println "inserting!") (insert root num <) (println num " inserted.") (printTree root) (assign i (+ i 1))) (println "insertion phase complete  tree is...") (printTree root) (println "deletion phase begins...") (assign i 0) (while (< i (length input)) (assign num (getElement input i)) (assign x (findNode root num <)) (delete x) (println num " deleted.") (printTree root) (assign i (+ i 1))) (println "deletion phase complete  tree is...") (println "good-bye!")))
hellodef args: : (<object 16752> (env (if (null? @) # (car @))))

def args: : (<object 16950> (env (if (null? @) # (car @))))
def args: : (<object 17069> (i ))
def args: : (<object 17069> (num ))
def args: : (<object 17069> (x ))
def args: : (<object 17069> (input (array 1 2 9 3 6 4 7 8 5)))
EXCEPTION: undefinedVariable
file rb.s,line 322: variable assign is undefined
