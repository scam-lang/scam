(define (run1)
    (println "need lazy evaluation!")
    )

(define (run2)
    (inspect (zeno_cost 20 150 0.25))
    )

(define (zeno_cost d c f)
    (cond
        ((<= (* c f) (/ 1 12.)) c)
        ((<= (/ d 2.) (/ 1 9600.)) (+ c 5))
        (else (+ c (zeno_cost (/ d 2.) (* c f) f)))
        )
    )

(define (run3)
    (inspect (min8 1 2 3 4 5 6 7 8))
    (inspect (min8 2 1 3 4 5 6 7 8))
    (inspect (min8 2 3 1 4 5 6 7 8))
    )

(define (min8 a b c d e f g h)
(define (min2 a b) (if (< a b) a b))
(define (min3 a b c) (if (< a b) (min2 a c) (min2 b c)))
(define (min4 a b c d) (if (< a b) (min3 a c d) (min3 b c d)))
(define (min5 a b c d e) (if (< a b) (min4 a c d e) (min4 b c d e)))
(define (min6 a b c d e f) (if (< a b) (min5 a c d e f) (min5 b c d e f)))
(define (min7 a b c d e f g) (if (< a b) (min6 a c d e f g) (min6 b c d e f g)))
    (if (< a b) (min7 a c d e f g h) (min7 b c d e f g h))
    )
        
(define (run4)
    (inspect (root3 8.0))
    (inspect (root3 27.0))
    )

(define (root3 x)
    (define (iter lower upper)
        (define guess (/ (+ upper lower) 2))
        (define try (* guess guess guess))
        (cond
            ((= try x) guess)
            ((> try x) (iter lower guess))
            (else (iter guess upper))
            )
        )
    (iter 1 x)
    )

(define (run5)
    (pt 9)
    )

(define (pt n)
    (define (indent count)
        (cond
            ((= count 0) 'done)
            (else (print " ") (indent (- count 1)))
            )
        )
    (define (ptLevel r c)
        (cond 
            ((= r 0) 1)
            ((= c 0) 1)
            ((= c r) 1)
            (else (+ (ptLevel (- r 1) (- c 1)) (ptLevel (- r 1) c)))
            )
        )

    (define (row-iter row)
        (define (col-iter col)
            (cond
                ((> col row) (println))
                (else
                    (print (ptLevel row col) " ")
                    (col-iter (+ col 1))
                    )
                )
            )
        (cond 
            ((> row n) (println))
            (else
                (indent (- n row))
                (col-iter 0)
                (row-iter (+ row 1))
                )
            )
        )
    (row-iter 0)
    )

(define (run6)
    (inspect (r-zorp 1 (lambda (x) (* x x))))
    (inspect (r-zorp 2 (lambda (x) (* x x))))
    (inspect (r-zorp 3 (lambda (x) (* x x))))
    (inspect (r-zorp 4 (lambda (x) (* x x))))
    (inspect (r-zorp 5 (lambda (x) (* x x))))
    (inspect (zorp 1 (lambda (x) (* x x))))
    (inspect (zorp 2 (lambda (x) (* x x))))
    (inspect (zorp 3 (lambda (x) (* x x))))
    (inspect (zorp 4 (lambda (x) (* x x))))
    (inspect (zorp 5 (lambda (x) (* x x))))
    )

(define (my-square x) (* x x))
(define (r-zorp i f)
    (cond
        ((< i 3) (f i))
        (else
            (+  (r-zorp (- i 1) f)
                (/  (my-square (- (r-zorp (- i 1) f) (r-zorp (- i 2) f)))
                    (+  (r-zorp (- i 3) f)
                        (* -2 (r-zorp (- i 2) f))
                        (r-zorp (- i 1) f)
                        )
                    )
                )
            )
        )
    )

(define (zorp i f)
    (define (iter a b c store)
        (cond
            ((= store 0) a)
            (else
                (iter
                    b c (+ c (/ (my-square (- c b)) (+ a (* -2 b) c)))
                    (- store 1)
                    )
                )
            )
        )
    (iter (f 0) (f 1) (f 2) i)
    )


(define (run7)
    (inspect (square 5))
    (inspect (halve 6))
    (inspect (halve 5))
    (inspect (halve 4))
    (inspect (babyl* 7 8))
    (inspect (babyl* 9 9))
    )

(define (square n)
    (define (iter result store)
        (cond
            ((= store 1) result)
            (else (iter (+ result store store -1) (- store 1)))
            )
        )
    (iter 1 n)
    )

(define (halve n)
    (define (iter result store)
        (cond
            ((= store 0) result)
            ((= (% store 2) 0) (iter (+ result 1) (- store 1)))
            (else (iter result (- store 1)))
            )
        )
    (iter 0 n)
    )

(define (babyl* a b)
    (/ (- (square (+ a b)) (square a) (square b)) 2)
    )

(define (run8)
    (inspect (ecf 0))
    (inspect (ecf 1))
    (inspect (ecf 2))
    )

(define (ecf terms)
    (define (iter count)
        (cond
            ((= terms count) 0.0)
            (else
                (/ 1 (+ 1 (/ 1 (+ 2 (* 2 count) (/ 1 (+ 1 (iter (+ count 1))))))))
                )
            )
        )
    (+ 2  (iter 0))
    )


(define (run9)
    (inspect (ramanujan 0))
    (inspect (ramanujan 1))
    (inspect (ramanujan 2))
    (inspect (ramanujan 10))
    (inspect (ramanujan 100))
    (println "the answer is 3")
    )

(define (ramanujan terms)
    (define (iter result store)
        (cond
            ((= store 0) result)
            (else (iter (sqrt (+ 1 (* (+ store 1) result))) (- store 1)))
            )
        )
    (iter 1 terms)
    )

(define (run10)
    (inspect (ramanujan2 0 2))
    (inspect (ramanujan2 1 2))
    (inspect (ramanujan2 2 2))
    (inspect (ramanujan2 10 2))
    (inspect (ramanujan2 50 2))
    (inspect (ramanujan2 2 3))
    (inspect (ramanujan2 50 3))
    (inspect (ramanujan2 50 10))
    (println "the answer is x + 1")
    )

(define (ramanujan2 terms x)
    (define (iter count)
        (cond
            ((= count terms) 0.0)
            (else (sqrt (+ 1 (* (+ x count 1) (iter (+ count 1))))))
            )
        )
    (sqrt (+ 1 (* x (iter 0))))
    )
;(run1)
;(run2)
;(run3)
;(run4)
;(run5)
;(run6)
;(run7)
;(run8)
;(run9)
;(run10)
