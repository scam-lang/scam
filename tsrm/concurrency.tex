\chapter{Concurrency}
\label{Concurrency}

\section{Concurrency constructs in Scam}

Scam provides for concurrency using heavyweight processes that
can communicate through shared memory. The following subsections
detail the built-in concurrency and concurrency control
functions and give details on
their use.

\subsection{Parallel execution of expressions}

Expressions in Scam can be evaluated in parallel with the variadic function
{\it pexecute}:

\begin{verbatim}
    (pexecute expr1 expr2 ... exprN)
\end{verbatim}

Each of the expressions will execute in parallel in separate processes.
Conventionally, the expressions are calls to no-argument functions, as in:

\begin{verbatim}
    (pexecute (f) (g) ((lambda () ...)))
\end{verbatim}

In the above example, the functions {\it f} and {\it g}
and the body of the lambda
will all be executed in parallel.

Prior to calling {\it pexecute}, one must allocate shared memory.
After {\it pexecute} returns, one can convert the data in shared memory into
a regular list. After conversion, one should free the shared memory.
Thus, a typical call to {\it pexecute} would look like:

\begin{verbatim}
    (allocateSharedMemory)
    (pexecute ...)
    (define result (convertSharedMemory))
    (freeSharedMemory)
\end{verbatim}
    
The next subsection explains how to set up shared
memory and how individual processes running in parallel can access
it.

\subsection{Shared memory}

Expressions executing in parallel can communicate through shared memory.
By default, shared memory is an array consisting of a single element.
To increase the amount of shared memory, one uses the {\it setSharedSize}
function.
As an example, the call:

\begin{verbatim}
    (setSharedSize 10)
\end{verbatim}

increases shared memory to 10 elements. One can retrieve the current size of
shared memory with a call to \verb!(getSharedSize)!.
Once the shared memory size has been set, one allocates and frees
shared memory with the no-argument {\it allocateSharedMemory}
and {\it freeSharedMemory}
functions.
Shared memory is initialized to zero. If some other initialization is
required, one can set values in shared memory after allocation but prior
to calling {\it pexecute}.

Each expression running in parallel executes in its own
process. Each process
can access the shared memory using the {\it setShared} and {\it getShared}
functions.  For example:

\begin{verbatim}
    (setShared i (+ (getShared i) 1))
\end{verbatim}

increments the value at shared memory location {\it i}. Note that there
is no implicit control over access to shared memory. Competing processes
may very well trash each other's updates to a shared memory location.

To control access to shared memory,
Scam provides a binary semaphore, as described
in the next subsection.

\color{red}
Warning:
\color{black}
only literal values should be stored in shared memory.
Otherwise, should garbage collection occur during parallel execution,
addresses stored in shared memory will point to stale memory.
Accessing stale memory
will most assuredly corrupt the current computation.
Moreover, storing non-primitive objects generated after a process 
is initiated cannot 
be seen by other processes, so storing them
in shared memory is pointless.

\subsection{Controlling access to shared memory}

Scam provides one concurrency control mechanism, a single binary
semaphore. For a process to acquire the semaphore, it issues a call to:

\begin{verbatim}
    (acquire)
\end{verbatim}

Likewise, to release the semaphore, a process would issue a call to:

\begin{verbatim}
    (release)
\end{verbatim}

Thus, to protect the update of a shared memory location, all processes
would follow the following pattern:

\begin{verbatim}
    (acquire)
    (setShared i (+ (getShared i) 1))
    (release)
\end{verbatim}

Note that a binary semaphore is {\it not} a mutex. It is possible for
one process to acquire the semaphore and another process to release it.
However, it is relatively straightforward to implement a mutex using
the built-in semaphore and {\it control memory}.
Control memory is described in the next subsection.

\subsection{Support for higher-level concurrency control mechanisms}

A different type of shared memory, called {\it control memory},
is available to store
information (such as {\it pid}s) for the use of higher-level control
structures. The manipulation of this section of memory is similar to
that of shared memory, with the following accessors and mutators:

\begin{itemize}
\item
        {\it getControlSize}, analogous to {\it getSharedSize}
\item
        {\it setControlSize}, analogous to {\it setSharedSize}
\item
        {\it setControl}, analogous to {\it setShared}
\item
        {\it getControl}, analogous to {\it getShared}
\end{itemize}

The default size of control memory is a single element.
To implement a mutex, one could store the {\it pid} of the acquiring
process in this element.
The no-argument
{\it getpid} function returns the process id of the calling process.
One could store the {\it pid} of the acquiring process,
in the single element of control  memory, and only allow
a process to release the semaphore if the process ids matched.

Like regular shared memory, only literal values should be stored
in control memory. Also like regular shared memory, elements are initialized
to zero.

\subsection{Debugging concurrency problems}

Getting concurrent execution correct is often a difficult process.
One can get a little information about the use of the semaphore 
by calling the {\it debugSemaphore} function:

\begin{verbatim}
    (debugSemaphore #t)
    (debugSemaphore #f)
\end{verbatim}

The first call turns debugging on while the second turns debugging off. When
on, attempts to acquire the semaphore produce output (on stdout) of
the form:

\begin{verbatim}
    process XXXX is acquiring...
\end{verbatim}

where XXXX is replaced by the process id of the acquiring process.
If the semaphore is actually acquired, debugging emits:

\begin{verbatim}
    process XXXX has acquired.
\end{verbatim}

On the releasing side, debugging emits messages of the form:

\begin{verbatim}
    process XXXX is releasing...
    process XXXX has released.
\end{verbatim}

When a process executing in parallel throws an exception, {\it pexecute} will
produce an error message similar to:

\begin{verbatim}
    file philosophers.scm,line 356: parallel execution of process 5827 failed
    try using *pexecute for more information
\end{verbatim}

One can print the process id of a process
using the no-argument {\it getpid} function.
Additionally, if a process terminates with an exception,
calling \verb!*!{\it pexecute} rather than {\it pexecute} may reveal the
exception that caused the failure.
The \verb!*!{\it pexecute} function simulates concurrency, but actually runs the
given expressions sequentially.
