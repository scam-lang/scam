\chapter{Concurrency}
\label{Concurrency}

\section{Concurrency constructs in Scam}

Scam provides for concurrency using heavyweight processes that
can communicate through shared memory. The following subsections
detail the built-in concurrency and concurrency control
functions and give details on
their use.

\subsection{Parallel execution of expressions}

Expressions in Scam can be evaluated in parallel with the variadic function
{\it pexecute}:

\begin{verbatim}
    (pexecute expr1 expr2 ... exprN)
\end{verbatim}

Each of the expressions will execute in parallel in separate processes.
Conventionally, the expressions are calls to no-argument functions, as in:

\begin{verbatim}
    (pexecute (f) (g) (lambda () ...))
\end{verbatim}

In the above example, the functions {\it f} and {\it g}
and the body of the lambda
will all be executed in parallel.

The result of a call to {\it pexecute} will be an array of all the values
in shared memory. The next subsection explains how to set up shared
memory and how individual processes running in parallel can access
it.

\subsection{Shared memory}

Expressions executing in parallel can communicate through shared memory.
By default, shared memory is an array consisting of a single element.
To increase the amount of shared memory, one uses the {\it setSharedSize}
function.
As an example, the call:

\begin{verbatim}
    (setSharedSize 10)
\end{verbatim}

increases shared memory to 10 elements.

Each expressions running in parallel has an associated process. Each process
can access the shared memory using the {\it setShared} and {\it getShared}
functions.  For example:

\begin{verbatim}
    (setShared i (+ (getShared i) 1))
\end{verbatim}

increments the value at shared memory location {\it i}. Note that there
is no implicit control over access to shared memory. Competing processes
may very well trash each other's updates to a shared memory location.

Shared memory is allocated when {\it pexecute} is called and each element
is initialized to zero. It is released
just before {\it pexecute} terminates. 

To control access, Scam provides a binary semaphore, as described
in the next subsection.

\subsection{Controlling access to shared memory}

Scam provides a single concurrency control mechanism, a single binary
semaphore. For a process to acquire the semaphore, it issues a call to:

\begin{verbatim}
    (acquire)
\end{verbatim}

Likewise, to release the semaphore, a process would issue a call to:

\begin{verbatim}
    (release)
\end{verbatim}

Thus, to protect the update of a shared memory location, all processes
would follow the following pattern:

\begin{verbatim}
    (acquire)
    (setShared i (+ (getShared i) 1))
    (release)
\end{verbatim}

Note that a binary semaphore is {\it not} a mutex. It is possible for
one process to acquire the semaphore and another process to release it.
However, it is relatively straightforward to implement a mutex using
the built-in semaphore and the {\it getpid} function. The no-argument
{\it getpid} function returns the process id of the calling process.
One would store the process id of the process that acquired
the semaphore somewhere in shared memory and only allow
a process to release the semaphore if the process ids matched.

The built-in semaphore is stored in shared memory.

\subsection{Debugging concurrency problems}

Getting concurrent execution correct is often a difficult process.
One can get a little information about the use of the semaphore 
by calling the {\it debugSemaphore} function:

\begin{verbatim}
    (debugSemaphore #t)
    (debugSemaphore #f)
\end{verbatim}

The first call turns debugging on while the second turns debugging off. When
on, attempts to acquire the semaphore produce output (on stdout) of
the form:

\begin{verbatim}
    process XXXX is acquiring...
\end{verbatim}

where XXXX is replaced by the process id of the acquiring process.
If the semaphore is actually acquired, debugging emits:

\begin{verbatim}
    process XXXX has acquired.
\end{verbatim}

On the releasing side, debugging emits messages of the form:

\begin{verbatim}
    process XXXX is releasing...
    process XXXX has released.
\end{verbatim}

When a process executing in parallel throws an exception, {\it pexecute} will
produce an error message similar to:

\begin{verbatim}
    file philosophers,line 356: parallel execution of process 5827 failed
    try using *pexecute for more information
\end{verbatim}

One can print the process id of a process
using the no-argument {\it getpid} function.
Additionally, if a process terminates with an exception,
calling {\it *pexecute} rather than {\it pexecute} may reveal the
exception that caused the failure.
The *pexecute function simulates concurrency, but actually runs the
given expressions sequentially.
