\chapter{Concurrency}
\label{Concurrency}

\section{Concurrency constructs in Scam}

Scam provides for concurrency using lightweight threads.
can communicate through shared memory. The following subsections
describes the built-in concurrency and concurrency control
functions and give details on
their use.

\subsection{Parallel execution of expressions}

Expressions in Scam can be evaluated in parallel with the variadic function
{\it pexecute}:

\begin{verbatim}
    (begin
        (thread expr1)
        (thread expr2)
        ...
        (thread exprN)
        )
\end{verbatim}

Each of the expressions will execute in parallel in separate processes.
Conventionally, the expressions are calls to no-argument functions, as in:

\begin{verbatim}
    (begin (thread f) (thread g) (thread (lambda () ...))))
\end{verbatim}

In the above example, the functions {\it f} and {\it g}
and the body of the lambda
will all be executed in parallel.

\subsection{Support for threads}

The following functions can be used to control threads and their
interactions:

\begin{description}
\item[getTID] This no-function returns the thread ID of the current thread.
\item[lock] This no-argument function acquires the built-in mutex.
\item[unlock] This no-argument function releases the built-in mutex.
Only the thread that acquired the mutex can release it.
\item[tjoin] This one-argument function causes the current thread to wait until
a particular thread terminates. If the desired thread has already terminated,
the function immediately returns. The desired thread is specified by passing
its thread ID to the function.
\end{description}

\subsection{Support for higher-level thread interactions}

[Description of thread.lib goes here]

\subsection{Debugging concurrency problems}

[Description of thread debugging goes here. What happens if a 
thread throws an exception, for example.]

[We will need something like this:]

\begin{verbatim}
    (debugMutex #t)
    (debugMutex #f)
\end{verbatim}

The first call turns debugging on while the second turns debugging off. When
on, attempts to acquire the mutex produce output (on stderr) of
the form:

\begin{verbatim}
    thread XXXX is acquiring...
\end{verbatim}

where XXXX is replaced by the process id of the acquiring process.
If the mutex is actually acquired, debugging emits:

\begin{verbatim}
    thread XXXX has acquired.
\end{verbatim}

On the releasing side, debugging emits messages of the form:

\begin{verbatim}
    thread XXXX is releasing...
    thread XXXX has released.
\end{verbatim}

[We need something like this to simulate 
When a process executing in parallel throws an exception, {\it pexecute} will
produce an error message similar to:

\begin{verbatim}
    file philosophers.scm,line 356: parallel execution of thread 3 failed
    try using ????? for more information
\end{verbatim}

If a thread terminates with an exception,
calling ???? may reveal the
exception that caused the failure.
The ???? call simulates concurrency, but actually runs the
given expressions sequentially in the parent process.
