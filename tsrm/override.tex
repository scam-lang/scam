\chapter{Overriding Functions}
\label{OverridingFunctions}

Suppose one wishes to count how many additions are performed when
code in a module is executed. One way to do this is to override
the built-in addtion function:

\begin{verbatim}
    (define plus-count 0)
    (define (+ a b)
        (assign plus-count (+ plus-count 1))
        (+ a b)
        )
\end{verbatim}

The problem here is that the original binding of \verb!+! is lost when the 
new version is defined.
Calling \verb!+! now will result in an infinite recursive
loop.

One solution is to save the original binding of \verb!+! before the new version
is defined:

\begin{verbatim}
    (define old+ +)
    (define (+ a b)
        (assign plus-count (old+ plus-count 1))
        (old+ a b)
        )
\end{verbatim}

With the original version of \verb!+! bound to old-plus,
now {\it a} and {\it b} can be added
together properly.
    
Scam automates this process with two functions, {\it redefine} and {\it prior}.
If the new version of a function is ``redefined'' rather than defined,
the previous
binding of the function is saved in the function closure that results.
The {\it prior} function 
is then used to retrieve this binding. Here is a rewrite
of the above code using these functions:

\begin{verbatim}
    (include "reflection.lib")

    (redefine (+ a b)
        (assign plus-count ((prior) plus-count 1))
        ((prior) a b)
        )
\end{verbatim}

The {\it redefine} and {\it prior} functions can be accessed by including
{\it reflection.lib}.
    
\section{Retrieving previous definition}

Another function in the {\it reflection} library, useful for retrieving previous definitions is
the {\it priorDefinition} function. It can be used to obtain the value
of a variable immediately prior to the new definition. For
example, consider the code:

\begin{verbatim}
    (define x 0)
    (define x 1)
    (inspect x)
\end{verbatim}

The output of this fragment is:

\begin{verbatim}
    x is 1
\end{verbatim}

as expected. The original definition of {\it x} with initial value zero
is shadowed by the subsequent version. To obtain the original value
of {\it x}, the {\it priorDefinition} function is used:

\begin{verbatim}
    (define x 0)
    (define x 1)
    (inspect (priorDefinition 'x x))
\end{verbatim}

The {\it priorDefinition} function is passed the symbol name and the current
value of the binding. Now, the output is:

\begin{verbatim}
    (priorDefinition (quote x) x) is 0
\end{verbatim}

The fact that {\it priorDefinition} takes the value along with the symbol
name allows definitions prior to the prior definition to be accessed.

\begin{verbatim}
    (define x 0)
    (scope
        (define x 1)
        (define x 2)
        (println "x is " x)
        (define y (priorDefinition 'x x))
        (println "x was " y)
        (assign y (priorDefinition 'x y))
        (println "before that, x was " y)
        )
\end{verbatim}

The output generated by evaluation this code is:

\begin{verbatim}
    x is 2
    x was 1
    before that, x was 0
\end{verbatim}

Note that definitions found in enclosing scopes can be retrieved
as well as prior definitions in the same scope.

\section{Implementing functions for prior definitions}

The redefine function works by adding a field to the closure
object generated by a function definition. It begins by
delaying evaluation of the  paramater list and the function
body and extracting the function name from the parameter list.

\begin{verbatim}
    (define (redefine # $params $)
        ;obtain the function name
        (define f-name (car $params))
        ;find the previous binding of the function name
        ;if no prior binding, use the variadic identity function 
        (if (defined? f-name #)
            (define f-prior (dot # (__id f-name)))
            (define f-prior (lambda (@) @))
            )
        ;now generate the function closure
        (define f (eval (cons 'define (cons $params $)) #))
        ;add the previous binding to the closure
        (addSymbol '__prior f-prior f)
        f
        )
\end{verbatim}

It continues by looking up the function name in the calling scope, \verb!#!,
binding that value to the symbol {\it f-prior}. If no binding exists,
an identity function is bound to {\it f-prior}.
Next, the desired function definition is processed by building
the code for a function definition from the delayed parameter list
and the delayed body.
Finally, a new field is added to the function closure and bound
to the prior function.

The {\it prior} function then looks for the added symbol and returns
its binding. It does so by extracting the constructor of the calling
environment and then retrieving the value of the symbol that was 
added by {\it redefine}:

\begin{verbatim}
    (define (prior #)
        (define f (dot # __constructor))
        (dot f __prior)
        )
\end{verbatim}

The {\it priorDefinition} function simply walks backward through the list of
enclosing scopes, setting a flag when the given name-value pair
is found. It then searches for the first binding of the given
name as it walks backwards from that point:

\begin{verbatim}
    (define (priorDefinition # name value)
        (define started #f)     ;note the current binding has been found
        (define searching #t)   ;note the previous binding has not been found
        (define result nil)     ;will hold the value of the previous binding
        (while (and searching (valid? #))
            ; extract the list of names and values from the current scope
            (define vars (localNames #))
            (define vals (localValues #))
            (while (and searching (valid? vars))
                (cond
                    ((and started (eq? name (car vars)))
                        ;prior binding found!
                        (assign searching #f)
                        (assign result (car vals))
                        )
                    ((and (eq? name (car vars)) (eq? value (car vals)))
                        ;current binding found
                        (assign started #t)
                        )
                    )
                ; chop of the current binding in this scope
                (assign vars (cdr vars))
                (assign vals (cdr vals))
                )
            ; chop of the current scope in the chain of scopes
            (assign # (dot # __context))
            )
        result
        )
