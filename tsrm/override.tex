\chapter{Overriding Functions}
\label{OverridingFunctions}

Suppose one wishes to count how many additions are performed when
code in a module is executed. One way to do this is to override
the built-in addtion function:

\begin{verbatim}
    (define plus-count 0)
    (define (+ a b)
        (assign plus-count (+ plus-count 1))
        (+ a b)
        )
\end{verbatim}

The problem here is that the original binding of {\it +} is lost when the 
new version is defined.
Calling {\it +} now will result in an infinite recursive
loop.

One solution is to save the original binding of {\it +} before the new version
is defined:

\begin{verbatim}
    (define old+ +)
    (define (+ a b)
        (assign plus-count (old+ plus-count 1))
        (old+ a b)
        )
\end{verbatim}

With the original version of {\it +} bound to {\it old+},
now {\it a} and {\it b} can be added
together properly.
    
Scam automates this process with two functions, {\it redefine} and {\it prior}.
If the new version of a function is ``redefined'' rather than defined,
the previous
binding of the function is saved in the function closure that results.
The {\it prior} function 
is then used to retrieve this binding. Here is a rewrite
of the above code using these functions:

\begin{verbatim}
    (include "reflection.lib")

    (redefine (+ a b)
        (assign plus-count ((prior) plus-count 1))
        ((prior) a b)
        )
\end{verbatim}

The {\it redefine} and {\it prior} functions can be accessed by including
{\it reflection.lib}.
    
\section{Implementing {\it redefine} and {\it prior}}

Recall that closures are objects in Scam.
The {\it redefine} function works by adding a field to the closure
object generated by a function definition. It begins by
delaying evaluation of the paramater list and the function
body and then extracting the function name from the parameter list.

\begin{verbatim}
    (define (redefine # $params $)
        ;obtain the function name
        (define f-name (car $params))
        ;find the previous binding of the function name
        ;if no prior binding, use the variadic identity function 
        (if (defined? f-name #)
            (define f-prior (get f-name #))
            (define f-prior (lambda (@) @))
            )
        ;now generate the function closure
        (define f (eval (cons 'define (cons $params $)) #))
        ;add the previous binding to the closure
        (addSymbol '__prior f-prior f)
        f
        )
\end{verbatim}

It continues by looking up the function name in the calling scope, {\it \#},
binding that value to the symbol {\it f-prior}. If no binding exists,
an identity function is bound to {\it f-prior}.
Next, the desired function definition is processed by building
the code for a function definition from the delayed parameter list
and the delayed body.
Finally, a new field is added to the function closure and bound
to the prior function.

The {\it prior} function then looks for the added symbol and returns
its binding. It does so by extracting the constructor of the calling
environment and then retrieving the value of the symbol that was 
added by {\it redefine}:

\begin{verbatim}
    (define (prior #)
        (define f (dot # __constructor))
        (get '__prior f)
        )
\end{verbatim}

\section{Cloning functions}

If you override a function defined in an enclosing scope, only calls
to
the overridden function {\it in the current scope} see the new definition.
Calls in the enclosing scope to the overridden function,
see the old version. A scope violation would occur otherwise.
To solve this problem, one can override the offending function
or more simply, clone it. Cloning a function creates a new
definition in the current scope. The only difference is the
definition environment is changed to the current environment,
the function parameter list and the body remain unchanged.

To clone a function, one calls the clone function, passing
in the function to be cloned. Consider this code:

\begin{verbatim}
    (include "reflection.lib")

    (define (f x) x)
    (inspect this)
    (inspect (dot f __context))

    (scope
        (inspect (local? 'f this))
        (define f (clone f))
        (inspect (local? 'f this))
        (inspect this)
        (inspect (dot f __context))
        )
\end{verbatim}

The output generated will be something like:

\begin{verbatim}
    this is <object 11698>
    (dot f __context) is <object 11698>
    (local? (quote f) this) is #f
    (local? (quote f) this) is #t
    this is <object 13317>
    (dot f __context) is <object 13317>
\end{verbatim}

The first two calls to {\it inspect} show that {\it f}'s definition
environment is the outer scope. The next call to {\it inspect} shows that
{\it f} is not defined in the inner scope. The last three calls show that
{\it f} is now defined with the proper definition environment.

For an example of using clone, see the chapter on Object.
